---
title: '[BOJ] 10157 자리배정'
date: 2022-03-07 17:20:00 +0900
categories: [Lecture, Problemset]
tags: [BOJ]
toc: false
---

[KOI 2014 E2](https://www.acmicpc.net/problem/10157)

이 문제는 표를 보고 규칙을 찾고, 그 규칙을 **코딩 가능한** 단위로 나눠서 풀어야 합니다. 표를 전체적으로 보면 왼쪽 아래부터 시작해서 위쪽으로 나선형을 그리며 중앙으로 이동하는 형태인 것을 알 수 있습니다. 하지만 그 "나선형" 을 어떻게 코딩으로 해야할까요? 나선형을 구성하는 규칙들을 찾고, 코드로 바꿔봅시다.

1. 세로 -> 가로 -> 세로 -> 가로 -> ... 순서대로 이동한다
2. 세로는 R, 가로는 C - 1 부터 시작해서 각 이동마다 이동횟수가 1씩 줄어든다
3. 세로 -> 가로로 한번 이동한 후에, 이동 방향이 바뀐다

아직 잘 와닿지 않을 수도 있지만, 단계적으로 코드를 작성해봅시다.

> 입력 처리

```cpp
int C, R, K;
cin >> C >> R >> K;

int x = 1, y = 0;
```

여기서, y가 0부터 시작하는 이유는, 처음에 한번 좌표가 증가하며 (1,1) 은 1번 으로 시작하기 위함입니다. 그렇게 하지 않으면 R만큼 반복한 뒤에는 y가 R + 1이 되어버리기 때문에 이와 같이 처리해주었습니다.

***

> 세로 -> 가로 -> 세로 -> 가로 -> ... 순서대로 이동한다

```cpp
while(true) {
    for (int i = 0; ; i++) {
        y += 1;
    }

    for (int i = 0; ; i++){
        x += 1;
    }
}
```

***

> 세로는 R, 가로는 C - 1 부터 시작해서 각 이동마다 이동횟수가 1씩 줄어든다

```cpp
while(true) {
    for (int i = 0; i < R; i++) {
        y += 1;
    }
    R--;

    for (int i = 0; i < C - 1; i++){
        x += 1;
    }
    C--;
}
```

***

> 세로 -> 가로로 한번 이동한 후에, 이동 방향이 바뀐다

"이동 방향이 바뀐다" 라는 말은, 1을 더해주다가 1을 빼준다, 그러니까 1이 -1로, 그리고 그 반대로 부호가 계속 **변한다** 라는 것을 알 수 있습니다. 프로그래밍에서, 이렇게 값이 변한다면 **변수** 를 사용해 주어야 한다는 의미일 가능성이 높습니다.

```cpp
int sw = 1;

while(true) {
    for (int i = 0; i < R; i++) {
        y += sw;
    }
    R--;

    for (int i = 0; i < C - 1; i++){
        x += sw;
    }
    C--;

    sw = -sw;
}
```

그럼 벌써 기본적인 코드가 완성되었네요! 여기서 이제 매 이동마다 번호를 하나씩 세주고, 번호가 만약에 우리가 찾는 대기번호(K) 라면 결과를 출력하는 것 까지 해서 코드를 마무리 해 보겠습니다.

```cpp
int C, R, K;
cin >> C >> R >> K;

int x = 1, y = 0;
int sw = 1, cnt = 0;

while(true) {
    for (int i = 0; i < R; i++) {
        y += sw;
        cnt++;
        if (cnt == K) break;
    }
    if (cnt == K) break;
    R--;

    for (int i = 0; i < C - 1; i++){
        x += sw;
        cnt++;
        if (cnt == K) break;
    }
    if (cnt == K) break;
    C--;

    sw = -sw;
}

cout << x << ' ' << y;
```

여기서 `break` 는 **현재 반복문** 만 나가주기 때문에, 바깥의 while까지 나가기 위해서 한번 더 break 해준 것에 유의해 주세요.

전체 로직은 위와 같지만, 아직 마지막으로 할 일이 남았습니다.

***

> 반례 찾기

이 문제는 반례를 문제에서 제시해 주었기 때문에 반례에 대한 처리만 해 주면 됩니다. 그 반례란 "입력받은 대기번호 K가 존재하지 않을 수 있다" 입니다. 그렇다면 끝까지 반복을 한 후에 찾았었는지 못찾았었는데 확인해 주어야 할까요? 훨씬 더 간단하게 할 수 있습니다. 나올 수 있는 최대 대기번호는 C * R이기 때문에, 만약 입력받은 K가 C * R보다 크다면 0을 출력하고 `return` 해 주어서 바로 끝내주면 됩니다.

***

> 전체 소스

```cpp
#include <iostream>

using namespace std;

int main() {
    int C, R, K;
    cin >> C >> R >> K;

    int x = 1, y = 0;
    int sw = 1, cnt = 0;

    if (C * R < K) {
        cout << 0;
        return 0;
    }

    while(true) {
        for (int i = 0; i < R; i++) {
            y += sw;
            cnt++;
            if (cnt == K) break;
        }
        if (cnt == K) break;
        R--;

        for (int i = 0; i < C - 1; i++){
            x += sw;
            cnt++;
            if (cnt == K) break;
        }
        if (cnt == K) break;
        C--;

        sw = -sw;
    }

    cout << x << ' ' << y;
}
```