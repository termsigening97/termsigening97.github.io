---
title: 'Clean Architecture - 시스템 설계'
date: 2022-03-01 12:00:00 +0900
categories: [Lecture, Basic]
tags: [Architect]
---

## 프로그래밍 패러다임

### 구조적 프로그래밍structured programming

1968년 Edsger Wybe Dijkstra가 발견했으며, 무분별한 점프(goto)는 프로그램 구조에 해롭다는 사실을 제시했고, 이런 점프들을 if/then/else와 do/while/until과 같은 것으로 대체하였다.

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

구조적 프로그래밍은 프로그래밍에서 반증 가능한 단위를 만들어낼 수 있으며, 그럼으로 인해 기능적 분해를 할 수 있게 해준다. 가장 작은 기능부터 가장 큰 컴포넌트까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록)만들기 위해 노력해야 한다.

※ 테스트는 어떤 문제가 있다는 것을 알려줄 뿐이지 어떤 문제가 없다는 것을 알려주진 못한다. 

### 객체 지향 프로그래밍object-oriented programming

1966년 Ole Johan Dal과 Kristen Nygaard에 의해 등장했으며, 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했고, 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다. 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 다형성이 등장하게 되었다.

- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

객체지향 프로그래밍이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 이용해서 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부 사항을 포함하는 모듈에 대해 독립성을 보장할 수 있게 된다.

### 함수형 프로그래밍functional programming

위의 두 패러다임보다 먼저 만들어졌으며, 람다 계산법의 연구 결과에 직접적인 영향을 받아 만들어졌다. 람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이고, 이는 함수형 언어에서는 할당문이 전혀 없다는 뜻이기도 하다.

- 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

가변 변수는 동시성 프로그래밍(스레드, 프로세스 등) 에서 많은 문제를 일으킨다. 그래서 상태 변화를 일으키는 대신에 지금까지의 모든 트랜잭션을 이어붙이고, 값이 필요할 때는 이 트랜잭션을 전부 처리하는 식으로 할 수 있다.

## SOLID 원칙

변경이 발생하는 부분을 변경이 발생하지 않는 부분과 분리해야한다. 변경이 발생하는 부분에서의 코드를 가능한 많이 변경이 발생하지 않는 부분으로 이동시켜야 한다는 뜻이다.

### SRP: 단일 책임 원칙Single Responsibility Principle

Conway 법칙에 따른 따름정리: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

`하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.`
여기서 액터란 사용자, 이해관계자 등을 의미한다.

### OCP: 개방-폐쇄 원칙Open-Closed Principle

기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.

`소프트웨어 개체artifact는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.`

다시 말해 소프트웨어의 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.

### LSP: 리스코프 치환 원칙Liskov Substitution Principle

하위 타입subtype에 관한 유명한 원칙이며, 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.

`S 타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.`

### ISP: 인터페이스 분리 원칙Interface Segregation Principle

소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

### DIP: 의존성 역전 원칙Dependency Inversion Principle

고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

## 컴포넌트 응집도

### REP: 재사용/릴리스 등가 원칙Reuse/Release Equivalence Principle
`재사용 단위는 릴리스 단위와 같다`

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다. 컴포넌트는 재사용이 가능해야한다.

### CCP: 공통 폐쇄 원칙Common Closure Principle
`동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라`

SRP를 컴포넌트 관점에서 다시 쓴 것으로, 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다. 유지보수성maintainability 은 재사용성보다 훨씬 중요하며, 코드가 반드시 변경되어야 한다면 여러 컴포넌트 도처에서 분산되어 발생되는 것 보다는 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.

### CRP: 공통 재사용 원칙Common Reuse Principle
`컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라`

같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다. 또한, 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다.


세 원칙은 서로 상충하며, 이 원칙들이 균형을 이루는 방법을 찾아야 한다. 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 시간이 흐르며 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해해야 한다. 예를들어 프로젝트 초기에는 CCP가 REP보다 중요하다.
REP - 재사용성을 위한 그룹
CCP - 유지보수성을 위한 그룹
CRP - 불필요한 릴리스를 피하기 위해 분리하기

## 컴포넌트 결합

### ADP: 의존성 비순환 원칙(Acyclic Dependencies Principle)
`컴포넌트 의존성 그래프에 순환이 있어서는 안된다`

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하면, 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다. 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다. 담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다. 그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자는 릴리스 된 버전을 사용한다.

컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다. 새 릴리스가 적용할 준비가 되었다는 판단이 들었을 때 새 릴리스를 사용하기 시작한다. 따라서 어떤 팀도 다른 팀에 좌우되지 않게 된다. 단, 이 작업은 의존성 구조에 순환이 있으면 안된다.

어느 컴포넌트도 시작해도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아가지 않는다면 된다.

#### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 DAG로 원상복귀 하는 일은 언제라도 가능하다. 다음 두가지 방법이 있다.

1. DIP을 적용하여, A->B(A가 B에 의존적) 일 때 A가 필요로 하는 메서드를 인터페이스로 작성하고 이 인터페이스는 A에 위치시키고, B는 이 인터페이스를 상속시킨다.

2. A와 B 모두가 의존하는 새로운 컴포넌트를 만들고, 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

#### 하향식top-down 설계

컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다. 컴포넌트 의존성 구조와 같이 큰 단위로 분해된 집단을 관찰하면 시스템의 기능적 측면을 컴포넌트가 어떤 식으로돈 표현하리라고 믿을 수 있지만, 이는 컴포넌트 의존성 다이어그램이 가진 속성이 아니다.

컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 오히려 빌드 가능성과 유지보수성을 보여주는 지도와 같다. 그래서 이러한 이유때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다. 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문이다.

### SDP: 안정된 의존성 원칙Stable Dependencies Principle
`안정성의 방향으로(더 안정된 쪽에) 의존하라`

설계는 결코 정적일 수 없기 때문에, 공통 폐쇄 원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다. 이처럼 컴포넌트의 일부는 변동성을 지니도록 설계된다.

안정성을 평가하는 방법은 Fan-in을 안으로 들어오는 의존성의 개수, Fan-out을 밖으로 나가는 의존성의 개수라고 하자. 이 때 개수의 단위는 클래스 개수이다. 그럼 불안정성 I는 `I = Fan-out / (Fan-in + Fan-out)` 라는 식으로 계산할 수 있으며 이 지표는 [0, 1] 범위의 값을 가지며 I가 0이면 최고로 안정된 컴포넌트라고 할 수 있다. 왜냐면 많은 컴포넌트가 하나의 컴포넌트를 의존하고 있을 수록 그 컴포넌트를 변경하기 힘들기 때문이다. SDP에서 컴포넌트의 I지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야한다.

하지만 모든 컴포넌트가 안정적이어야 하는 것은 아니란 것을 염두하자.

### SAP: 안정된 추상화 원칙Stable Abstractions Principle
`컴포넌트는 안정된 정도만큼만 추상화되어야 한다`

고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 (I=0) 컴포넌트에 위치해야 하고, 불안정한 컴포넌트는 반드시 변동성이 큰 소프트웨어만을 포함해야 한다. 하지만 고수준이 안정된 컴포넌트에 위치되면 수정하기가 힘드므로, OCP 원칙에 따라 추상 클래스로 만들어야 한다.

SAP는 안정성과 추상화 정도 사이의 관계를 정의하며, 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 이을 방해해서는 안된다고 한다. 또한, 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.

SAP와 SDP를 결합하면 컴포넌트에 대한 DIP가 아닌가하고 생각할 수 있지만, 컴포넌트는 클래스와 다르게 부분적으로만 추상적일 수 있다.

## 아키텍처

### 독립성

좋은 아키텍처는 다음을 지원해야 한다.

#### 유스케이스
시스템의 아키텍처는 시스템의 의도를 지원해야 한다. 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않지만, 행위를 명확히 하고 외부로 드러내며 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만들어야 한다.

#### 운영
어떤 과제가 있을 때, 이 과제를 해결할 수 있으면서 개선이 용이하도록 설계해야한다. 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

#### 개발
Conway의 법칙 "시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다"
많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

#### 배포
아키텍처는 '즉각적인 배포'를 목표로 설계해야하며, 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다. 이를 위해서도 시스템을 컴포넌트 단위로 적절하게 분할, 격리해야 하며 마스터 컴포넌트로 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.



// To-Do: 이후 추가 작성