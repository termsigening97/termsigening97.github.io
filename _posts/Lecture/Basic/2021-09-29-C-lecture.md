---
title: C언어 총정리
date: 2021-09-29 12:00:00 +0900
categories: [Lecture, Basic]
tags: [CPP, Essence]
---

> 디스코드에 작성했던 내용을 블로그로 이전 중입니다. 완성된 후에 내용이 더 깔끔하게 변경됩니다.
{: .prompt-warning }

이 강좌는 C언어의 기초 필수 문법을 설명합니다. 초보자가 쉽고 빠르게 이해할 수 있도록 구성되어 있으며, 꼭 지금 알 필요 없는 어려운 개념들은 부록으로 정리하였습니다. 내용이 많이 함축되어 있기 때문에 모든 내용을 정확히 이해하고 넘어가도록 합시다!

## Visual Studio 시작하기
***

[Visual Studio](https://visualstudio.microsoft.com/ko/vs/)

위 링크에서 Visual Studio Community 버전을 받아줍니다. 업데이트가 됨에 따라 이름에 2019, 2022 등 년도가 다를 수 있지만 최신버전을 받아주면 됩니다.

> 만약 컴퓨터 사양이 많이 낮다면, Visual Studio Code를 이용할 수도 있습니다.
{: .prompt-info }

실행 후, [C++를 사용한 데스크톱 개발] 을 체크해준 후에 설치를 진행합니다.

Visual Studio을 실행시킨 후, [새 프로젝트 만들기(N)] 를 클릭한 후에 언어를 C++으로 설정하고 [빈 프로젝트]를 고른 뒤에 프로젝트 이름과 경로는 아무렇게나 설정해준 뒤에 "만들기" 를 누릅니다

그 후에 "솔루션 탐색기" 라고 아래와 같은 구조로 되어있는 창에서

```
프로젝트명
├── 외부 종속성
├── 리소스 파일
├── 소스 파일     <---
└── 헤더 파일
```

[소스 파일] 을 선택한 후, 우클릭->추가->새 항목 을 선택합니다. (또는 단축키 [Ctrl+Shift+A])

그리고 [C++ 파일(.cpp)] 을 선택한 후(자동으로 선택되어있습니다) 원하는 이름으로 설정해 주되 확장자를 .cpp에서 .c로 변경합니다. .cpp는 c plus plus로 C++을 의미합니다.

그러면 방금 만든 파일이 열리면서 텍스트를 적을 수 있게 됩니다.

이제 이곳에서 첫 프로그램을 작성해보도록 하겠습니다. 영타가 느리다면 복사 붙여넣기를 해도 괜찮지만 더 잘 기억하기 위해 가능하면 따라서 적어보세요!

## 기초 사항
***

```c
#include <stdio.h>

int main() {

  printf("Hello, World!");

  return 0;
}
```

위 코드를 작성하고 [Ctrl+F5] 단축키를 누르면 콘솔 창(cmd, 명령프롬프트)이 열리며
`Hello, World!`
라는 문장이 출력됩니다. 이제 각 코드가 무엇을 의미하는지 한번 알아보도록 합시다.

* `#include` 는 다른 코딩파일을 가져오겠다는 뜻이고, `<stdio.h>` 는 [Standard Input/Output library] 로써 C언어를 사용하기 위해 필수로 가져와야 하는 파일입니다.

* `int main() { ... }` 는 **함수** 라고 하는데, 이는 한참 뒤에 설명될 개념이니 그 전까지는 꼭 적어줘야 한다고 알아두시면 됩니다. 모든 프로그램은 이 main 함수에서 시작합니다. `return 0;` 또한 함수에서 배우는 내용입니다.

그리고 각 문장을 보시면 끝에 ;(세미콜론) 이 보이는데, 이는 프로그래밍에서 "문장의 끝"을 나타냅니다. 몇몇 언어마다 차이는 있지만, 대부분 ;를 적어주지 않으면 그건 문장이 끝나지 않았다라고 판단하게 됩니다. 그러니까, 프로그래밍에서 아무리 띄어쓰기를 하던 줄바꿈을 하던 ;가 있으면 상관없습니다. 또한 중괄호 {} 도 비슷한 역할을 하는데, 여러 줄의 코드가 한 문장 안에 들어가야 할 때 사용됩니다. 일단은 익숙해지기 위해서 앞으로 예제들을 보며 익혀봅시다.

### 주석Comment

더 자세한 설명을 하기에 앞서 "주석(Comment)" 이라는 개념에 대해서 설명해 드리겠습니다.
주석이란, 코드를 읽는 사람을 위해 적어주는 것으로 실제 프로그램에는 아무런 영향이 없는 글자입니다. 주석을 작성하기 위해서는 **//** 나 **/\* \*/** 을 사용하게 되는데,

```c
#include <stdio.h>

int main() {

  // printf("실행 안됨");

  /*
    printf("이것도");
    printf("실행");
    printf("안됨");
  */

  return 0;
}
```

//는 한줄만, /\* \*/는 여러 줄을 주석처리하기 위해 사용합니다.

## 변수Variable
***

프로그래밍에서는 여러가지 값들을 기억해둘 필요가 있습니다. 게임을 예로 들자면 체력이나 공격력, 돈 같은 능력치가 있을수도 있고, 웹사이트의 경우 아이디나 비밀번호 등이 될 수 있죠.

이 값을 기억하기 위한 공간이 **변수**입니다. 변수는 특정한 자료형(data type)의 값을 저장하는 공간의 이름으로, 컴퓨터의 메모리인 램(RAM)에다 정보를 저장합니다. 자료형, 혹은 타입(type) 이라 불리는 내용은 나중에 설명됩니다.

```c
#include <stdio.h>

int main() {

  int a;
  a = 5;

  return 0;
}
```

위 코드는 a라는 변수를 작성하고, 5를 대입하는 코드입니다.

`int a;` 와 같이 작성하는 것을 **"변수를 선언한다"** 라고 하고, `<자료형> <변수이름>` 의 형태로 선언합니다.

이 때, 변수 이름에는 규칙이 있는데

1. 변수 이름은 대소문자를 구별한다
  * `a`와 `A`는 서로 다른 변수입니다.

2. 변수 이름은 숫자로 시작할 수 없다
  * `1coin` 은 불가능하지만, `coin1` 과 같이 첫번째에 있지만 않으면 됩니다.

1. 변수 이름에는 \_ 를 제외한 특수문자가 들어갈 수 없다
  * `sigening2774@naver.com`, `test value`, `hashtag#` 등은 전부 안되고 \_ 만 가능합니다.

그리고 가능하면 한글 변수는 작성하지 말아주세요.

> 이 선언하는 작업을 하면 컴퓨터는 메모리(RAM)에서 비어있는 공간을 알아서 찾아서 자료형의 크기만큼의 공간을 확보하고, 그 공간의 주소를 변수(예제에서는 a)가 가리키게 합니다. 그럼 `a = 5;` 처럼 변수를 다룰 때는 a가 가지고있는 메모리(RAM)의 주소에다가 값을 넣는다는 것과 같은 의미입니다. 또한 RAM은 Random Access Memory로, 빈 장소를 무작위로 빠르게 찾아주기 때문에 붙은 이름입니다.
{: .prompt-info }

## 자료형DataType
***

프로그래밍에서는 자료형이라는게 존재하는데, 메모리의 양도 한정되어있어서 크기가 적당해야 하는 이유도 있고, 자료형별로 연산이 다르기 때문에 존재하는 등 여러가지 이유가 있습니다. 이 자료형은 크게 3가지가 있는데, **정수형**, **실수형**, **문자형** 입니다.

<table>
<thead>
  <tr>
    <th>종류</th>
    <th>명칭</th>
    <th>크기</th>
    <th>값 범위</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td rowspan="3">정수형</td>
    <td>short</td>
    <td>2</td>
    <td>-32768 ~ 32767</td>
  </tr>
  <tr>
    <td>int</td>
    <td>4</td>
    <td>-2147483648 ~ 2147483647</td>
  </tr>
  <tr>
    <td>long</td>
    <td>4</td>
    <td>-2147483648 ~ 2147483647</td>
  </tr>
  <tr>
    <td>문자형</td>
    <td>char</td>
    <td>1</td>
    <td>-128 ~ 127</td>
  </tr>
  <tr>
    <td rowspan="2">부동소수점형</td>
    <td>float</td>
    <td>4</td>
    <td>1.2E-38 ~ 3.4E38</td>
  </tr>
  <tr>
    <td>double</td>
    <td>8</td>
    <td>2.2E-308 ~ 1.8E308</td>
  </tr>
</tbody>
</table>

1바이트는 8비트에 해당하고, 1비트는 0과 1만을 가지고 있는데, 이를 이용해 2진수를 만들어 1바이트의 경우 2의 8승을, 4바이트의 경우 2의 32승의 숫자까지 표현할 수 있음을 의미합니다.

**정수형**
* short, int, long 이 해당되며, "정수형" 은 말 그대로 정수이기 때문에 소수점이 없는 숫자만 저장할 수 있습니다.

**문자형**
* char 가 해당되고, 일단은 숫자를 저장하는 정수형이지만 문자를 저장하는데 사용됩니다. 문자의 경우, 컴퓨터는 문자를 저장할 수 없기 때문에 각 문자에 대응하는 숫자가 있고, 문자를 저장할 때는 이에 해당하는 숫자로 저장되며 출력을 할 때는 그 숫자에 해당하는 문자를 출력합니다. 이 때 이 숫자들을 아스키 코드(ASCII Code) 라고 부릅니다.

**부동소수점형**
* float, double 이 해당되며, 실수형이라고도 불리며 소수점을 가질 수 있는 자료형입니다. 부동 소수점(floating point) 은 말 그대로 소수점이 부동(float) 할 수 있음을 의미합니다. 주의할 점은, 실제 소수점 값을 가지고 있기에는 값의 범위가 커서 실제로는 계산식을 통해 소수점을 예측하여 계산합니다. 그래서 오차가 발생할 수 있으며, float의 경우 약 8자리, double의 경우 약 16자리까지 정확하게 표현할 수 있습니다.

여기서 변수가 아니라 `3, 5` 처럼 직접 적어준 값을 **상수** 라고 하는데, 만약 `2.0` 이라고 적으면 이 값은 float형 상수일까요 double형 상수일까요? 정답은 double형입니다. 기본적으로 double형이 사용되고 만약 float형 상수를 사용하고싶다면 `2.0f` 과 같이 숫자 뒤에 f를 붙여주어야 하죠.

또, 문자 타입의 경우 A라는 문자를 표현하고 싶을때는 `'A'` 라고 작은 따옴표로 묶어주시고, 문자가 여러개인 문자열을 사용하고 싶으시면 `"Hello, World"` 처럼 큰따옴표로 묶어주시면 됩니다.

살짝 팁을 알려드리자면 보통 int, double, char만 사용해도 아무 문제가 없습니다.

### 부록: 2진수 계산과 오버플로우

자료형이 가질 수 있는 최대 숫자보다 더 큰 값을 입력하면 오버플로우가 발생해서 해당 자료형이 가질 수 있는 최소 값으로, 반대로 최소 숫자보다 작은 값을 입력하면 언더플로우가 발생해서 해당 자료형이 가질 수 있는 최대 값으로 이동됩니다.

```c
#include <stdio.h>

int main() {
    short over = 32768;
    short under = -32769;

    printf("Overflow : %d\n", over);
    printf("Underflow : %d\n", under);

    printf("More Overflow : %d\n", over + 32768);

    return 0;
}
```
하지만 단순히 최대/최소가 되는 것이 아니라, 넘은 만큼 더 이동하게 됩니다. 이를 이해하기 위해서는 메모리 구조와 2진수를 알아야 하는데 1바이트를 기준으로 설명해드리겠습니다.

`0 0 0 0 | 0 0 0 0`

1바이트는 위와 같이 8비트로 이루어져 있습니다. 만약 0111 1111 이라면 이는 2^7인 128이 되는거죠. 그런데 2진수로는 음수를 표현할 방법이 없어서 맨 왼쪽에있는 비트(MSB) 를 가지고 0이 양수, 1이 음수와 같은 식으로 판단하는거죠. 그렇다면 char의 최대값인 127에 해당하는 0111 1111 에 1을 더하면 어떻게될까요? 일의자리부터 자리올림되어서 1000 0000 이 되는데, 이는 음수의 최솟값인 -128에 해당됩니다. 언더플로우와 더 자세한 설명은 2진수의 음수 표기방식인 2의 보수에 관련해서 찾아보시면 알 수 있습니다.

## scanf_s(), printf()로 입/출력하기
***

변수를 입력받을때는 scanf_s() 라는 함수를 쓰고, 변수를 출력할때는 printf() 라는 함수를 씁니다. 제일 처음에 `Hello, World!` 라는 메세지를 출력한 함수도 printf()인데, 어떻게 쓰는지 제대로 알아봅시다.

```c
#include <stdio.h>

int main() {

    int a, b;

    printf("숫자 2개를 입력하세요: ");
    scanf_s("%d%d", &a, &b);

    printf("덧셈 결과는: %d", a + b);

    return 0;
}
```

printf()에 변수나 값을 출력하는 경우나 scanf_s()로 입력받을 경우에는 안에 %d, %f와같은 **형식 지정자** 들이 들어가는데, 받으려는 자료형과 똑같은 형식지정자를 적어줘야 합니다. 자주 사용되는 형식 지정자들은 다음과 같습니다.

```
%d : 10진수 정수를 읽습니다 (decimal, 10진수)
%f : 실수를 읽습니다 (float)
%lf : 실수를 읽습니다 (double, lf는 long float의 약자)
%c : 문자를 읽습니다 (char)
%s : 문자열을 읽습니다 (string)
```

그래서 만약 int형 변수 3개에 값을 입력받고 출력한다면 다음과 같이 하면 됩니다.

```c
#include <stdio.h>

int main() {

    int a, b, c;

    scanf_s("%d%d%d", &a, &b, &c);

    printf("a: %d, b: %d, c: %d", a, b, c);

    return 0;
}
```

%d가 3개기 때문에 3개의 값을 입력받고, 순서대로 a, b, c에 넣어줍니다. 이 때, scanf_s()는 공백`' '`, 탭키`'\t'`, 줄바꿈`'\n'` 을 입력받았을때 하나를 입력받았다고 처리합니다. 여기서 scanf_s에 변수를 적어줄 때 변수의 이름 앞에 `&`을 적어주는데, 이는 변수의 **주소** 를 가져오라는 의미입니다. 무슨 말이냐면, 그냥 a, b, c라고 적어버리면 그건 a에 있는 값을 쓰겠다는 말인데 우리는 변수 a가 가지고 있는 공간, 즉 변수 a의 주소에 값을 넣어줘야하기 때문에 `&`을 쓰는거죠.

printf()의 경우에도 많이 헷갈릴 수 있는데, `"a: %d, b: %d, c: %d"` 라고 적어줬을 때 여기서 `"a: , b: , c: "`라고 적어준 부분은 그대로 출력되고, %d와 같이 형식지정자가 적힌 부분이 자동으로 오른쪽에 ,로 넣어준 값으로 순서대로 치환됩니다. 여기서 변수가 아니라 값이라는 단어를 쓴 이유는, 굳이 변수를 적지 않아도 무언가 값이 있다면 출력할 수 있기 때문이죠.

이해하기 힘들다면 어떻게 입력, 출력받는지 여러가지 방법으로 시도해 봐서 사용법을 완벽히 익히는 것이 중요합니다.


### 이스케이프 문자

이스케이프 문자는 줄바꿈이나 문법상 출력할 수 없는 문자를 출려가기 위해 만들어졌습니다. 보시면 바로 이해가 될거에요. \ (역슬래쉬) 의 경우 엔터키 바로 위에있는거로, 글꼴에 따라 원화표시가 나오지만 상관없습니다.

```
\0 : NULL 문자 (아무것도 아닌 문자)
\n : 줄 바꾸기 (엔터키 누른것과 동일)
\t : 수평탭 문자 (탭키 누른것과 동일)
\\ : 백슬래쉬(\)
\' : 작은 따옴표
\" : 큰 따옴표(쌍 따옴표)
%% : 퍼센트(%)
```

예시 코드:

```c
printf("안녕하세요.\n시즈닝입니다.");
```

출력 결과:

```
안녕하세요.
시즈닝입니다.
```

### **문자 타입을 받고 싶으실때**

printf()와 다르게 scanf_s()에는 \_s가 붙어있는데, 이는 safe의 약자입니다. 문자 타입을 받을 때 멈추지 않고 계속 받을 위험성이 있기 때문인데요, 그래서 문자타입을 받으실땐 최대 몇글자까지 입력받을것인지 뒤에 숫자로 적어줘야합니다.

예시 코드:
```c
char a, b;
scanf_s("%c%c", &a, 1, &b, 1);
printf("%c %c", a, b);
```
 char타입은 어짜피 한글자밖에 받지 못하기 때문에 그냥 1이라고 적어주면 되고, 문자열의 경우 나중에 배열/문자열 챕터에서 알려드리겠습니다.

 그런데 위의 코드를 실행하면 a에 입력받은건 잘 나오는데, b에 입력받은건 나오지 않을 수가 있습니다. `AB` 같이 입력하면 잘 나오는데, `A B` 와 같이 중간에 문자가 껴있으면 나오지가 않죠. 그 이유는 이전에 `A`라는 문자를 입력받았다고 할때, 그 뒤에 입력의 종료를 나타내는 문자도 같이 입력받기 때문이죠 (공백`' '`, 탭키`'\t'`, 줄바꿈`'\n'`)

 그래서 이 문자들을 무시해준다는 의미로 형식지정자 앞에 띄어쓰기를 해줄 수 있습니다.

```c
char a, b;
scanf_s("%c %c", &a, 1, &b, 1);
printf("%c %c", a, b);
```

## 연산자(Operator)
***

### 대입 연산자(Assignment Operator)
 위에 변수에서 배웠던 `=` 는 수학에서 사용되던 **좌변과 우변이 같다** 와 완전히 다른 의미입니다. 할당 연산자라고도 불리는 이것은, 오른쪽(r-value)에 있는 값을 왼쪽(l-value)에 넣어준다는 뜻이죠. 그래서 `a = 1205` 와 같이 하면 1205라는 값이 a라는 변수에 들어가게 됩니다. 이런 이유로 l-value라고 불리는 왼쪽값에는 값을 저장할 수 있는 변수만이 들어올 수 있어요.

 또한, 오른쪽에있는걸 왼쪽에 넣는것이기 때문에 다음과 같은 것도 가능합니다.
`a = b = c = d = e = 5`

 대입 연산자는 오른쪽에 있을 덧셈, 뺄셈 등의 연산을 기다려야하기 때문에 오른쪽부터 차례대로 계산되어 5개의 변수에 모두 5가 저장됩니다.

### 산술 연산자(Arithmetic Operator)
* \+ : 두 값을 더합니다. `3 + 5`    // 8
* \- : 두 값을 뺍니다. `7 - 5`   // 2
* \* : 두 값을 곱합니다. `2 * 3`   // 6
* / : 두 값을 나눕니다. `17 / 3`   // 5
* % : 두 값을 나눈 나머지를 구합니다. `123 % 10`   // 3

키보드에는 나눗셈 기호가 없기때문에 /를 나눗셈 연산자로 사용하고, 곱셈을 x라고 적기에는 문자 X와 비슷하니 *가 사용되었습니다.

특이하게 나머지 연산자가 존재하는데, 이게 프로그래밍에서는 매우 유용하게 쓰입니다. 실수형은 나머지를 구하는 방법이 다르기 때문에 정수형에만 지원이 되죠.

> 변수는 사용되기 전에 무조건 초기화가 되어 있어야 합니다. 대입 연산자로 아무 값도 넣어주지 않았다면 그 변수는 0을 가지고 있는게 아니라, 알수 없는 쓰레기 값을 가지고 있기 때문에 오류가 발생합니다.
{: .prompt-warning }

예제 코드:
```c
#include <stdio.h>
int main() {
  int a, b;
  a = 10;
  b = 3;
  printf("a + b 는 : %d \n", a + b);
  printf("a - b 는 : %d \n", a - b);
  printf("a * b 는 : %d \n", a * b);
  printf("a / b 는 : %d \n", a / b);
  printf("a %% b 는 : %d \n", a % b);
  return 0;
}
```

여기서 위의 설명과 예제 코드를 실행하셨다면 볼 수 있겠지만,  `17 / 3` 은 5 고, `10 / 3` 도 3.333...이 아니라 3입니다. 왜냐면 a의 자료형도 int, b의 자료형도 int기 때문에 연산 결과도 int가 나와서 소수점이 버려지게 됩니다.

그럼 만약 소수점이 필요하면 어떻게 해야할까요? 두 변수중 한 변수만 실수 타입이면 됩니다.

예제 코드:
```c
int a = 10, c = 4;
float b = 3;

printf("a / b 는 : %f \n", a / b);
printf("a / 3 는 : %f \n", a / 3);
printf("a / 3.0 는 : %f \n", a / 3.0);
printf("a / c 는 : %f \n", a / c);
printf("a / c 는 : %f \n", (double)a / c);
```

5개의 printf중 1번째, 3번째, 5번째줄에서는 소수점이 잘 계산되는것을 보실 수 있습니다. 그런데 왜 2개중 하나만 실수형이어도 계산이 될까요? 또 (double)은 뭘까요?

### 암시적 형변환, 명시적 형변환

프로그래밍에서는 **"형번환"** 이라는 개념이 존재합니다. 여기에는 **암시적 형변환**과 **명시적 형변환**이 존재하는데, 암시적 형변환은 자동으로 바뀌는거라 보시면 됩니다. 범위가 더 작은 타입에서 범위가 더 큰 타입으로는 자동으로 변환이 됩니다. 그래서 int와 double과 연산할때는 int가 double로, float와 double과 연산할때는 float가 double로 형변환이 되죠.

하지만 `int / int`과 같이 같은 타입끼리 연산을 할 때 등에 형변환이 필요해질 때는 명시적 형변환을 해주면 됩니다. 간단하게 값 앞에 `(<자료형>)` 을 적어주면 그 줄에서만 해당 값이 정해준 타입으로 바뀌게 됩니다. 그래서 5번째는 int끼리 나뉘어도 소수점이 계산된 것이죠.

### 대입-산술 연산자(Assignment-Arithmetic Operator)

 이름은 거창하게 지었지만(보통 그냥 대입연산자에 포함합니다) 표현을 축약한 것 뿐입니다. 만약 어떤 변수에 값을 계속 누적하고싶으면 어떻게 해야할까요?

```c
int a = 0;
a + 3;
a + 5;
```
이러면 a에 8이 들어가있을까요? 아닙니다. a는 그대로 0이죠. 왜냐면 a에는 0밖에 **대입** 하지 않았기 때문이에요. 그래서 값을 누적하려면
```c
int a = 0;
a = a + 3;
a = a + 5;
```
와 같이 해주어야 합니다. 그런데 프로그래밍을 하다보면 이런 연산을 자주하기 때문에 `a = a + 3` 와 같은 식을 축약한 `a += 3` 가 존재합니다. -=, *=, /=, %= 또한 당연히 존재하고, "변수의 값을 계산하고 바꿔준다" 라는 의미로 해석하거나 익숙해질때까지 축약이 안된 버전을 기억해두시는 것도 좋습니다.

***

지금까지는 값이 2개 필요한 이항 연산자를 배웠고, 이제 값 하나에만 쓰이는 단항 연산자를 보겠습니다.

### 부호 연산자(Sign Operator)
`-`, `+` 라는 연산자들이 이에 해당합니다. 사용법은
`+a` `-a`
와 같이 사용되는데, +는 사실 의미가 없고 -의 경우에는 부호를 반대로 바꿔줍니다.

### 증감 연산자(Increment and Decrement Operator)

`++`, `--` 라는 연산자들이 이에 해당합니다. 사용법은
`a++` `++a` `a--` `--a`
처럼 앞에(전위형)붙냐 뒤에(후위형)붙냐의 차이인데, 일단 무슨 역할을 하는 것인지 알아봅시다.

a++는 a += 1, 즉 a = a + 1과 같은 의미입니다. ++a도 a += 1과 같은 의미이죠. 그런데 여기서 차이는 연산 순서에 있습니다. 앞에 붙는 전위형의 경우 변수에 들어있던 값을 사용하기 전에 먼저 변수에 1을 더하고(해당 줄의 다른 모든 연산을 하기 전에 먼저 변수에 1을 더하고), 뒤에 붙는 후위형의 경우 변수의 값을 먼저 쓰게 한 뒤에 변수에 1을 더합니다(다른 모든 연산이 끝나고 1이 더해짐).

말로만 들으면 헷갈리기 때문에 예제 코드를 보여드리겠습니다.

```c
int a = 1;

printf("%d\n", ++a);   // 2
printf("%d\n", a++);   // 2
printf("%d\n", a);     // 3
a++;
++a;
printf("%d\n", a);     // 5

```
첫번째에는 먼저 더하고 변수를 썼기 때문에, a에 1을 더한 값인 2가 출력됩니다. 두번째에는 변수를 먼저 가져다 쓰고 이후에 더했기 때문에, 이전의 값인 2가 그대로 출력됩니다. 

세번째에는 두번째에서 출력이 끝나고 더해졌기 때문에 3이 나오고, 주변에 다른 식이 없을경우 a++나 ++a나 그게 그거기때문에 마지막에는 5라는 값이 나오게 됩니다. 한번 여러가지 방법으로 계산해 보고 이해해보세요.

***

마지막으로, 연산자는 수학의 연산순서를 그대로 따라갑니다. 그래서 곱셈과 나눗셈, 나머지 등을 먼저 계산하고 덧셈과 뺄셈은 나중에 계산하죠. 그래서 괄호 연산자 또한 존재합니다.

`(a + b) / 3 * (c - d)`

와 같은 식도 만들 수 있게 되죠.

### 부록: 비트 연산자

작성중입니다.

## 조건문
***

프로그래밍에서 특정한 경우에 특정한 결과가 일어나게 하려면 어떻게 해야할까요? 예를들어, 비밀번호에 숫자 최소 하나, 특수문자 하나, 대소문자 하나씩 필요하다는 것을 어떻게 확인할까요?

바로 이런 "만약에 ... 하면" 이라는 것을 코드로 가능하게 해주는 게 조건문입니다. 조건문에는 if문과 switch문이 있으니 한번 공부해봅시다.

### if, else, else if

if문의 사용법은 다음과 같습니다.

*조건문 예제1*
```c
int a;
scanf_s("%d", &a);
if (a == 0) {
  printf("입력받은 숫자는 0입니다.");
} else if (a < 0) {
  printf("입력받은 숫자는 음수입니다.");
} else {
  printf("입력받은 숫자는 양수입니다.");
}
```
위 프로그램은 정수를 하나 입력받아, 0인지 음수인지 양수인지를 구분해 주는 프로그램입니다. "만약" 이라는 뜻을 가진 if를 사용하고 있으며, 안쪽에는 주로 조건식이 들어가게 됩니다. (조금있다 알려드리겠습니다)

`if (<값>) { <실행될 코드> }`

if문의 ()안쪽에는 숫자가 들어가는데, 0은 거짓(False)를 의미하고 0이 아닌 **모든** 숫자는 참(True)를 의미합니다. 그리고 만약 값이 참(True)이라면 뒤에 이어진 중괄호의 내용을 실행하죠.

else if문은 if문의 바로 다음에만 쓰일 수 있고, 전에 있던 if문의 조건이 **만족하지 않을 경우**에만 넘어옵니다. 그리고 if문과 같이 조건을 추가로 확인하죠. 위의 코드를 예로 들자면, a가 0이 아닐 경우 else if문으로 넘어오고, 이 else if문은 a가 0보다 작은지(음수인지) 확인합니다.

else문 또한 if문이 있어야지만 사용될 수 있고, `if ... else if ... else` 의 순서대로 사용되어 맨 마지막에 위치됩니다. 왜냐하면 else는 위의 if, else if문의 조건이 전부 만족하지 않았을 때 조건 없이 **무조건** 넘어오게 되는 부분이기 때문이죠.

> if, else if, else는 선택사항이고 if와 else 사이에는 else if가 무한개가 올 수 있습니다.
{: .prompt-info }

그리고 if문 안에는 얼마든지 많은 if문이 들어올 수 있습니다. else if를 쓰지 않는다면 다음과 같이도 표현할 수 있죠.

```c
if (a == 0) {
  printf("입력받은 숫자는 0입니다.");
} else {
  if (a < 0) {
    printf("입력받은 숫자는 음수입니다.");
  } else {
    printf("입력받은 숫자는 양수입니다.");
  }
}
```
하지만 이러면 코드가 길어지고 가독성이 떨어지기 때문에 else if라는 구문이 등장하게 되었습니다.

추가로, 중괄호`{}`는 세미콜론`;` 의 역할을 대신하기 때문에, 세미콜론을 적어주지 않아도 됩니다. 또한, 중괄호는 여러 줄의 코드가 포함될 때 적어주는 것이죠.

그래서 맨 위의 if문은 사실 중괄호를 생략할 수 있습니다. 각 if문 안에 한줄씩밖에 없기 때문이죠.

```c
if (a == 0)
  printf("입력받은 숫자는 0입니다.");
else if (a < 0)
  printf("입력받은 숫자는 음수입니다.");
else
  printf("입력받은 숫자는 양수입니다.");
```
혹시라도 `if (a == 0);` 과 같이 세미콜론을 붙이지 않도록 해주세요. 세미콜론은 문장의 끝을 의미하기 때문에, 이렇게 하면 이 if문은 아무런 코드 실행 없이 조건만 확인하고 끝나게 됩니다.

### 조건식

> 관계 연산자

```
A == B   // A와 B가 같은가?
A != B   // A와 B가 다른가?
A > B    // A가 B보다 큰가? (B를 포함X)
A >= B   // A가 B 이상인가? (B를 포함함)
A < B    // A가 B보다 작은가? (B를 포함X)
A <= B   // A가 B 이하인가? (B를 포함함)
```

위는 조건 연산자들입니다. 프로그래밍에서 `=` 는 대입 연산자로 사용되기 때문에, 수학적인 의미로 두 값이 서로 같냐는 것을 계산하고 싶다면 `==` 을 사용하셔야 합니다. 꼭 기억해주세요!

한번 저 계산결과 자체를 출력해보면 알 수 있지만, 조건이 맞을경우 1, 조건이 틀릴경우 0이 나옵니다. 아까 말씀드렸다시피 if문같은 조건문은 0은 거짓, 0이 아닌 모든 숫자는 참이기 때문에 조건이 만족할 때 코드가 실행되는 것이죠.

> 논리 연산자
  
```
!<조건식>             // NOT 연산
<조건식> || <조건식>  // OR 연산
<조건식> && <조건식>  // AND 연산
```


논리 연산자는 조건식 자체에 사용되는 연산자입니다. 조건식 앞에 `!` 를 붙이면 예) `!(a == b)`
조건식의 결과를 반전합니다. 위의 경우 "a와 b가 같지 **않을**경우" 가 됩니다. 이를 NOT 연산이라고 합니다.

조건식 2개 사이에 `||`(역슬래시\ 를 쉬프트누르고) 를 넣으면 예) `a == b || a == 0`
두 조건식 중 하나라도 참일 경우 참을 반환하고, 아니면 거짓을 반환합니다. 위의 경우 "a가 b랑 같거나 **또는** a가 0일 경우" 가 됩니다. 이를 OR 연산이라고 합니다. 

조건식 2개 사이에 `&&` 를 넣으면 예) `1 <= a && a <= 10`
두 조건식이 모두 참이어야 참을 반환하고, 아니면 거짓을 반환합니다. 위의 경우 "a가 1 이상이**면서** 10 이하일 경우" 가 됩니다. 이를 AND 연산이라고 합니다.

> 조건 연산자

삼항 연산자라고도 불리며, `<조건식> ? <코드> : <코드>` 와 같이 사용됩니다. 밑의 예제로 알아봅시다.  

```c
int a;
scanf_s("%d", &a);

// 절댓값
a = a < 0 ? -a : a;

printf("%d", a);
```
위의 코드는 a가 음수일 경우 -를 붙여서 양수로, 양수일 경우 a를 그대로 써서 절댓값을 구해줍니다. 복잡해 보이죠? 실제로도 그렇습니다. 조건 연산자는 `<조건식> ? <참일경우 코드> : <거짓일경우 코드>;` 처럼 쓰입니다. `if ... else` 문을 한줄로 적었다고 생각해도 편하죠. 또한, 삼항 연산자도 2개 이상 중첩될 수도 있지만 이는 가독성이 안좋기 때문에 잘 사용하지 않습니다.

### switch

switch문은 사실 거의 쓰지 않고, 주로 사용되는곳이 한정되어 있기 때문에 이런것이 있다라고만 아시고 if문만 쓰셔도 됩니다. switch문의 구조는 다음과 같은데요

```c
int menu;
scanf_s("%d", &menu);

switch(menu){
  case 1:
    printf("1번 메뉴를 선택했습니다!");
    break;
  case 2:
    printf("2번 메뉴를 선택했습니다!");
    break;
  case 3:
    printf("3번 메뉴를 선택했습니다!");
    break;
  default:
    printf("그런 메뉴 없는데요?");
}
```

`switch(<값>)` 처럼 괄호 안에 값이 들어가고, 밑에 `case <값>:` 이 있고 switch에 넣어준 값이 case 뒤의 값과 같은 경우 해당 구문 안으로 들어가게 됩니다. 그런데 한번 들어가기 시작하면 밑에까지 전부 실행해버리기 때문에 `break문`으로 switch문을 나가주어야 합니다. 이 break문에 대해서는 바로 다음 강의인 "반복문" 에서도 쓰이게 됩니다.

 `default:` 의 경우 else문처럼 case에 해당하는 부분이 없더라도 무조건 들어가집니다. 어짜피 마지막 줄이기 때문에 break를 해줄 필요도 없죠.

## 반복문
***

이 반복문까지의 내용은 매우 중요하기 때문에, 이해가 될 때까지 처음부터 반복해서 읽고 실습해보는 것을 추천드립니다. 왜냐하면 이 이후의 내용을 1도 몰라도 반복문까지만 완벽히 안다면 이론상 모든 프로그램을 제작할 수 있기 때문이죠.

반복문에도 2가지 종류가 있는데, 반복문은 이름 그대로 코드를 반복하기 위해 만들어진 구문입니다. 다음 코드를 보시죠

```c
int a, b;
scanf_s("%d%d", &a, &b);
printf("a + b의 값은 = %d\n", a + b);

scanf_s("%d%d", &a, &b);
printf("a + b의 값은 = %d\n", a + b);

scanf_s("%d%d", &a, &b);
printf("a + b의 값은 = %d\n", a + b);
```
 a와 b를 입력받아서, a + b의 결과를 출력하고 싶은데, 이걸 계속 처리하려면 위와 같이 복사해서 사용했어야 합니다. 하지만 이건 엄청 비효율적이고, 사용자는 이걸 3번만 해보고 싶을수도, 100번도 넘게 사용할 수도 있기 때문에 한계가 있죠.

### while, do ... while

 while문은 주로 "특정 조건이 만족하는 **동안**" 반복하기 위해 사용됩니다. `while (<조건식>) { <실행될 코드> }` 와 같이 사용되고, 바로 위의 코드를 "사용자가 0을 2개 입력할 때까지 계속 실행하게" 변경해 보겠습니다.

```c
int a, b;
scanf_s("%d%d", &a, &b);

while (a != 0 && b != 0) {
  printf("a + b의 값은 = %d\n", a + b);
  scanf_s("%d%d", &a, &b);
}
```
 이제 실행해 보면 `0 0` 을 입력하기 전까지 계속 계산이 되는 것을 볼 수 있습니다. 조건문에 "a가 0이 아니면서 b가 0이 아닐경우" 라고 적어 주었기 때문에, while문은 해당 조건이 **만족하는 동안** 계속 코드를 반복합니다.

 이제 다 좋은데, while문은 조건을 먼저 확인하고 코드를 실행해서 처음에 a와 b에 값이 들어있지 않으면 알수없는 쓰레기값으로 계산이 되어 오류가 나기 때문에, 입력을 미리 받고 출력을 나중에 했습니다. 물론 `int a = -1, b = -1;` 처럼 0이 아닌 값을 미리 넣어줄 수도 있지만, 저는 반복문 안에서 전부 처리되었으면 좋겠습니다. 그럼 어떻게 해야할까요?

```c
int a, b;

do {
  scanf_s("%d%d", &a, &b);
  printf("a + b의 값은 = %d\n", a + b);
} while (a != 0 && b != 0);
```
 do ... while 문은 조건을 확인하기 전에 먼저 실행(do) 하고, 그 후에 조건을 확인합니다. 그래서 일단 한번은 실행하고 조건을 봐줄 수 있다는 장점이 있죠. 만약 눈썰미가 좋으시다면, 위처럼 코드를 바꾼 경우에 처음부터 0 0으로 나가려고 한다면 아까와 다르게 0+0을 출력하고 나가게 된다는 것을 알 수 있습니다. 이는 나중에 `break` 문을 설명드리면서 고쳐보도록 하죠.

### for

 for문은 주로 "특정 횟수만큼" 반복하기 위해 사용됩니다. 그래서 while보다는 for문이 많이 사용되지만, 상호간의 변환이 간단합니다. for문의 구조는 `for (<초기식>; <조건식>; <증감식>) { <실행될 코드> }` 입니다. for문은 **초기식 -> 조건식 -> (조건이 참이면)코드실행 -> 증감식 -> 조건식 -> 코드...** 의 순서대로 반복되고, 초기식/조건식/증감식은 선택사항이어서 비워둘 수 있습니다. 이렇게 이론으로만 들으면 어렵기때문에 실제 코드로 알아봅시다.

```c
int a;
scanf_s("%d", &a);

for (int i = 1; i <= 9; i++) {
  printf("%d * %d = %d\n", a, i, a * i);
}
```
 위의 코드는 입력한 숫자의 구구단을 출력하는 for문입니다. `int i = 1` 이 먼저 실행되어서 i가 1이 되고, 조건을 확인하고, 조건이 참이므로 `a * 1` 을 출력하게 됩니다. 그 후에 i에 1을 더하는 증감식 `i++` 을 만나고, 다시 조건을 확인하고... 그렇게 i가 1부터 9까지 반복되면서 구구단을 출력하는거죠.

 위에서 for문 부분만 아래처럼 while문으로 바꿀수도 있습니다.
```c
int i = 0;
while (i <= 9) {
  printf("%d * %d = %d\n", a, i, a * i);
  i++;
}
```
 이제 for문을 다시 보면 그냥 while문에 변수 선언&초기화와 변수 증가/감소 식 부분이 추가된 것이란 걸 아실 수 있습니다.

 다시 더 간단한 for문 예제를 보여드리면, `"Hello, World"` 를 5번 출력하는 코드는 다음과 같습니다.
```c
for (int i = 0; i < 5; i++)
  printf("Hello, World\n");
```
 i가 0부터 5보다 작을때까지, 즉 0,1,2,3,4 까지 증가하면서 밑의 코드를 호출하고, 그 후에 증감식을 다시 만나면 i가 5가 되어서 조건이 만족하지 않게 되어서 반복문을 빠져나가게 됩니다.

또, 위의 코드를 보면 반복문도 한줄만 있을 경우 중괄호{}를 생락할 수 있다는 걸 아실 수 있습니다.

### break, continue

 break문을 만나면 **현재 진행중인 반복문** 을 빠져나가게 됩니다. while, for, switch에만 사용됩니다.

```c
int a, b;
while (1) {
  scanf_s("%d%d", &a, &b);
  if (a == 0 && b == 0) break;
  printf("a + b의 값은 = %d\n", a + b);
}
```
 위의 코드는 **[무한 반복문]** 이라는 기법인데, 조건에 그냥 1을 넣어 무한대로 반복시키고 if문과 break문을 활용해서 특정 조건에 빠져나가도록 하는 것이죠. 그럼 아까 말씀드렸던 0 0을 입력했을때 0+0이 출력되던 문제도 해결됩니다! 출력을 하기전에 조건으로 확인을 해서 빠져나가기 때문이죠.

 continue문을 만나면 바로 다음 반복으로 건너뜁니다. while문의 경우 밑의 코드들을 넘기고 바로 조건식으로 가고, for문의 경우 증감식으로 갑니다.

```c
for (int i = 1; i <= 10; i++) {
  if (i % 2 == 0) continue;
  printf("%d ", i);
}
```
 위의 코드는 i를 2로 나눈 나머지가 0인 경우, 즉 i가 짝수인 경우에 건너뛰도록 되어서 홀수만 출력되게 됩니다. 조건이 만족하면 바로 i++부분으로 넘어가기 때문이죠.

### 중첩 반복문

 나중에 머리를 싸매게 될 난관이자, 이해하기 난해한 기법입니다. 중첩 반복문이란 말그대로 반복문 안에 반복문을 넣는것을 의미합니다. 그럼 뭐가 달라질까요?

예제 코드:
```c
for (int i = 0; i < 5; i++) {
  for (int j = 0; j < 5; j++) {
    printf("*");
  }
  printf("\n");
}
```
실행 결과:
```
*****
*****
*****
*****
*****
```
 바깥쪽 반복문이 1번 반복할 때, 안쪽 반복문은 처음부터 끝까지, 그러니까 0부터 4까지 총 5번 반복합니다. 그런데 바깥쪽 반복문이 5번 반복하니까 총 반복횟수는 5x5 = 25가 되는것이죠.

 안쪽 j변수 반복문이 5번 반복해서 별을 5개 출력하고 나면, i변수 반복문에서 줄바꿈 문자를 출력해서 위와 같은 별 사각형이 출력되게 됩니다.

 중첩 반복문을 자유롭게 다룰 수 있게 되면 할수있는 것이 더욱 많아지기 때문에, 연습문제를 도전해서 실력을 쌓으면서 익숙해지는 것을 추천드립니다!

## 배열(Array)

배열이란? 단순하게 여러개의 변수를 한꺼번에 선언해주는 기능입니다.

```c
int arr[5];

arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
arr[4] = 50;

printf("%d %d %d %d %d", arr[0], arr[1], arr[2], arr[3], arr[4]);
```
 만약 위의 코드를 배열없이 만드려면 어떻게 했어야할까요? `int a0, a1, a2, a3, a4` 와 같이 일일이 써줘야 했을겁니다. 그리고 배열의 경우 []안의 숫자만 바꿔주면 크기가 바로 바뀌는데 변수로 선언하면 그런것도 불가능하죠.

 배열의 선언 방법은 변수와 완전히 똑같지만, 변수 뒤에 `[<크기>]` 를 적어줌으로써 해당 숫자크기의, 해당 타입의 배열을 만들 수 있습니다. 또, 배열의 원소(값)를 쓰고 싶다면 `<배열이름>[<번호>]` 와 같은 방법으로 쓸 수 있죠. 여기서 중요한 점은, 배열은 1번째가 아니라 0번째부터 시작한다는 점입니다.

 또한, 위의 코드를 반복문을 사용하도록, 그리고 배열의 원소에 입력을 받도록 만들어 더 간단하고 유용하게 만들 수 있습니다.
```c
int arr[5];

for(int i = 0; i < 5; i++)
  scanf_s("%d", &arr[i]);

for(int i = 0; i < 5; i++)
  printf("%d ", arr[i]);
```
 위에서 보시면 아시다시피 배열은 대부분 반복문과 같이 쓰입니다. 0번째부터 원하는 번째까지 간단하게 접근할 수 있기 때문이죠.

 만약 배열을 변수처럼 선언과 동시에 초기화해주고 싶다면(배열도 초기화를 하지 않으면 쓰레기값을 가지고 있습니다) 다음과 같이 해줄 수 있습니다.

```c
int arr1[5] = {1, 2, 3, 4, 5};
int arr2[] = {1, 2, 3, 4, 5};
int arr3[5] = { 0 };
```
 선언을 할때 중괄호{} 와 안에 값을 적어주면, 0번째부터 순서대로 해당 값으로 초기화가 됩니다. 또한, `arr2` 처럼 크기를 적어주지 않으면 뒤에 적어준 값의 개수만큼 초기화가 됩니다.
 그럼 `arr3` 은 어떻게 되는걸까요? 첫번째 원소의 값이 0으로 바뀝니다. 그런데, 이 중괄호로 초기화를 하면 나머지 모든 원소들도 자동으로 기본값인 0으로 초기화가 됩니다. 그래서 arr[3]의 원소들은 `{ 0, 0, 0, 0, 0 }` 이 되는거죠.

 배열을 쓰시면서 주의하실 점은, 배열의 범위를 벗어나는(음수번호 포함)값을 번호(인덱스)로 넘겨주면, 배열의 범위를 벗어났다는 오류가 발생하게 됩니다.

 배열의 내용은 이게 끝입니다. 하지만 배열이 어려워지는 이유는 바로 활용과 다차원 배열에 있죠. 이제 다차원 배열을 선언하는 법을 알아봅시다.

### N차원 배열

 2차원 배열은 우리 주변에서 간단하게 볼 수 있습니다. 표의 형태를 가지고 있기 때문이죠. 변수가 점이면 배열은 선, 2차원 배열은 면, 3차원 배열은 도형... 이런식으로 기하학적으로 표현할 수도 있습니다. 그런데 2차원 배열이란 정확히 무엇일까요?

 2차원 배열을 컴퓨터적으로 살펴보면 **배열의 배열** 이 됩니다. int형 배열이라는 것은 각 원소가 `int형인 변수`라는 뜻이잖아요? 그러면 int형 배열의 배열은 각 원소가 `int형 배열` 인 것입니다.

`int arr[5][10];` <br>
위와 같이 선언하면 **크기가 10인 int형 배열이 5개 있다** 라는 뜻이 됩니다. 왼쪽(앞쪽) 에 있을수록 차원이 높고, 오른쪽(뒤쪽) 에 있을수록 차원이 낮기 때문이죠. 그러면 0번째에 있는 배열의 4번째 원소는 어떻게 접근할까요?

`arr[0][4]` 와 같이, 접근할 때에도 대괄호를 2개 써서 접근합니다. 사용법이 잘 이해가 되시나요? 그렇다면 3차원, 4차원 배열도

`int arr[2][5][10][10];` <br>
이런식으로 얼마든지 늘릴 수 있게 됩니다. 하지만 4차원 이상은 코드를 이해하기 버거워지기 때문에 대부분 2차원까지만, 가끔 3차원을 씁니다. 그런데 2차원 배열을 쓰면 메모리 상에서 어떻게 되어있을까요?

{% raw %}
```c
int arr_d2[2][3] = {{1, 2, 3}, {4, 5, 6}}; // {1, 2, 3, 4, 5, 6} 도 됩니다
int arr_d1[6] = {1, 2, 3, 4, 5, 6};
```
{% endraw %}

 1차원이나 2차원이나 메모리 상에서는 숫자가 순서대로 들어가 있습니다. 그래서 사실 1차원을 쓰냐 2차원을 쓰냐의 차이는 배열의 원소에 접근할 때 쓰이는 번호(인덱스)가 1개냐 2개냐의 차이이죠.

마지막으로 3차원 배열의 반복문 접근예제만 보여드리겠습니다.

```c
int arr[3][2][5], cnt = 0;

for(int i = 0; i < 3; i++){
  for(int j = 0; j < 2; j++){
    for(int k = 0; k < 5; k++){
      arr[i][j][k] = ++cnt;
    }
  }
}

for(int i = 0; i < 3; i++){
  for(int j = 0; j < 2; j++){
    for(int k = 0; k < 5; k++){
      printf("%d ", arr[i][j][k]);
    }
    printf("\n");
  }
  printf("\n");
}
```

## 함수
***

함수는 수학에서도 있는 개념이며, 주로 f(x)으로 표현되죠. f(x)가 무슨 뜻인가요? 값 하나를 넘겨주었을때 안에서 모종의 계산을 취한 후 결과를 만들어주는 것이죠. 더하기 빼기같은 사칙연산도 함수라고 할 수 있습니다! 값 2개를 넘겨주면 안에서 두 값을 더하고 결과를 주기 때문이죠.

그러면 프로그래밍에서의 함수는 어떨까요? 완전 똑같습니다. 원하는 값들을 변수로 입력받고, 안에서 코드를 실행한 후, 원하는 자료형을 반환하죠. 함수의 정의부터 살펴보도록 합시다.

`<반환 자료형> <함수 이름>(<매개변수 목록>){ <실행될 코드들> }`

와 같이 생겼습니다. 함수를 사용하는 것을 **함수를 호출한다** 라고 하고, 함수에 넘겨주는 값들은 **매개변수** 라고 부릅니다. 예제코드를 보고 더 자세히 알아보도록 하죠!

```c
// start부터 end의 합을 구해서 반환(return)하는 함수
int GetSum(int start, int end){
  int sum = 0;
  for (int i = start; i <= end; i++)
    sum += i;
  return sum;
}

int main() {
  int result = GetSum(1, 10);
  printf("1부터 10까지의 합: %d", result); // result에 안넣고 바로 GetSum(1, 10)을 넣어도 됩니다.

  return 0;
}
```
 `GetSum()`을 보시면 int형 값 2개를 매개변수로 받는데, 각각의 변수 이름이 `start` 와 `end` 이고, 함수의 자료형은 int인 GetSum 이라는 함수를 만들었다고 할 수 있습니다. 안쪽에서는 start부터 end까지의 합계를 구해서, **return** 이라는 구문으로 계산된 값을 반환합니다.

 여기서 **return** 이란, 처음에 말씀드린 계산한 결과를 호출한 곳으로 돌려주는 역할을 합니다. `int result = GetSum(1, 10);` 이라고 하면, 여기서 GetSum에 1과 10을 넣어서 호출했고, 그 계산된 결과가 이곳으로 돌아오는(return, 반환되다)거죠. 이쯤에서 함수의 자료형이 무슨 역할을 하는지 설명해드리면, 반환되는 값의 타입을 의미합니다. 만약 `return 5.5;` 를 해주었는데, 그 함수의 자료형이 int 타입이라면 5.5가아니라 **5**가 반환됩니다.

그리고 함수는 return을 만나면 즉시 종료하게 됩니다.
```c
int GiveSomething(){
  printf("5를 드릴게요!");
  return 5;
  printf("10은 안되나요?");
  return 10;
}
```
위의 함수는 5를 반환하고 밑의 모든 코드를 실행하지 않습니다.

 그런데 GetSum()의 코드를 보시면서 느끼신 점이 있지 않나요? 네, 지금까지 계속 적어주던 `int main(){ }` 도 사실은 함수입니다. 왜 굳이 main이라는 이름이냐면, 프로그램을 실행하면 컴퓨터가 정확히 main이라는 이름의 함수를 실행시키면서 프로그램이 실행됩니다. 그러면 `return 0` 의 반환값인 0은 어디로 가는걸까요? 이는 운영체제로 넘어가게 되는데, 사실 뭘주던 상관은 없습니다. 하지만 관례적으로, 그리고 예외를 방지하기 위해 적어주는 것이죠.

### void 타입

 함수에는 void라는 타입이 존재합니다. 이는 반환값(return값)이 존재하지 않는다는 뜻이고, return을 함수 종료 용도로 사용할 수는 있지만 뒤에 무언가 값을 적어줄 수는 없습니다. 주로, 내부에서 출력하는 등 값을 전달할 필요가 없는 경우에 사용됩니다.

```c
void print(char ch){
  if (ch == '\n') return;
  printf("%c", ch);
}
```

### 변수의 범위

 변수에는 범위가 존재합니다. 엄청 간단하게 알려드리면, 중괄호에 따라 범위가 나뉘는데 예를들어 중괄호 안에서 선언한 변수는 그 중괄호가 끝나면 사라집니다.

```c
int main() {
  int a = 5;
  
  if (a == 5) {
    printf("밖에서 안쪽은 되네요: %d\n", a);
    int b = 3;
  }
  printf("b라는 변수가 어디있죠? %d\n", b);   // 오류가 뜹니다
}
```
 그래서 위의 코드는 b라는 변수를 찾지 못해 오류가 발생합니다. 또, 이런 코드를 헷갈리지 말으셔야합니다.
```c
int Add(int x, int y) {
  x += 10;
  y -= 5;
  return x + y;
}

int main(){
  int x = 2, y = 5;
  
  int result = Add(x, y);
  printf("%d + %d = %d", x, y, result);
}
```
`Add(int x, int y)` 와 main함수 안에있는 `int x, y`는 이름만 같고 서로 다른 변수입니다. 중괄호의 범위가 다르기 때문이죠. (매개변수라도 해당 함수 안에있는겁니다)

### 지역변수, 전역변수

 그렇게 중괄호 안에서 선언된 변수를 지역변수라고 하고, 아무 중괄호 안에도 들어있지 않은 변수를 전역변수라고 합니다. 지역변수는 스택(Stack)이라는 메모리에 상주하고, 전역변수는 힙(Heap)이라는 메모리에 상주합니다. 힙의 메모리 공간이 더 넉넉합니다. 전역변수의 경우 어디에서든지(어느 함수에서든지) 사용될 수 있습니다. 하지만 **실제 프로그램 개발에선 거의 절대 사용하지 않습니다**. 전역 변수와 겹치는 이름을 지으면 안되는 등의 문제가 생기거든요!

```c
int cnt;   // 전역변수는 자동으로 초기화됩니다

void Counter() {
  cnt++;
}

int main() {
  Counter();
  Counter();
  Counter();
  printf("%d", cnt);   // 3 출력
  return 0;
}
```

### 정적변수

 만약 전역변수를 쓰기는 싫은데, 다음에 함수를 호출할 때에도 값을 기억하고 싶다면 정적 변수를 쓰는것도 방법 중에 하나입니다. 정적 변수는 해당 변수를 스택(Stack)이 아닌 힙(Heap)메모리에 상주하도록 변경합니다.

 변수를 선언할 때 자료형에 static을 붙여주면 되고, 앞에하나 뒤에하나 상관없습니다.

```c
void Counter() {
  static int cnt; // int static cnt; 도 됩니다
  cnt++;
  printf("%d ", cnt); 
}

int main() {
  Counter();
  Counter();
  Counter();
  return 0;
}
```

### 함수 원형(함수 시그니처)

 C언어는 절차지향 언어입니다. 이건 프로그램을 실행할 때 위에서부터 차례대로 읽는다는 뜻이죠. 갑자기 이걸 왜 설명해주냐면, 함수를 호출할 때 그 함수의 정의가 함수를 호출하려는 것 보다 밑에있다면, 함수를 찾지 못해서 오류가 나게 됩니다. 정확히는, 함수의 매개변수에 잘못된 타입을 주는 등의 실수를 해도, 컴파일러가 오류를 찾아주지 못하고 오류가 나게 됩니다. 그런데 만약 함수를 밑에다 구현하고싶다면 어떻게 해야할까요?

```c
int Add(int a, int b);

int main() {
  int sum = Add(10, 15);

  return 0;
}

int Add(int a, int b) {
  return a + b;
}
```
 바로 위처럼 함수의 원형, 즉 함수의 정의만을 위에 적어주면 아무런 문제없이 해당 함수를 읽어올 수 있게 됩니다. 대부분의 C프로그래머는 이렇게 위에 함수의 원형을 정의해두고 밑에 함수를 작성한다고 합니다!

## 포인터(Pointer)
***

강의 거의 처음에 변수에 대해서 설명을 할 때, 변수를 선언하면 메모리(RAM) 에서 비어있는 공간을 찾아서 변수의 자료형의 크기만큼 확보해 준다고 했었습니다. 그리고 변수에게는 그 메모리(RAM)의 주소를 가리키게 했는데요, 포인터는 바로 이 주소를 저장하고 다루는 변수입니다.

```c
int a = 5;
int *p;
p = &a;

*p = 0;
printf("%d", a);
```
 위의 예제를 적고 실행해 보면,  a의 값이 0으로 바뀌었다는 것을 알 수 있습니다. scanf_s()에 대해 설명할 때 &는 변수의 주소를 계산한다고 한 게 기억나시나요? 위의 코드는 int 포인터형 변수 p를 선언하고, 거기에 a의 주소를 넣은 다음에 p가 가리키고 있는 주소의 값을 0으로 바꿔준 것입니다. p에는 a의 주소가 들어가있었으니, a가 가리키고 있던 값이 바뀌게 되는 것이죠. 대충 포인터가 무얼 하는지 감이 오셨다면, 더 제대로 알아봅시다!

`<자료형> *<변수명>`
 포인터는 위와 같이 변수를 선언할 때, 변수의 이름 앞에 \*을 붙여서 해당 자료형의 포인터 변수를 선언합니다. 그러면 이제 이 변수는 주소값을 담을 수 있는 변수가 되는거죠!

> 주소값은 실제로 숫자의 형태로 지정되어 있습니다. `0x00000012` 같은식으로 말이죠. 32비트 컴퓨터의 경우 16진수 8자리로 표현이 가능하고(각 자리가 2^4 이기 때문에 2^4^8 = 2^32) 64비트는 16진수 16자리로 표현이 가능합니다.
{: .prompt-info }

 그럼 위 코드의 3번째 줄 까지는 이해가 되셨을 겁니다(아마도요). 그럼 그 밑의 `*p = 0;`은 무엇일까요? 포인터 변수를 **사용**할 때, 앞에 \*를 붙여주면 해당 포인터 변수가 **가리키는 주소의 값**을 의미합니다. 만약에 저 코드에서 \*가 없었다면 p가 가리키는 주소를 0으로 바꾸라는 의미였겠죠. 그렇기 때문에 a의 주소의 값이 바뀌어서 0이 출력된 거에요!

 마지막으로, 포인터에 타입이 존재하는 이유는 타입마다 가지고 있는 데이터의 크기가 다르기 때문입니다. `int *` 형의 경우, int가 4바이트기 때문에 가리키고 있는 주소부터 4바이트만큼의 값을 자동으로 읽어오고, `char *` 형의 경우 1바이트만 읽어오는 식으로 작동합니다.

### 배열과 포인터

 포인터는 주소를 다루는 자료형이라고 했었습니다. 그런데 배열도 포인터라는 점 알고계셨나요? 서로다른 변수를 5개 선언하는것과 크기 5의 배열을 선언하는것은, 번호로 접근한다는 차이 외에도 큰 특징이 하나 있습니다.

`int s1, s2, s3, s4, s5;`
위처럼 변수를 5번 선언하면 메모리(RAM)에서 서로 다른곳에 4바이트씩 할당이 됩니다.

`int s[5];`
하지만 위처럼 배열로 선언하면 int형 변수 5개만큼의 공간인 20바이트를 한꺼번에 할당합니다. 그러면 엄청 큰 장점이 생기는데, 배열의 원소들의 주소가 전부 일정한 간격으로 뛰어져 있어서 1번째 원소의 주소만 알면 그 주소부터 4바이트(1칸)을 건너뛰면 2번째 원소, 16바이트(4칸)을 건너뛰면 5번째 원소가 나오게 되겠죠? 그래서 배열을 선언하면 첫번째 원소의 주소가 배열의 이름에 저장됩니다.

```c
// 주소는 0x00, 0x04, 0x08... 과 같은식으로 일정한 간격이 됩니다
int s[5] = {10, 20, 30, 40, 50};

printf("%d %d", *s, *(s+4)); // 10, 50 출력
```
 첫번째는 변수를 쓸때 \*를 붙여서 포인터인 s가 가진 주소의 값을 출력해서 10이 나오고, 두번째는 첫번째 주소부터 4칸 뒤의 주소의 값을 출력해서 50가 나오게 됩니다.
 일단 괄호를 사용한 이유는, \* 연산자의 우선순위가 +보다 높아서(거의 가장높습니다) 그냥 `*s + 4`라고 쓰면 `10 + 4` 가 되어서 14가 나오게 됩니다.

 다음으로, `s + 4`를 하면 4바이트만큼 건너뛰는 게 아닌가? 라고 생각하실 수 있는데, 포인터 자료형에 +를 사용하면 다르게 계산되어서 해당 포인터의 크기만큼 건너뛴 게 됩니다. `int*`의 경우 int가 4바이트기 때문에 `s + 1`을 하면 4바이트를 건너뛰어서 20이 나오는 식이죠.

 그런데 배열을 다룰때 맨날 이렇게 쓰면 귀찮고 힘들기때문에 위를 간편하게 만들어서 다음과 같은 식이 나오게 되었습니다.
`s[0]` `s[1]`     // `*(s + 0)`, `*(s + 1)` 과 같습니다
그리고 이게 바로 배열이 0부터 시작하는 이유이기도 하죠!

### 함수와 포인터

포인터를 배우실때 이해가 되셨든, 안되셨든 "대체 이게 왜필요한거지?" 라는 생각이 들으실 수 있습니다. 포인터는 바로 함수에서 진가를 발휘하는데요.

```c
void Swap(int a, int b) {
  int tmp = a;
  a = b;
  b = tmp;
// 그냥 a = b; b = a; 하시면 a = b 하는순간 a에있던 값이 사라지고 b값이랑 똑같아지기 때문에 위와 같이 임시변수에 원본값을 저장해서 바꿔줍니다.
}

int main(){
  int x = 5, y = 3;
  
  Swap(x, y);
  printf("%d %d", x, y);

  return 0;
}
```
 두 변수의 값을 바꾸는 Swap(int, int) 함수를 만들었습니다. 출력 결과는 어떻게될까요? `5 3`이 나옵니다. 왜냐면 Swap에 x와 y를 넣어준다 하더라도 이건 **x와 y가 가지고 있는 값**을 사용하는것이기 때문에, x와 y의 값 자체는 바뀌지 않습니다. 정확히는, `Swap(x, y)` 와 같이 사용하면 x값이 복사되어서 a에 들어가고, y값이 복사되어서 b에 들어갑니다. 이를 **값에 의한 호출(Call by Value)** 라고 합니다.

그래서 만약 넘겨준 x, y값 자체가 바뀌는 함수를 만들고 싶다면 다음과 같이 포인터를 사용해야합니다.
```c
void Swap(int* a, int* b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

int main(){
  int x = 5, y = 3;
  
  Swap(&x, &y);
  printf("%d %d", x, y);

  return 0;
}
```
이렇게 원본값을 참조해서 사용하는것을 **참조에 의한 호출(Call by Reference)**라고 합니다.
이제 scanf_s() 를 호출할 때 왜 변수에 &를 붙여주는지도 이해가 되시나요? 또, 위에서 배열은 포인터라고 설명드렸다시피 포인터를 사용하면 배열을 입력받을수도 있습니다!

### 상수 변수, 상수 포인터

 상수변수는 말그대로 값을 못바꾸는 변수입니다. static과 마찬가지로 자료형에 const를 앞이나 뒤에 붙여주면 됩니다. 평소라면 진짜 쓸모없지만 함수에서는 혹시나 값을 실수로 바꾸고 싶지 않은 경우에, 주로 포인터와 같이 사용됩니다.

`const int PI = 3.141592`

const(상수) 변수는 선언 후에 값을 바꾸지 못하기 때문에, 무조건 선언과 동시에 초기화해주어야 합니다.

 상수 포인터의 경우, **포인터가 가리키고 있는 주소안의 값** 을 바꾸지 못한다는 기능을 가지고 있습니다.

```c
int main() {
  int a = 0;
  const int* p = &a; // int const* p = &a 도 가능합니다

  *p = 5; // 에러

  return 0;
}
```
 그래서 p가 가리킬 주소를 변경할 수는 있지만,  가리키고 있는 주소의 값을 바꾸지는 못합니다. 그런데 상수 포인터에서 만약 \*보다 뒤에 const를 붙이면, 이는 다른 의미가 되는데요

```c
int main() {
  int a = 0, b = 5;
  int* const p = &a;
  *p = 5;
  p = &b; // 에러

  return 0;
}
```
 이는 **가리키고 있는 주소**를 바꾸지 못한다는 뜻입니다. 그래서 가리키고 있는 주소의 값을 바꿀수는 있지만, 다른 대상을 가리키게는 못하죠.

`const int* const a;`

 두개는 혼용해서 쓸 수 있으며, 이런게 있다는 것만 알아두고 혹시 나중에 필요해지면 적재적소에 써먹도록 합시다. 몰라도 프로그래밍에는 지장이 없지만, 실수로 값을 바꾸는 행위 등을 막기 위해 주로 사용됩니다.

밑의 2가지 개념들은 매우 어려울 수 있어서 부록으로 분리했으니, 참고만 하시길 바랍니다.

### 부록: 재귀 함수

 재귀recursive 함수란, 함수 내부에서 자기 자신을 호출하는 것을 의미합니다. 어떻게 보면 무한 반복문이라고도 볼 수 있죠. 예를들어 N! (팩토리얼, 5! == 5\*4\*3\*2\*1) 은 재귀함수로 다음과 같이 나타낼 수 있습니다.

```c
int fact(int n) {
  if (n == 1) return 1;
  return n * fact(n - 1);
}

int main() {
  printf("%d", fact(5));   // 120
}
```
 처음에 n에 5가 들어갔고, n은 1이 아니니까 `5 * fact(4)` 가 return됩니다. 그런데 return하기전에 함수를 먼저 실행해서 fact(4)가 호출되면 이 함수는 `4 * fact(3)` 을 반환합니다. 그 다음은 `3 * fact(2)`, `2 * fact(1)`... fact(1)은 1을 반환하고 더이상 fact()를 호출하지 않아서 이제 거꾸로 빠져나옵니다. 그러면 `2 * fact(1)`에서 fact(1)의 반환값이 1이었으니 `2 * 1` 이 되고, 이게 반환되어서 `3 * fact(2)` 에서 fact(2)의 반환값이 `2 * 1` 이었으니 `3 * 2 * 1`이 되고, 그다음은 `4 * 3 * 2 * 1`, 그다음은 `5 * 4 * 3 * 2 * 1` 이 되면 마지막으로 main함수에 `5 * 4 * 3 * 2 * 1` 의 값인 **120** 을 전달하고 끝이 납니다.

 이것이 재귀 함수의 원리이며, 지금 이해하시기에는 많이 힘들 수 있으니 이런 기법이 있다는 것 정도로만 알아두시면 좋습니다.

### 부록: 함수 포인터

 함수에도 포인터가 있습니다. 어? 그러면 함수 코드가 메모리(RAM)에 있어야 하지 않나요? 네. 함수뿐만 아니라 코드 전체가 메모리에 존재합니다. 그럼 함수 포인터는 무슨 기능을 하냐면, 매개변수와 반환타입이 같은 함수라면 아무거나 넣어줄 수가 있습니다. 바로 예제부터 보여드리도록 하죠

```c
int add(int a, int b) {
  return a + b;
}
int sub(int a, int b) {
  return a - b;
}
int mul(int a, int b) {
  return a * b;
}
int div(int a, int b) {
  return a / b;
}

int main() {
  int (*op)(int, int);
  
  op = add;
  printf("%d\n", op(10, 5));
  op = sub;
  printf("%d\n", op(10, 5));
  op = mul;
  printf("%d\n", op(10, 5));
  op = div;
  printf("%d\n", op(10, 5));
}
```
함수 포인터는 다음과 같이 정의합니다.

`<반환 타입> (*<포인터 이름>)(<매개변수들>);`

 그러면 해당 함수 포인터와 똑같은 구조인 함수를 아무거나 넣어줄 수 있는데, 그래서 만들어진 게 위와 같은 코드입니다. int형을 반환하고 int타입 매개변수를 2개 받는 사칙연산 연산자들을 만들어서, 함수 포인터가 가리키게 만들어서 호출하는 것이죠. 이 함수 포인터는 이후 객체지향에서 대리자(delegate)라고도 불리는 문법으로 발전하게 되는데, 엄청난 활용도를 가진 기능입니다.

 일단 이쯤되서 프로그래밍은 공부하는것이 아니라면 혼자 개발할 일이 별로 없다는 점을 인지하셔야 합니다. 그래서 이 함수 포인터를 어떻게 써먹냐면, 예를들어 값을 순서대로 정렬하는 sort()라는 함수를 만들었다고 합시다. 정렬을 해주는 알고리즘은 여러가지가 있는데, 그중 가장 간단한 버블정렬을 사용하였습니다.

 버블 정렬이란, `5 2 4 3 1` 과 같은 값이 배열에 들어있고 오름차순으로 정렬하려한다면, 이 배열을 반복문으로 순서대로 보면서 자기가 가진 숫자와 자기 다음숫자끼리 비교해서 만약 뒤의 숫자가 더 작다면 서로 위치를 교환해하는 것입니다.

 한번 반복하게 되면 5가 제일 크기때문에 5 뒤에있는 숫자와 계속 자리를 바꿔주어서 5가 자신의 자리로 가게 되겠죠.
`2 4 3 1 5`

 그런데 맨 오른쪽에있던 1이 맨 왼쪽까지 오려면 최소한 4번(길이-1)만큼 반복해줘야 하기 때문에 위의 작업을 **길이-1**만큼 반복해주는게 버블 정렬입니다.

```c
#include <stdio.h>

void sort(int* arr, int size, int (*op)(int, int)) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - 1; j++) {
            if (op(arr[j], arr[j + 1])) {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}

int bigger(int a, int b) {
    return a > b;
}

int lesser(int a, int b) {
    return a < b;
}

int main() {
    
    int arr[10] = { 10, 5, 2, 4, 7, 8, 1, 3, 9, 6 };

    for (int i = 0; i < 10; i++)
        printf("%d ", arr[i]);
    printf("\n");

    sort(arr, 10, bigger);

    for (int i = 0; i < 10; i++)
        printf("%d ", arr[i]); // 내림차순 정렬
    printf("\n");

    sort(arr, 10, lesser);

    for (int i = 0; i < 10; i++)
        printf("%d ", arr[i]); // 오름차순 정렬
    printf("\n");

}
```
 만약 이 코드가 이해가 되셨다면, 함수 포인터가 엄청난 녀석이란걸 아실겁니다. `sort()`는 배열과 배열의 길이, 그리고 함수 포인터를 매개변수로 받는데 이 함수 포인터는 정렬 내부에서 대소비교를 할 때 쓰이게 됩니다. 그래서 현재 숫자보다 뒤의 숫자가 더 작을때 참(True)를 반환하는 lesser, 그 반대인 bigger를 만들어서 넘겨주면 넘겨준 함수에 따라 정렬순서가 바뀌게 됩니다.

 이 코드가 너무 어려우시면 나중에 실력이 쌓인 다음에 보시는 걸 추천합니다. 참고로, 이거 쓸줄 몰라도 프로그래밍 하는데 지장이 아예 없습니다!

## 문자열string
***

 문자열이란, 간단하게 문자의 나열이라는 뜻입니다. char 타입은 문자 하나를 저장하는 자료형인데, 만약 `"Hello, World"` 와 같은 문자열을 저장하려면 어떻게 해야할까요? 정답은 [배열을 사용한다] 입니다. `char str[50] = "Hello, World";` 처럼 할 수 있죠.

 또, 다시 알려드리자면 C언어에서 작은따옴표(' ')는 문자를 의미하고, 큰따옴표(" ")는 문자열을 의미합니다.

### 아스키 코드

 우리가 char형에 문자를 저장할 때, 실제로 문자가 저장되는 것이 아니라, 해당 문자의 **아스키코드**에 해당하는 값이 저장됩니다. 이 아스키코드는 문자를 표현하기 위한 규약이라고 볼 수 있는데, 예를들어 'A' 의 아스키 코드는 65고, 'a' 의 아스키 코드는 97입니다. 이런식으로 문자마다 대응되는 숫자가 존재하고, 문자를 저장할 때는 해당 숫자로 저장이 되고 문자를 출력할 때는 그 숫자에 해당하는 문자가 출력되죠. 참고로 문자로 '0' 은 0이 아니라 48입니다. 아스키 코드를 외울 필요는 전혀 없으며, 아스키 코드로 저장된다는 점만 알아두시면 됩니다.

### 널null 문자

`"ABC"` 라는 문자열이 있는데, 이 문자열의 길이는 어떻게 알 수 있을까요? 3글자니까 3개가 아니냐고요? 맞는데, 프로그램이 배열의 길이를 알아낼 수 있는 방법은 없죠(방법이 하나 있기는 한데, 언제나 사용가능하진 않습니다). 그래서 C언어에서는 마지막 문자 뒤에 아스키 코드로 0에 해당하는 `'\0'` 이라는, NULL이라고 불리는 문자를 추가하는 방법을 생각해 냈습니다. 길이를 알고 싶다면, 문자열의 0번째부터 계속 반복을 하다가 만약 문자열의 i번째가 `'\0'` 이라면 그때 i의 값이 해당하는 문자열의 길이인 것이죠.

```c
char str[] = "ABC"; // 문자열을 넣어줄 때는 배열의 크기를 적지 않아도 되는데, 이 경우 넣어준 문자열의 길이만큼 자동으로 설정됩니다.
int i;

for(i = 0; str[i] != NULL; i++) // != '\0', != 0, 또는 왼쪽처럼 NULL이라고 적어도 됩니다. NULL은 기호상수중 하나며, 숫자 0과 똑같습니다.
  printf("%c", str[i]);

printf("\n문자열의 길이: %d", i);
```
 위 코드처럼 "ABC" 자체를 넣어주면, 큰따옴표는 끝에 NULL문자를 자동으로 삽입해주기 때문에 str배열은
`char str[4] = {'A', 'B', 'C', '\0'};` 을 해준 것과 똑같이 되는 것이죠. 만약 "ABC" 를 넣어주지 않고 하나씩 일일이 `{'A', 'B', 'C'}` 을 넣어줬다면 뒤에 NULL문자가 삽입되지 않는다는 점을 주의해주세요. 또, 문자열 배열에는 NULL문자가 들어갈 공간이 있어야합니다.
 위처럼 문자열의 길이를 알아내야 할 경우는 매우 많기 때문에, 문자열의 길이를 반환하는  `strlen()`이라는 함수가 존재하는데, 나중에 알려드리겠습니다.

### 문자열 입력받기

문자열을 입력받을 때는 "%s" 를 사용하면 됩니다. 복잡한 것은 없으니 바로 보여드리겠습니다.

```c
char str[50]; // 몇글자까지 들어올 지 모르기 때문에 50이라고 적어줬습니다. 그럼 NULL문자가 들어갈 공간을 제외한 49글자까지 받을 수 있는거죠. 공간이 남아도거나 부족할 수 있다는 비효율적인 문제는 나중에 "동적 메모리" 에서 배우게 됩니다.
scanf_s("%s", str, 50);

printf("%s", str);
```
 scanf\_s()를 처음 설명드릴때, 문자를 입력받을 때는 몇글자까지 받을 수 있는지를 뒤에 적어준다고 했었습니다. 이는 그냥 선언해준 배열의 크기로 정해주면 됩니다. 또, %s로 입력받을때는 **&**를 사용하지 않는다는 것을 알 수 있는데, 이는 배열과 포인터에서 설명드렸다시피 배열의 이름은 포인터이기 때문에, 이미 주소를 담고 있기 때문입니다. 또, %s가 문자열을 입력받기 때문에 입력받은 문자열을 배열의 시작 위치부터 자동으로 넣어주기도 합니다.
 위에 코드는 문자열을 입력받고, 문자열을 출력하는 간단한 프로그램인데, 실행하고 `Hello, World` 같은식으로 입력하면 `Hello,` 만 나오는 것을 볼 수 있습니다. 왜냐면 scanf\_s는  **탭키`'\t'`, 공백`' '`, 줄바꿈`'\n'` 문자에서 입력을 멈춰버리기 때문인데요. 그래서 만약 띄어쓰기가 포함된 문장을 입력받고 싶다면 `gets_s()` 를 사용해야합니다.

```c
#include <stdio.h>
#include <string.h>

int main() {
  char str[50];
  gets_s(str, 50);

  printf("%s", str);
}
```
 gets\_s()도 마찬가지로 \_s가 붙었기도 하고, 문자와 관련되어있기 때문에 몇글자까지 받는지 적어줍니다. 사용법은 저게 끝! 그리고 gets\_s() 는 <string.h> 라는 라이브러리 안에 들어있습니다. <string.h> 에는 문자열을 편하게 다루게 도와주는 내장함수들이 있습니다. 종류가 다양하고 문자열을 다룰 때만 사용되기 때문에 아래의 링크를 참고해주세요!

https://modoocode.com/77
왼쪽 카테고리에서 C -> C Reference -> string.h 아래있는 함수들을 참고하시면 됩니다.

## 구조체struct
***

구조체란, 나만의 자료형을 만드는 것입니다. 배열처럼 값 여러개를 기억하게 할 수도 있는데, 구조체는 서로 다른 타입 또한 포함할 수 있습니다. 만약 지금까지 배운대로 학교에서 학생들의 정보를 저장하게 한다고 해봅시다. 만약 학생이 30명정도 된다면 다음과 같이 적어줘야 했을겁니다.

```c
int student_number[30], age[30];
char name[30][10];
```
 쓰는데는 지장이 없지만, 자료들이 서로 분리되어 있어서 접근성과 가독성이 떨어지게 됩니다. 하지만 만약 구조체를 쓰면 어떻게될까요?

```c
struct student {
  int student_number, age;
  char name[10];
};

int main() {
  struct student stu_list[30];

  // ...이하생략
}
```
 이렇게 간단하게 표현될 수 있습니다! 그럼 이제 구조체 변수를 사용하는 방법을 자세히 알아보도록 할까요?

```c
struct point {
  int x, y;
};

int main() {
  struct point p1, p2;
  struct point p3 = {2, 3};
  p1.x = 5;
  p1.y = -10;

  scanf_s("%d %d", &p2.x, &p2.y);
  
  printf("p1: %d, %d\n", p1.x, p1.y);
  printf("p2: %d, %d\n", p2.x, p2.y);
  printf("p3: %d, %d\n", p3.x, p3.y);
}
```
 위에서 볼 수 있듯이 point 구조체 안에 `int x, y;` 로 int타입의 변수 2개를 선언해 주었는데, 이를 멤버 변수, 필드 변수라고도 부릅니다. 그럼 이제 point 구조체는 x, y를 멤버(필드) 로 가지는 새로운 자료형이 되는것이죠.
 구조체 변수를 선언할 때는 `struct`까지 포함하여 타입(자료형) 이름이기 때문에, `struct point <변수명>` 처럼 선언해주었습니다. 또, 구조체 변수를 사용할 때 `<구조체변수>.<구조체필드>` 와 같이 사용해 주는데, 접근 방식만 다를뿐 변수를 사용한다는 점은 똑같습니다. 또, **p3**의 경우 배열과 같이 `{2, 3}` 처럼 선언과 동시에 초기화해줄 수 있습니다. 이 경우는 구조체에서 선언한 변수의 순서대로 값이 자동으로 들어가게 되죠.

 구조체는 보기에는 어려워 보이지만, 단순히 새로운 자료형을 선언해 주는 것이라고 볼 수 있습니다! 언어가 제공하는 int, float과 같은 기본 자료형들을 **원초(primitive) 자료형**이라고 하는데, 한 가지 종류의 값만 가지고 있는 이 원초 자료형들을 여러개 묶어서 새 자료형을 만드는 것이 구조체입니다.

### typedef

typedef란, 어떤 자료형을 부르는 이름을 추가해주는 키워드입니다.

```c
typedef int number;

int main() {
  number a, b; // int a, b; 와 동일합니다
}
```
 위처럼 그냥 int를 number로도 부를 수 있게 해주는 것이죠. 그래서 평소엔 이게 엄청 쓸데없는데, 구조체를 사용할 때는 typedef를 써서 더 이름을 부르기 편하게 만들 수 있습니다.

```c
struct point {
  int x, y, z;
};

typedef struct point point;

int main() {
  point v;
  v.x = 5;
  v.y = 10;
  v.z = -5;
}
```
`struct point` 타입을 `point` 로 **typedef** 를 해주면, 앞으로 구조체 변수를 선언할 때마다 앞에 struct를 붙여줄 필요가 없겠죠? 그런데 이것을 더 쉽게 해줄 수 있는 방법이 있습니다.
```c
// typedef struct point로 해도 됩니다.
typedef struct {
  int x, y, z;
} point;

int main() {
  point v;
  v.x = 5;
  v.y = 10;
  v.z = -5;
}
```
 바로 구조체의 선언과 동시에 해당 구조체를 typedef 해주는 것인데요, 자료형의 선언과 동시에 point라는 이름으로 불리도록 해주는 것입니다. 대부분의 경우 구조체를 선언할 때 이와 같이 해주는데, C++로 넘어와서는 기본적으로 구조체 변수에 `struct` 를 붙이지 않아도 되도록 바뀌기도 하고, C언어로 개발을 하실 일은 별로 없으실테니 이런게 있다는 것만 알아두시면 되겠습니다!

### 함수에 구조체 쓰기

 위에서 설명드렸다시피 구조체는 나만의 자료형을 새로 만드는 것과 똑같기 때문에, 그냥 자료형처럼 사용하면 되지만 헷갈리실 수 있으니 예시를 보여드릴게요!

```c
struct point {
  int x, y;
} ;

struct point subtract(struct point a, struct point b) {
  struct point result;
  result.x = a.x - b.x;
  result.y = a.y - b.y;
  return result;
}

int main() {
  struct point p1, p2;
  scanf_s("%d%d", &p1.x, &p1.y);
  scanf_s("%d%d", &p2.x, &p2.y);

  struct point result = subtract(p1, p2);
  printf("뺄셈 결과: (%d, %d)", result.x, result.y);

  return 0;
}
```
물론 위의 코드는 가독성이 꽤 떨어져서 typedef를 사용하여 다음과 같이 줄일 수 있습니다.
```c
typedef struct {
  int x, y;
} point;

point subtract(point a, point b) {
  point result;
  result.x = a.x - b.x;
  result.y = a.y - b.y;
  return result;
}

int main() {
  point p1, p2;
  scanf_s("%d%d", &p1.x, &p1.y);
  scanf_s("%d%d", &p2.x, &p2.y);

  point result = subtract(p1, p2);
  printf("뺄셈 결과: (%d, %d)", result.x, result.y);

  return 0;
}
```
### 구조체 포인터

구조체 포인터는 구조체 타입의 포인터입니다. 일반 변수와 별다를 것이 없지만, 한가지 새로운 연산자가 등장하게 되는데요, 위의 `struct point` 로 예를 들어보면,

```c
struct point val;
struct point *p = val;

*p.x = 5;   // 오류 발생
p->y = 10; // 자기멋대로 바뀜 
```

선언은 아시는대로 변수 앞에 \*를 붙이면 끝납니다. 그런데 이 다음에 a의 x, y값을 바꾸려고 하면 이상한 오류가 발생하거나, `.` 연산자가 자기멋대로 `->` 로 바뀌게 됩니다. 이것의 이유는 `*` 연산자의 우선순위보다 `.` 연산자의 우선순위가 더 높아서인데요, 그래서 `*p.x = 5;` 와 같은 문장을 작성하면 일단 point 구조체의 **포인터 타입인** p 변수가 x 멤버를 참조한다는 건데, 포인터에는 그런게 없으므로 오류가 발생하게 되는 것이죠. 

그래서 `(*p).x` 과 같이 괄호로 `*` 연산을 먼저 처리해줘야 합니다. 하지만 이게 보기도 불편하고, 포인터의 포인터의 포인터... 같이 복잡해지면 보기에도 엄청 불편하기 때문에 `(*(*(*p1).node).node).node` 과 같이 됩니다.

그래서 C언어는 `->` 이라는 새로운 연산자를 도입했습니다. `p->x` 는 `(*p).x` 와 똑같은 의미가 되는거죠! 방금 위에 예시코드도 이 연산자를 쓰면 `p1->node->node->node` 와 같이 보기좋게 바꿀 수 있게 됩니다.

### 공용체

 구조체랑 똑같은 방법으로 쓰는데, 공용체 자료형 변수를 선언하면 공용체 내 변수중 가장 크기가 큰 자료형만큼만 메모리를 할당합니다.

```c
union test {
  int a;   // 4바이트
  char b;  // 1바이트
};

int main() {
  union test t;

  t.a = 10000;
  printf("%d %c\n", t.a, t.b);

  t.b = 'a';
  printf("%d %c\n", t.a, t.b);
}
```

위의 test가 구조체였다면, int를 위한 공간과 char를 위한 공간을 할당을 해서 총 5바이트가 할당되겠지만, 공용체는 제일 큰 자료형인 int만큼, 그러니까 4바이트만큼의 공간만을 할당합니다. 그래서 a만 바꿨는데 b의 값도 바뀌고, b의 값만 바꿨는데 a의 값도 바뀌게 되는 것이죠.

공용체는 주로 운영체제와 같이 극한의 최적화가 필요한 상황에만 주로 사용되기 때문에 이런게 있다라고만 알아두시면 됩니다.

### 열거형

숫자에 의미를 부여하기 위해 사용됩니다. 무슨 말이냐고요? 다음 코드를 보시죠.

```c
enum days { MON, TUE, WED, THU, FRI, SAT, SUN };

int main() {
  char weeks[7][10] = { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" };

  for (int i = MON; i <= SUN; i++)
        printf("오늘은 %s!\n", weeks[i]);

  return 0;
}
```

 우리가 0번째 일부터 6번째 일까지! 라고 하는것보다 월요일부터 일요일까지! 라고 하는 게 더 편하기 때문에, 열거형이라는 것이 추가되었습니다. 사실 열거형은 사용되는 특수한 상황이 존재하는데, 그 상황이 올 정도면 C언어를 이미 잘 다룰 수 있게 되셨을 때니까 이런 기능이 있다라고만 알아두시면 됩니다!
 참고로, MON부터 시작해서 0, 1, 2, 3, 4, 5, 6 과 같이 말 그대로 숫자에 이름이 붙는 형식으로 작동됩니다.

## 파일 입출력
***

 변수에 저장된 값들은 RAM에 저장되는데, 이 정보들은 프로그램이 종료되면 전부 사라져버리게 됩니다. 만약 프로그램이 끝나도 정보를 저장해놓고, 프로그램을 켰을 때 저장된 정보를 불러오게 하고 싶다면 하드디스크에 저장을 해야하는데, 그러기 위해서 사용되는 것이 파일이죠!

```c
int main() {
  FILE* fp;

  fopen_s(&fp, "data.txt", "w");

  if (fp == NULL) {
    perror("파일을 열지 못했습니다.");
    return 1;
  }

  int test;
  scanf_s("%d", &test);
  fprintf(fp, "파일에 정상적으로\n입력 완료되었습니다! %d", test);
}
```
 위의 코드를 실행하고, 아무 숫자나 입력해 보고, 소스코드가 있는 폴더에 들어가보면 (어딨는지 모르시다면 [솔루션 탐색기] 에서 "솔루션 ~~~" 를 우클릭하고 [파일 탐색기에서 폴더 열기] 를 클릭해보세요) data라는 .txt 파일이 생성되고, 그 안에는 잘 적힌 걸 보실 수 있습니다!

`fopen_s(파일포인터, 파일이름+확장자, 모드)`
파일을 여는 역할을 합니다. 파일에서 입력받을 때는 파일의 주소를 알아야 하기 때문에 **FILE \*** 타입을 사용해서 입력받습니다. 두번째 매개변수에는 확장자를 포함한 파일 이름을 적고, 세번째 매개변수는 파일을 열 때 선택할 모드인데, 주로 아래 3가지가 사용됩니다.

```
r : read, 입력할 때 씁니다. 파일이 없으면 오류가 발생합니다.
w : write, 출력할 때 씁니다. 파일이 없을 경우 새로 만들고, 있으면 덮어씌웁니다.
a : append, 출력할 때 씁니다. 파일이 없을 경우 새로 만들고, 있으면 뒤에 이어적습니다.
-b : rb, wb와 같이 사용되며 binary라는 이진 파일로 저장이 됩니다. 나중에 알아보세요!
```

 파일과 관련된 함수들은 평소에 쓰던것과 똑같은데(fprintf, fscanf\_s, fgets\_s) 실제로 사용법도 똑같습니다. 대신, 첫번째 매개변수로 사용할 파일 포인터를 넘겨줍니다.


 아래 예제를 진행하기 전에, 코드와 같은 경로에 `input.txt` 라는 파일을 하나 만들고, 안에 숫자를 원하는 만큼 적어주세요! (띄어쓰기나 줄바꿈 해서)
```c
int main() {
  FILE *fin, *fout;
  fopen_s(&fin, "input.txt", "r");
  fopen_s(&fout, "output.txt", "w");


  if (fin == NULL || fout == NULL) {
    printf("파일을 열지 못했습니다!");
    return 1;
  }
  
  int sum = 0, cnt = 0, max = -2000000000, min = 2000000000, tmp;
  
  while (fscanf_s(fin, "%d", &tmp) != EOF) {
    sum += tmp;
    cnt++;
    if (tmp > max) max = tmp;
    if (tmp < min) min = tmp;
  }
  
  fprintf(fout, "합계는 : %d\n", sum);
  fprintf(fout, "평균은 : %.2lf\n", (double)sum / cnt);
  fprintf(fout, "최대, 최소값은 : %d, %d", max, min);
}
```
 그러면 출력이 잘 나오실 거고, 이제 파일 함수들 쓰는 방법도 아셨을거라 생각합니다. 여기서 중요한 점은 `fscanf_s(fin, "%d", &tmp) != EOF` 부분인데, 파일로 입력을 받을 경우에는, 파일 끝에 도달했을때 EOF라는 값을 읽어오는데, 이는 **End of File** 의 약자입니다. 그래서 위의 문장은 파일에서 입력받은 값이 EOF가 아닌 동안 반복을 하는 것이죠. (EOF는 사실 -1라는 값입니다.)

### 절대경로, 상대경로

`fopen_s(..., "input.txt", ...)` 를 사용할 때, 중간에는 사실 파일의 경로까지 포함해서 적어줘야 합니다. 하지만 아무 경로도 입력해주지 않아도 코드랑 같은 위치에 파일이 생성되는데, 이는 **상대 경로**가 사용되어서 그렇습니다. C:/ 처럼 최상위 경로인 드라이브부터 모든 경로를 적는 것은 **절대 경로** 라고 하며, 예외없이 무조건 똑같은 경로에 파일이 생성됩니다. 상대 경로는 특정 폴더를 기준으로 하는 경로이며, 주로 소스 파일과 같은 경로/프로젝트의 경로가 기준이 됩니다.

`./input.txt`   :   ./는 현재 폴더를 의미하는데, 적어주지 않아도 현재 폴더가 기준이 됩니다.
`../input.txt`   :   ../는 상위 폴더를 의미합니다. 그러니까 상위 폴더에 있는 input.txt를 의미합니다.
`./File/Resources/input.txt`   :   ./는 적어주지 않아도 되는데, 현재 폴더에 있는 File 폴더 내의 Resources 폴더 내의 input.txt를 의미합니다.

위의 3가지가 상대경로를 사용하는 방법이고, 이걸 이용해서 어느 폴더나 이동할 수 있습니다! 절대 경로를 쓰는 경우는 거의 없다고 봐도 무방해요.

`../../Debug/Resources/input.txt` 처럼 혼합해서 사용할 수 있고, 우리가 폴더를 다루듯이 똑같이 사용하면 된다고 이해하시면 됩니다.

## 동적 메모리
***

 동적 메모리란 말 그대로 프로그램 실행 중에 동적으로(원하는 값으로) 배열을 선언하는 겁니다. 왜냐면 C언어에서는 배열의 크기를 무조건 상수(숫자)로밖에 정해줄 수 없기 때문이죠.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  int N;
  scanf_s("%d", &N);

  int* arr = (int*)malloc(sizeof(int) * N));
  for (int i = 0; i < N; i++) {
    scanf_s("%d", arr[i]);
  }

  for (int i = 0; i < N; i++) {
    printf("%d ", arr[i]);
  }

  free(arr);
}
```
malloc() 은 수동으로 메모리를 할당하는 함수입니다. 이게 무슨 뜻이냐면, 원래는 변수를 선언하면 알아서 해당 변수의 자료형의 크기(예: int면 4바이트) 만큼을 할당하고, 배열 또한 마찬가지인데 그 N바이트를 할당하는 것을 malloc()으로 해줄 수 있습니다. 예를들어 malloc(40)하면 40바이트의 공간이 할당되는 것이죠.

그런데 이 할당된 공간은 int형 기준으로 봤을때는 10개가 들어가고, char형 기준으로 봤을때는 40개가 들어갈 수 있는 공간입니다. 그래서 이 함수는 아무 포인터 타입(자료형)으로나 바뀔 수 있도록 **void \*** 타입을 반환하게 되는데, 이는 **명시적 형변환** 으로 우리가 써줄 타입으로 변환해주어야 합니다. 그래서 위 코드에서는 int형 배열을 만들고 싶기 때문에 `int *`형 변수를 선언하고, malloc의 반환값을 명시적 형변환 `(int *)` 을 이용해 타입을 바꿔준 것이죠.

위쪽 챕터에서 "배열과 포인터" 를 찾아보시면 왜 이것만으로 원하는 길이의 배열을 만들 수 있는지 알 수 있는데, 배열을 선언한다는 것은 포인터를 선언하는 것과 같고, 해당 포인터가 배열의 크기만큼 선언된 메모리들의 첫번째 주소를 가지고 있기 때문입니다. 변수랑은 다르게, 배열을 선언하면 배열의 모든 원소들의 주소가 메모리상에 이어져 있기 때문이죠.

`sizeof(<자료형>)` 은 안쪽에 아무 자료형이나 넣으면 해당 자료형의 크기를 알려줍니다. 왜냐면 int가 4바이트고, double은 8바이트다라는 메모리 크기를 다 외우고 다닐수도 없고, 특히나 구조체의 경우는 구조체 내부의 모든 멤버변수의 크기의 합을 구해야 하기 때문에 헷갈릴 수 있기 때문이죠. 그래서 위의 코드에서 `sizeof(int) * N` 부분은 int 타입의 크기가 N개만큼 있는 메모리 크기라고 해석할 수 있습니다.

`free()` 는 할당된 메모리를 해제해주는 역할을 합니다. 수동으로 할당했기 때문에, 자동으로 해제되지 않아서 까먹지 말고 꼭 메모리를 해제해주어야 합니다. 아니면 코드가 실행될 때마다 메모리를 할당하고, 그 할당된 메모리가 쓰이지는 않지만 남아있어서 **메모리 누수**가 발생할 수 있거든요.

2차원 배열을 동적 할당하고싶으면 다음과 같이 더블 포인터를 사용해주면 됩니다. 포인터의 포인터가 있어야 배열의 배열을 사용할 수 있기 때문이죠.

```c
int N, M;
scanf_s("%d%d", &N, &M);

int** arr = (int**)malloc(sizeof(int*) * N);
for (int i = 0; i < N; i++) {
  arr[i] = (int*)malloc(sizeof(int) * M);
}

// 출력 등등

for (int i = 0; i < N; i++) {
  free(arr[i]);
}
free(arr);
```
일단 배열들의 위치를 기억할 공간을 동적할당하고, 그 배열들을 각각 또 따로 동적할당 해줍니다. 그래서 메모리를 해제할 때도 배열 안의 배열들을 먼저 해제해주고, 마지막으로 배열들의 위치를 가지고 있는 포인터를 해제해 줘야 하죠.

## 더 알아보기

### 부록: 매크로 함수

매크로 함수는 함수의 내용을 어느정도 이해하셨다면 아래의 글을 보고 쉽게 이해하실 수 있을거에요.<br>
[링크](https://modoocode.com/99)

### 부록: 모듈화 프로그래밍

지금까지는 거의 소스파일 하나에서만 작업을 했지만, 실제 프로그램에서 이렇게 하면 보기도 불편하고, 다른사람과 협업할 수도 없겠죠? 그래서 아래 글은 소스코드를 분리하는 법을 알려줍니다.<br>
[링크](https://modoocode.com/87)

### 부록: 전처리기

#include 와 같이 #이 붙는 키워드는 전처리기라고 합니다. 가끔 요긴하게 사용되죠.<br>
[링크](https://modoocode.com/88)