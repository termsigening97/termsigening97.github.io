---
title: '유니티 그래픽스 최적화'
date: 2022-05-12 14:00:00 +0900
categories: [Lecture, Game Dev]
tags: [Optimize]
---

## 2종류의 드로우콜

드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다.

Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다.

SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다.

이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 드로우콜이 늘어난다.

## Batching(배칭)

여러 오브젝트들에게 동일한 Material을 사용하게 하여서 SetPass call을 줄이는 것. 텍스처 아틀라스(Atlas) 기법으로 서로 다른 오브젝트임에도 하나의 텍스쳐로 합쳐서 머티리얼을 공유시키면 Batch는 메쉬당 여러번이라도 SetPass는 공유된 머티리얼만큼만 호출된다.

여기서 머티리얼이란 머티리얼 인스턴스를 말하며, 같은 머티리얼이라도 다른 에셋(복사본 등)이라면 Batching되지 않는다.

또한, 스크립트로 접근할 때에도 주의해야하는데, 아래와 같이 Renderer 컴포넌트의 material 속성을 수정하면 머티리얼의 복사본이 생성된다.

`GetComponent<Renderer>().material.color = Color.red;`

대신 sharedMaterial을 사용하면 공유하고 있는 머티리얼을 수정할 수 있지만, 해당 머티리얼을 사용하는 모든 오브젝트에 적용된다.

Edit [>] Project Setting [>] Player
에서 Static Batching, Dynamic Batching을 사용할 수 있고, 조건이 맞으면 자동 배칭이 된다.

## Static Batching

정적인 오브젝트들을 위한 배칭 기법이며, 주로 배경 오브젝트에 해당된다. GameObject 속성에서 Static을 체크해줘야만 적용되며, 이 Static에 대해 모른다면 이동/회전/스케일이 조절되지 않는, 게임 시작부터 끝까지 절대로 변화하지 않는 오브젝트이다. 그렇기에 로딩 시간에 자동 배칭하여서 성능이 매우 뛰어나다.

Mesh의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 Mesh를 그릴 때의 드로우콜을 줄여준다. Batch콜 자체를 줄여주는데, 내부적으로 모든 Mesh를 합친다. 그래서 원래 3개의 오브젝트가 1개의 Mesh만 사용한다면 메모리에는 1개의 Mesh만 있으면 되는데, Static Batching에서는 3개의 Mesh를 합친 만큼의 메모리가 필요하게 된다.

런타임 중에 생성된 Static 오브젝트들은 자동 배칭처리되지 않으며, 배칭처리를 하고싶다면 생성 후에 `StaticBatchingUtility.Combine()` 메서드를 사용해야 한다. 하지만 이 방법을 사용하면 Mesh를 재생성해야하기 때문에 많은 시간이 필요해서 일반적으로 사용되지 않는다.

보통 배경을 모듈화 방식으로 제작하여(바닥, 벽, 기둥 따로) Static Batching을 이용한다. 3D툴에서 하나의 커다란 Mesh로 미리 만들어온다면 카메라에 가려져 보이지 않는 Culling 처리가 이루어질때 일부만 보여도 전체의 폴리곤이 처리가 되기 때문이다.

## Dynamic Batching

비 Static인 오브젝트들의 Vertex들을 모아서 합쳐서 오버헤드가 발생하지만 드로우콜을 줄여 전체적인 성능 향상을 가져오는 것.

단, Skinned Mesh와 Vertex가 너무 많은 Mesh는 제외된다.

가끔 오버헤드가 더 많아 시간이 더 소요되는 경우도 있고, 제약사항이 많이 있기 때문에 성능이 크게 향상되지는 않을 수 있다.

## Frustum Culling

카메라 범위 밖은 렌더링 하지 않는것. 자동으로 처리되어서 따로 설정해줄 필요는 없고, 특히 고전게임 분야에서 시야 전체를 렌더링하지 않고 근~중거리만 렌더링하여 잘린 부분을 안개로 채운다. 또는, 애초에 탑뷰 시점 등으로 게임을 만들어서 사야를 넓게 보이지 않게한다.

## Occlusion Culling

다른 오브젝트에 가려진 오브젝트는 렌더링 하지 않는것. Window [>] Rendering [>] Occlusion Culling에서 Bake을 눌러 생성할 수 있다. Occluder는 가려지게 하는 오브젝트, Occludee는 가려지는 오브젝트를 의미하는데 Occluder는 사전 데이터가 필요하기 때문에 Static 오브젝트만 가능하고, Occludee는 Dynamic 오브젝트도 가능하다. Mesh Renderer 컴포넌트에 Dynamic Occluded 옵션이 체크되어있으면 활성화된다.

미리 데이터를 만들어 두는 것이기 때문에 정밀도를 설정해야 하는데, 정밀도가 높을수록 데이터 크기가 증가하고 연산 오버헤드가 발생한다. 적절히 테스트해서 맞추어야 한다.

## LOD(Level of Detail)

카메라와의 거리에 따라 오브젝트의 퀄리티를 조절해서 보여주는 기능이다. 자동으로 만들어 주는 것도 있지만, 대부분 단계별 LOD Mesh를 만들어서 사용한다.