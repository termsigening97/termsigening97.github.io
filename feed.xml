<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://termsigening97.github.io/</id><title>Sigening</title><subtitle>Personal Studies, Devlogs and Lectures</subtitle> <updated>2022-05-12T14:21:25+09:00</updated> <author> <name>Jun Hwi Gu</name> <uri>https://termsigening97.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://termsigening97.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://termsigening97.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Jun Hwi Gu </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>유니티 그래픽스 최적화</title><link href="https://termsigening97.github.io/posts/unity-optimization/" rel="alternate" type="text/html" title="유니티 그래픽스 최적화" /><published>2022-05-12T14:00:00+09:00</published> <updated>2022-05-12T14:21:07+09:00</updated> <id>https://termsigening97.github.io/posts/unity-optimization/</id> <content src="https://termsigening97.github.io/posts/unity-optimization/" /> <author> <name>Jun Hwi Gu</name> </author> <category term="Lecture" /> <category term="Game Dev" /> <summary> 2종류의 드로우콜 드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다. Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다. SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다. 이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 ... </summary> </entry> <entry><title>지식 스크랩</title><link href="https://termsigening97.github.io/posts/Scraps/" rel="alternate" type="text/html" title="지식 스크랩" /><published>2022-05-12T13:30:00+09:00</published> <updated>2022-05-12T14:00:33+09:00</updated> <id>https://termsigening97.github.io/posts/Scraps/</id> <content src="https://termsigening97.github.io/posts/Scraps/" /> <author> <name>Jun Hwi Gu</name> </author> <category term="Develop" /> <summary> Informative URLS Refactoring &amp;amp; Design Pattern Website Unreal Engine Multiplayer - Replication Youtube Tiny Facts 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는, 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 상황이 보인다. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 구상한 ... </summary> </entry> <entry><title>알고리즘 패러다임</title><link href="https://termsigening97.github.io/posts/algorithmic-paradigm/" rel="alternate" type="text/html" title="알고리즘 패러다임" /><published>2022-04-02T00:00:00+09:00</published> <updated>2022-04-02T00:00:00+09:00</updated> <id>https://termsigening97.github.io/posts/algorithmic-paradigm/</id> <content src="https://termsigening97.github.io/posts/algorithmic-paradigm/" /> <author> <name>Jun Hwi Gu</name> </author> <category term="Lecture" /> <category term="Basic" /> <summary> 알고리즘 패러다임 알고리즘 패러다임(Algorithmic Paradigm) 혹은 알고리즘 디자인 패러다임은 자주 등장하는 알고리즘 접근법을 의미하며, 여러 문제에 통상적으로 사용될 수 있습니다. 이 게시글을 이해하기 위해서는 일반적인 자료구조와 재귀함수를 응용할 수 있어야 함을 알립니다. 완전탐색 브루트 포스(Brute Force) 알고리즘이며, 모든 경우의 수를 전부 탐색하는 것을 의미합니다. 백트래킹 분할 정복 문제를 간단히 풀 수 있을 때까지 계속 분할하고, 분할된 문제의 해답을 찾아 그 해답을 합쳐서 문제를 해결하는 방식입니다. 다음과 같은 세가지 단계로 나뉠 수 있는데, 분할(divide) : 문제를 같은 방식으로 해결할 수 있는 부분 문제로 나눈다 정복(conquer) ... </summary> </entry> <entry><title>[BOJ] 2481 해밍 경로</title><link href="https://termsigening97.github.io/posts/BOJ-2481/" rel="alternate" type="text/html" title="[BOJ] 2481 해밍 경로" /><published>2022-03-21T19:23:00+09:00</published> <updated>2022-03-21T19:23:00+09:00</updated> <id>https://termsigening97.github.io/posts/BOJ-2481/</id> <content src="https://termsigening97.github.io/posts/BOJ-2481/" /> <author> <name>Jun Hwi Gu</name> </author> <category term="Lecture" /> <category term="Problemset" /> <summary> KOI 2010 M3 이 문제를 풀기 위해서는 각 이진수들끼리의 서로 다른 비트의 개수를 구한 다음, 해밍 경로가 되는 이진수끼리 연결한 그래프를 만들어 BFS를 이용해 1번 이진수까지의 경로를 구해야 합니다. 입력 처리 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; int main() { int N, K; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K; map&amp;lt;int, int&amp;gt; check; vector&amp;lt;int&amp;gt; v(N); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(N);... </summary> </entry> <entry><title>[BOJ] 2461 대표 선수</title><link href="https://termsigening97.github.io/posts/BOJ-2461/" rel="alternate" type="text/html" title="[BOJ] 2461 대표 선수" /><published>2022-03-21T18:34:00+09:00</published> <updated>2022-03-21T18:34:00+09:00</updated> <id>https://termsigening97.github.io/posts/BOJ-2461/</id> <content src="https://termsigening97.github.io/posts/BOJ-2461/" /> <author> <name>Jun Hwi Gu</name> </author> <category term="Lecture" /> <category term="Problemset" /> <summary> KOI 2011 M3 우선 시간을 고려하지 않은, 원초적인 풀이방법을 생각해 봅시다. 일단 각 반에서 최솟값인 학생들을 찾은 후에, 해당 학생들로 점수를 계산(최대값 - 최소값)합니다. 그 후에, 지금 골랐던 학생들 중 점수가 가장 낮은 학생을 다음 학생으로 교체하는 것이죠. 그런데 이렇게 최솟값을 찾으면 기하급수적인 시간이 소요되기 때문에, 일단 각 반들을 정렬해놓고 푸는 방법을 생각할 수 있습니다. 그런데 이제 각 반들을 정렬하고 현재 고른 학생들 중 최솟값을 다음 학생으로 바꾸는 작업 또한 최솟값을 찾아야 하기 때문에 시간초과가 나게 됩니다. 그래서 생각할 수 있는 다음 방법은, 전체 학생들을 정렬하는 것이죠. 입력 처리 #include &amp;lt;iostream&amp;gt; #include... </summary> </entry> </feed>
