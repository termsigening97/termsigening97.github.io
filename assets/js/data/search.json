[ { "title": "유니티 그래픽스 최적화", "url": "/posts/unity-optimization/", "categories": "Lecture, Game Dev", "tags": "Optimize", "date": "2022-05-12 14:00:00 +0900", "snippet": "2종류의 드로우콜드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다.Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다.SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다.이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 드로우콜이 늘어난다.Batching(배칭)여러 오브젝트들에게 동일한 Material을 사용하게 하여서 SetPass call을 줄이는 것. 텍스처 아틀라스(Atlas) 기법으로 서로 다른 오브젝트임에도 하나의 텍스쳐로 합쳐서 머티리얼을 공유시키면 Batch는 메쉬당 여러번이라도 SetPass는 공유된 머티리얼만큼만 호출된다.여기서 머티리얼이란 머티리얼 인스턴스를 말하며, 같은 머티리얼이라도 다른 에셋(복사본 등)이라면 Batching되지 않는다.또한, 스크립트로 접근할 때에도 주의해야하는데, 아래와 같이 Renderer 컴포넌트의 material 속성을 수정하면 머티리얼의 복사본이 생성된다.GetComponent&amp;lt;Renderer&amp;gt;().material.color = Color.red;대신 sharedMaterial을 사용하면 공유하고 있는 머티리얼을 수정할 수 있지만, 해당 머티리얼을 사용하는 모든 오브젝트에 적용된다.Edit [&amp;gt;] Project Setting [&amp;gt;] Player에서 Static Batching, Dynamic Batching을 사용할 수 있고, 조건이 맞으면 자동 배칭이 된다.Static Batching정적인 오브젝트들을 위한 배칭 기법이며, 주로 배경 오브젝트에 해당된다. GameObject 속성에서 Static을 체크해줘야만 적용되며, 이 Static에 대해 모른다면 이동/회전/스케일이 조절되지 않는, 게임 시작부터 끝까지 절대로 변화하지 않는 오브젝트이다. 그렇기에 로딩 시간에 자동 배칭하여서 성능이 매우 뛰어나다.Mesh의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 Mesh를 그릴 때의 드로우콜을 줄여준다. Batch콜 자체를 줄여주는데, 내부적으로 모든 Mesh를 합친다. 그래서 원래 3개의 오브젝트가 1개의 Mesh만 사용한다면 메모리에는 1개의 Mesh만 있으면 되는데, Static Batching에서는 3개의 Mesh를 합친 만큼의 메모리가 필요하게 된다.런타임 중에 생성된 Static 오브젝트들은 자동 배칭처리되지 않으며, 배칭처리를 하고싶다면 생성 후에 StaticBatchingUtility.Combine() 메서드를 사용해야 한다. 하지만 이 방법을 사용하면 Mesh를 재생성해야하기 때문에 많은 시간이 필요해서 일반적으로 사용되지 않는다.보통 배경을 모듈화 방식으로 제작하여(바닥, 벽, 기둥 따로) Static Batching을 이용한다. 3D툴에서 하나의 커다란 Mesh로 미리 만들어온다면 카메라에 가려져 보이지 않는 Culling 처리가 이루어질때 일부만 보여도 전체의 폴리곤이 처리가 되기 때문이다.Dynamic Batching비 Static인 오브젝트들의 Vertex들을 모아서 합쳐서 오버헤드가 발생하지만 드로우콜을 줄여 전체적인 성능 향상을 가져오는 것.단, Skinned Mesh와 Vertex가 너무 많은 Mesh는 제외된다.가끔 오버헤드가 더 많아 시간이 더 소요되는 경우도 있고, 제약사항이 많이 있기 때문에 성능이 크게 향상되지는 않을 수 있다.Frustum Culling카메라 범위 밖은 렌더링 하지 않는것. 자동으로 처리되어서 따로 설정해줄 필요는 없고, 특히 고전게임 분야에서 시야 전체를 렌더링하지 않고 근~중거리만 렌더링하여 잘린 부분을 안개로 채운다. 또는, 애초에 탑뷰 시점 등으로 게임을 만들어서 사야를 넓게 보이지 않게한다.Occlusion Culling다른 오브젝트에 가려진 오브젝트는 렌더링 하지 않는것. Window [&amp;gt;] Rendering [&amp;gt;] Occlusion Culling에서 Bake을 눌러 생성할 수 있다. Occluder는 가려지게 하는 오브젝트, Occludee는 가려지는 오브젝트를 의미하는데 Occluder는 사전 데이터가 필요하기 때문에 Static 오브젝트만 가능하고, Occludee는 Dynamic 오브젝트도 가능하다. Mesh Renderer 컴포넌트에 Dynamic Occluded 옵션이 체크되어있으면 활성화된다.미리 데이터를 만들어 두는 것이기 때문에 정밀도를 설정해야 하는데, 정밀도가 높을수록 데이터 크기가 증가하고 연산 오버헤드가 발생한다. 적절히 테스트해서 맞추어야 한다.LOD(Level of Detail)카메라와의 거리에 따라 오브젝트의 퀄리티를 조절해서 보여주는 기능이다. 자동으로 만들어 주는 것도 있지만, 대부분 단계별 LOD Mesh를 만들어서 사용한다." }, { "title": "지식 스크랩", "url": "/posts/Scraps/", "categories": "Develop", "tags": "Other", "date": "2022-05-12 13:30:00 +0900", "snippet": "Informative URLSRefactoring &amp;amp; Design Pattern Website Unreal Engine Multiplayer - Replication YoutubeTiny Facts 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는, 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 상황이 보인다. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 구상한 아이디어로 프로토타입을 작성하여 플레이테스트를 해 보아라. 이 때, 프로토타입은 필수적인 기능만 빠르게 작성하도록 한다. 또한, 반복작업을 통해 개선하라.프로토타입이 좋다고 해도 이를 바로 최종 결과물로 가능한 작성하지 마라.프로토타입에서 아이디어가 나오지는 않는다. 이는 단지 어떤 것이 좋은 아이디어인지, 나쁜 아이디어인지 판단을 가능하게 해 준다. 만약 내 게임을 설명할 때 “어떤 게임과 비슷하지만 어떤 스토리와 배경을 가지고 있다” 와 같이 기존 게임의 복제판에 불과한 게임을 만들고 싶지 않다면 자신의 원래 개념으로 돌아가 “이 아이디어에서 특별한 것은 무엇인가?” 라고 묻는 것이다.Personal Studies 인생의 12가지 법칙 - 질서너머 中 기존 제도나 창의적 변화를 함부로 깎아내리지 마라 내가 누구일 수 있는지 상상하고, 그것을 목표로 삼아라 원치 않는 것을 안개 속에 묻어두지 마라 남들이 책임을 방치한 곳에 기회가 숨어 있음을 인식하라 하고 싶지 않은 것을 하지 마라 이데올로기를 버려라 최소한 한 가지 일에 최대한 파고들고, 그 결과를 지켜보라 방 하나를 할 수 있는 한 아름답게 꾸며보라 여전히 나를 괴롭히는 기억이 있다면 아주 자세하게 글로 써보라 관계의 낭만을 유지하기 위해 성실히 계획하고 관리하라 분개하거나 거짓되거나 교만하지 마라 고통스러울지라도 감사하라 여기서 가장 큰 교훈은, 무언가를 평가하기 위해서는 그것에 대해 완전히 이해해야 한다는 점이다. 젊은 혈기에 근거없이 현재의 제도를 비판하지 말고 그 제도의 이유를 먼저 알고, 설득하라.더 높은 도덕을 위해 법칙을 깨려는 사람은 처음에는 그 법칙을 철저히 익히고 훈련해서 그 필요성을 이해해야 한다. 그리고 법칙의 자구字句 가 아니라 그 정신에 맞게 법칙을 깨야 한다. 반복 설계iterative design어떤 설계안은 본질적으로 오류가 발생하기 쉬우므로 고치지 말고 버려야 한다, 설계 과정에서 이런 막다른 골목을 예상해야 한다, 막다른 골목에 이르기까디 쏟아 부은 노력은 깔끔하고 산뜻한 새 출발을 위해 치르는 작은 대가에 불과하다.하지만 많은 관리자들이 그랬다가는 상사와 굉장히 곤란한 정치적 갈등에 빠지리라 생각한다. 이는 장기적으로 돈이 더 들더라도 불량 버전을 수선하는 게 낫다고 생각하는 것과 같다. 무지의 5단계 0단계 무지 - 무지의 부재 (Lack of Ignorance)무엇을 해야할지, 어떻게 표현할 지 알고 있는 단계 1단계 무지 - 지식의 부재(Lack of Knowledge)어떻게 해야 할지 모르지만, 하기 위해서 무엇을 배워야 할 지 아는 단계. 2단계 무지 - 지각의 부재(Lack of Awareness)어떤 것을 모른 다는 것을 모르는 단계. 3단계 무지 - 프로세스의 부재(Lack of Process)어떤 모르는 것에 대해서 모른 다는 것(2단계 무지)을 알아내기 위한 적당하고 효율적인 방법 모르는 단계 4단계 무지 - 메타 무지 (Meta-Ignorance)무지의 5단계에 대해서 모르는 단계. 산만의 지속세대 차이를 뚜렷이 부각하는 요소는 집중이다. 나이 든 사람은 한 번에 한두 가지 일에 집중하는 반면 젊은이들은 온갖 일에 주의를 분산한다.아이팟으로 음악을 틀어놓고, 끊임없이 문자를 하며, SNS 사이트는 24시간 열어두고, 학교 숙제 도중에 간간히 비디오 게임도 해가며 공부하는 세대를 린다 스톤은 “산만의 지속” 이라고 묘사한다. 젊은 신입은 이런 환경에서 가장 효율적으로 일한다고 말한다.문제는 산만의 지속이 몰입과는 정확히 반대 상태라는 사실이다. 일을 하는데 몰입이 필수라는 것에 동의한다면, 어느 선에서 주의의 분산을 제지해야 한다. 업무 시간 2%를 한번에 연달아 페이스북에 쏟는 경우와 종일 주의의 2%를 페이스북에 쏟는 경우가 다르다는 사실을 젊은 신입이 이해하게 해야된다. 몰입하지 못해 일에 장애가 생기기 때문이다. 인적 자본 투자회사가 사람에게 투자하는 돈에 관리자가 바라보는 관점은 중요하다. 인적 자본에는 실체가 있다. 이것을 버리는 돈(경비)로 잘못 생각하면 조직이 투자한 가치를 보존하지 못하는 행동을 관리자가 무심코 저지르게 만들지도 모른다.물론 ‘조직이 투자한 가치를 보존하지 못하는 행동’은 문제 있는 관리의 전형적인 표본이다. 중간 관리층과 경영진이 장기적인 성장을 희생해 단기적인 성과를 내는(당장의 분기 수익을 높이는)더 나은 방법을 내놓겠다고 서로 경쟁하며 싸운다. 보통은 이것을 “손익 계산만을 문제 삼은 의식”이라 부르지만, 우리는 또 다른 이름인 “종자용 옥수수 먹기” 라 부른다. 잘못된 면접 방식 똑똑한 척하는 면접관을 세운다: 이 면접관은 사사로운 즐거움을 위해 지원자를 힘든 상황으로 몰아붙일것이다. 수수께끼식 질문을 던진다: 비행기에 골프 공이 몇 개나 들어갈까? 구글이 했었던 면접이지만 이제 그 당사자들도 잘못된 것을 깨닫고 이런 질문을 그만둔지 오래이다. 개발능력과 아무 상관이 없다. 답을 모르는 질문을 한다: 면접관으로서 어떤 질문에 어떤 답변이 나와야 하는지 잘 모르겠다면 채용 중인 직무와 관련해서는 그다지 중요한 질문이 아닐 가능성이 높다. 지원자를 바보로 만든다: “내가 질문에 대답을 다 하고, 구현했던 아키텍처에 대해 설명을 요청해 주었을 때 즉시 일어나서 화이트보드에 설명을 했다. 그때 내 직속 상관이 될 면접관이 “너무 단순하네요. 그건 제대로 된 실제 아키텍처가 아닙니다.” 라고 하였다. 그래서 “감사합니다. 이 단순한 아키텍처가 3개 대륙에 걸쳐 2천만 명이 넘는 가입자를 서비스하고 있습니다. 간단한 시스템으로 해냈다는 것을 기쁘게 생각합니다.” 라고 말했고, 면접 기회를 준 것에 감사를 표하고 자리를 떠났다. 인터넷 접속을 막는다: 코딩 면접을 할 때 진짜 코딩 실력을 알겠다는 이유로 이러는 것은 말도 안된다. 솔루션 탐색 능력 또한 지원자에게 필요한 능력이며, 인터넷 검색때문에 코딩 면접이 변별력을 잃을 수 있다면 면접 과제 자체에 문제가 있는 것이다. 종이에 코드를 작성하게 한다: 우리는 학교처럼 의사 코드로 평가하는 것이 아니다. 실제도구를 이용해서 생산된 실제 코드를 평가해야 한다. 알고리즘 문제를 낸다: 시스템 개발에 필요한 상당수의 업무들이 알고리즘에 대한 깊은 이해를 필요로 하지 않는다. “지원자의 문제 해결 능력을 보아야 한다.” 라는 이유인데, 맞는 말이지만 회사의 실제 프로젝트와 가까운 다른 연습문제를 통해서도 이를 평가할 수 있다. 여러 시스템의 문제는 테스트가 부족하거나, 잘못된 설계, 떨어지는 응집성, 깊은 종속성, 새 기능 추가 시 부족한 리팩토링, 지속적인 요구사항 변경, 도메인 모델이 정교하지 못했다는 것들 등이 흔한 문제이다. 알고리즘은 절차적이고 함수적이며, 구현할 때 비즈니스 도메인 모델이나 클래스를 만들지는 않는다. 문제의 요지는, 회사에 필요한 개발능력을 평가해야한다. 알고리즘이 필요한거라면 알고리즘을, TDD(테스트주도개발)능력이 필요한거라면 그에 걸맞는 코딩 문제를 재시해야한다. 전화 면접을 한다: 시간이 부족할때만 해라. 딱딱하게 진행될 가능성이 높다. 잘못된 채용 공고로 애들러Lou Adler“ 기술과 경험을 나열하는 전통적인 직무 요건은 재능에도 반하고, 다양성에도 반하며, 성공적인 채용과의 상관관계도 최악이다 “ 절대적인 숫자 숫자는 임의적이고 오해하기 쉬우며 변덕스럽다. 5년 간의 자바 경력… 얼마 이상의 대학 학점… 과 같은것은 후보자를 제대로 선별하는 데 별 도움이 안된다. 채용된 후에 새로운 기술 학습 없이 같은 기술만으로 오래 일하는 개발자들이 많고, 이는 매년 새로운 기술을 익힌 개발자에 비해 1/5의 가치를 지니고 있다고 할 수도 있다. 키워드 매칭 채용 담당자들은 특정 기술이나 플랫폼에 대한 약어들을 선호하지 않는다. 채용 담당자는 해당 업무의 본질적인 부분을 잘 모르기 때문에 선무당에게 굿을 맡기는 결과가 된다. 기술 목록의 나열 불필요하게 너무 많은 기술 목록을 나열하면 재능있고 정직한 개발자가 스스로 지원을 포기하게 만들 수 있다. 보통 더 나은 개발잘르 선별하려는 욕심에 필요한 기술에 희망 기술까지 더해지기 일쑤다. 이는 후보군만 줄이는 행동이며 실제 그 업무를 잘하기 위한 것과 전혀 관계가 없다. 잘못된 기업 문화 설명 기업의 가치와 기대되는 태도, 책임을 채용 공고에 잘못 설명하는 경우가 많다. 팀워크, 긍정적 태도, 열정, 지혜로움과 같은 단어들을 나열하지 않도록 한다. 이러한 것들 중 어느 하나라도 자신이 해당하지 않는다고 스스로를 배제하는 지원자는 없다. 잘못된 요구 항목 더 훌륭한 개발자를 유인하기 위해서는 기술, 경력 년수, 일한 산업군, 출신 학교, 학점보다 그 직무에서 무엇을 책임져야 하는지 설명하는 것이 훨씬 낫다. 위에 나열된 항목들은 실제 역량과 전혀 일치하지 않는다. 잘못된 선별 조건 직무 요건들은 최고의 인재를 얻기 위함이 아닌 아닌 최악의 인재들을 걸러내기 위한 목적으로 설계되어 있다. 최고의 개발자들은 특정 기술의 사용 유무보다 회사의 문화, 업무에서의 책임, 프로젝트의 종류를 훨씬 더 중요하게 여긴다. 승진 요건과의 불일치 승진심사 때, 특정 프레임워크의 API를 알고있거나 자바 경력이 몇년 이상이라서 승진하지 않고, 그가 이룬 성과와 리더십, 팀워크와 같은 다른 중요한 이유로 승진을 한다. 채용 공고의 직무 요건이 이러한 승진 요건과 합치되는 부분이 없다면 그 직무 요건으로 필터링된 사람들이 회사 안에서 좋은 성과를 낼 거라는 기대 자체가 모순이다. 단순한 설계를 위한 네 가지 원칙 모든 테스트의 통과 중복의 최소화 : 동작/설정에 중복이 있으면 안된다. 명료성의 최대화 : 명료하고, 충분히 표현되고, 일관되어야 한다. 구성요소의 최소화 : 메서드, 클래스, 모듈의 수는 가능한 적어야 한다. 오디션 개최 (in “Peopleware”)우리가 몸담은 업계는 기술적이보다는 사회적이다. 직원-기계의 소통 능력보다 서로와 소통하는 능력이 더 주요하다. 그러므로 직원 채용 절차는 최소한 사회적이고 인간적인 의사소통 역량에 초점을 맞춰야 하며, 이 책의 저자가 발견한 최선의 방법은 후보자에 대한 오디션이다.개념은 간단하다. 과거에 자신이 수행한 업무와 관련해 10분에서 15분정도 프레젠테이션을 시킨다. 생전 처음 써봤던 새 기술/경험일 수도 있고, 힙겹게 깨우친 관리 경험일 수도 있고, 아주 재미있었던 프로젝트일 수도 있다. 주제는 지원자가 선택하고, 발표일을 정해 지원자와 함께 일할 사람들로 소규모 청중을 구성한다.물론 지원자는 긴장하고, 안 하려고 들지도 모른다. 누구나 긴장하기 마련이라고 말해주라. 오디션을 여는 이유도 설명하라. 다양한 지원자들의 의사소통 능력을 보고, 미래 동료 직원들을 채용 과정에 참여시키려는 의도라 설명한다.오디션을 마치고 지원자가 떠난 다음 참석자들과 간단히 후기를 나눈다. 각 참석자가 돌아가며 지원자가 업무에 적합한지, 그리고 팀과 잘 어울릴지 의견을 말한다. 물론 최종적인 결정은 관리자에게 달렸지만 미래 동료 직원들이 내놓는 의견은 굉장히 소중한다. 게다가 이렇게 고용한 신입 직원은 팀도 무리 없이 받아들인다. 팀원들이 뽑자 햇기 때문이다.” 오디션을 열면 신입 직원과 기존 직원들이 더 빨리 친해진다. 성공적인 오디션은 동료들로부터 받는 일종의 인증이었고, 반대의 경우도 역시 일종의 인증이었다. 실패한 오디션 후에는 직원들의 사기가 확 올라갔다. 자신을 채용한 이유가 하필 그 때 관리자의 책상에 이력서가 놓여 있었던 뜻밖의 행운 때문이 아니라는 사실을 지속적으로 보여주는 증거이기 때문이다. “오디션을 열 대는 한 가지 주의할 사항이 있다. 지원자는 회사가 하는 일과 직접 관련 있는 주제를 다뤄야 한다. “랭커 찍은 게임” 이나 “정원 가꾸기” 등 극단적인 주제라면 지원자는 굉장한 열정으로 발표하겠지만, 직장에서는 그런 열정을 못 볼지도 모른다. 베테랑 프로그래머와 대규모 프로젝트뛰어난 프로그래머들과 좀 처지는 이들 간에는 상당한 생산성 차이가 있고, 이를 대부분의 관리자는 알고 있지만 정확히 수치적으로 나타낸다면 가장 뛰어난 사람과 가장 못한 사람의 생산성 비율이 평균 10:1이나 되고, 실행 속도와 사용 공간 면에서는 다섯 배의 차이가 난다. 간단히 말해, 연복 2만 달러를 받는 프로그래머가 1만 달러를 받는 이에 비해 열 배의 생산성을 발휘할 수 있다는 뜻이며, 물론 그 반대 또한 가능하다. 이 연구의 데이터에서는 경력 연차와 성과 사이에 어떠한 상관 관계도 없었는데, 이는 경험을 하며 실제로 공부하고, 배워서 자신을 발전시키는지 아닌지에 대한 차이인 것 같다.서로 소통해야 하는 사람 수가 전체 비용에 영향을 미친다. 사람이 많을수록 커뮤니케이션 부담은 N(N-1)/2 배가 되며 어느 순간 인력(맨-먼스, Man-Month) 을 투입해서 얻는 이익보다 손실이 더 많아질 지경에 이르게 될 수 있다. 이것은 비용의 대부분이 커뮤니케이션, 그리고 잘못된 커뮤니케이션의 부작용을 바로잡는 데 소요되기 때문이다. 이는 가능하면 적은 수의 사람들에 의해 시스템이 만들어는 편이 낫다는 것을 시사한다. 개념적 일관성이 부족한 결과물을 만들어 내기 때문이기도 하다.보통 프로그래머 수백 명이 투입된 프로젝트보다 일급 멤버들로 구성된 작고 예리한 팀이 낫다고 하는데, 그 말 아래에는 앞의 수백 명은 평범하다는 뜻이 깔려 있다. 하지만 이는 “어떻게 해야 ‘큰’ 시스템을 의미 있는 일정 내에 만들어 낼 수 있는가?” 라는 어려운 질문을 회피하는 것을 뜻한다.예를 들어보자. 200명이 투입된 프로젝트 내에 관리자이면서 가장 유능하고 경험 많은 프로그래머가 25명이 있다면, 나머지 175명은 해고하고 그 관리자들을 다시 프로그래밍에 투입하는 것이다.하지만 이는 작은 팀은 아닌데, 보통 작은 팀이라면 10명 이하를 뜻하기 때문이다. 25명이면 최소 두 단계로 관리가 이루어지거나 5명의 관리자를 두어야 하는 규모이다. 이 팀에는 재무, 인사, 사무 공간, 비서 업무, 장비 운영에 추가 지원도 필요할 것이다.하지만 다른 한편으로, 200명인 원래 팀은 정말로 큰 시스템을 주먹구구식으로 만들기에 충분한 규모가 아니다. OS/360의 개발에는 프로젝트에 1000명 넘게 투입되었고, 1963~1966년까지 이 시스템의 설계-구축-문서화에 들어간 공수는 대략 5000맨이어(Man-Year) 정도였다. 밀스Mills의 제안커다란 전체 업무를 여러 팀에 나눠서 맡기되, 각 팀을 외과 수술 팀처럼 조직할 것의 제안이다. 즉, 모든 팀원이 다 같이 문제에 달려드는 것이 아니라, 한 명이 문제를 해결해 가는 동안 다른 이들은 그 사람이 효율과 생산성을 높일 수 있도록 여러 방면에서 지원해 주는 것이다.이는 사실 현재로썬 당연한데(이 책은 1975년에 1판, 1995년에 2판이 나왔다), 설계와 구축에는 적은 수의 사람이 개입하면서, 작업에는 여러 사람이 개입한다. 외과의: 수석 프로그래머.이 사람은 기능과 성능 명세를 직접 정의하며, 프로그램을 설계/코딩/테스트/문서화 한다. 그리고 전체 시스템에 실질적인 접속 권한을 가지고 있으며, 뛰어난 재능과 10년 이상의 경력, 시스템 및 응용 분야에 관한 상당 수준의 지식이 요구된다. 그 분야는 응용 수학이나 비즈니스 데이터 처리 등 무엇이나 될 수 있다. 부조종사: 외과의의 분신.업무의 어떤 부분이든 수행 가능하지만 경험은 많지 않으며, 주된 역할은 설계 과정에 참여하여 같이 고민-토론-평가 하는 것이다. 외과의가 부조종사와 여러 아이디어를 시도할 수는 있지만, 부조종사의 의견에 구애받지는 않는다. 모든 코드를 상세하게 알고 있고, 대안적인 설계에 대한 전략을 연구하며 종종 팀을 대표한다. 행정 담당:외과의는 인사, 임금 등의 최종 결정권이 있지만 이 부분에 시간을 할애해서는 안된다. 그러므로 돈, 사람, 공간, 장비를 관장하고 다른 부서의 행정 파트와 소통을 맡아줄 전문적인 행정 담당이 필요하다. 어떤 프로젝트에 법률적 계약적 중대 사안이 있거나, 보고를 강화해야하거나, 재무적 이슈가 있지 않다면 보통 한 명의 행정 담당이 두 팀을 맡을 수 있다. 편집자: 문서 생산은 최대한의 명확성을 위해 외과의가 직접 작성해야 한다. 외부/내부 문서에 동일하게 적용되지만, 외과의가 작성한 초안/구술 원고를 읽은 후에 그것을 비평/재작업/레퍼런스 보충/버전 관리/문서 생산 관리는 편집자가 담당해야 한다. 두 명의 비서:행정 담당과 편집자는 비서가 한 명씩 필요하며, 행정 비서는 프로젝트 관련 우편물/일반적인 업무 서류를 관리한다. 프로그램 사무원:이 사람은 팀에서 생산되는 모든 기술적인 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 컴퓨터에서 작업이 실행되는 전 과정을 팀의 멤버 누구나 볼 수 있게 하고, 프로그래밍이라는 작업을 “개인적인 예술에서 공개적인 실행으로” 바꾼다. 이 작업은 현대에서는 소스 컨트롤과 CI/CD라는 작업이 도맡아서 한다. 도구 담당:여러 편집기, 서비스 중 확실히 신뢰할 수 있고 팀에 적합한 도구를 찾고, 이들을 구축-유지-업그레이드 하는 책임을 받는다. 종종 특화된 유틸리티/목록으로 정리된 프로시저/매크로 라이브러리 등을 구축하기도 한다. 테스터:테스트 케이서를 만들고, 테스트 순서를 계획하고, 구성 요소 테스트를 위한 Scaffolding을 짠다. 이는 현대에 들어서 TDD(테스트 주도 개발) 과 같은 형태로 바뀌어 모든 프로그래머가 테스트를 작성하게 하기도 한다. 언어 전문가책에서는 특정 언어를 마스터한 사람을 일컫지만, 알고리즘 전문가 또한 이곳에 포함될 수 있다고 생각한다. 즉, 특정 언어나 기술의 수학적이고 복잡한 부분을 잘 다루는 사람을 뜻한다. 대개 2명~3명의 외과의를 도울 수 있다. 한가지 경고할 점은, 이는 1975년도에 쓰여진 책이고 지금은 이런 내용들이 당연시 여겨지고 있으며 몇몇은 시대를 많이 지났다는 것이다. 하지만 그렇기에 교과서적인 기초와 개발체제의 탄생 배경을 알 수 있기에 참고해볼 만한 가치가 있다. 명세서잘 짜여진 명세서는 [완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성] 이 있어야 한다. 완전성completeness사용자의 모든 요구 사항이 누락되지 않고 완전하게 반영되었는가? 일관성consistency요구 사항이 서로 모순/충돌되는 점은 없고, 산출물이나 요구사항의 내용이 일관성을 유지하는가? 명확성unambiguity서술된 명세서의 내용이 애매하지 않고 모든 참여자가 명확히 이해 가능한가? 기능성functionality서술된 명세서의 내용이 ‘어떻게’보다 ‘무엇을’에 관점을 두고 서술되었는가? 검증 가능성verifiability서술된 명세서의 내용이 사용자의 요구를 만족하는지 검증할 수 있는가? 추적 가능성traceability사용자 요구 분석 명세서와 설계 사양서를 추적할 수 있는가? 변경 용이성easily changeable요구 분석 명세서의 내용을 변경하고자 할 때 쉽게 찾아 변경할 수 있는가? AWS EC2 서버 구축하기운영 서버란?개발이나 테스트 목적이 아닌, 실제 사용자들을 대상으로 서비스하는 서버를 말합니다. 테스트 할 때와는 다르게 트래픽 대응과 빠른 응답속도, 그리고 높은 가용성을 고려해야 합니다.운영 서버 관리법은 크게 ‘환경 구성’, ‘코드 배포’, ‘모니터링’의 세 단계로 나뉩니다. ‘환경 구성’은 서비스할 코드를 구동시킬 수 있는 서버 인프라를 구축하는 것이고, ‘코드 배포’는 구성한 환경에 최신 버전의 코드를 빠르고 안전하게 배포하는 것이고, 마지막으로 ‘모니터링’은 안정적인 서비스 운영을 위해 서버와 코드에 어떤 이상이 없는지 바로 파악하고 대응할 수 있게 도와주는 것입니다.AWS(Amazon Web Services) 란?미국의 대형 인터넷 쇼핑몰인 아마존(Amazon)에서 자사를 위해 개발하였던 인프라 시스템인데, 이 기술을 2006년에 공개하며 서비스하기 시작해서 만들어졌습니다. 컴퓨팅 서버를 클라우드로 제공하여서 원래는 물리적인 기계를 구매하여 배치하고, 구축하고, 작동해야 했기 때문에 전문 인력들이 필요했고, 서버의 상태가 어떻게 될 지 확실하지 않기 때문에 필요 이상의 규모를 구축해야 하지만, AWS와 같은 클라우드 서비스를 이용하면 몇번의 클릭만으로 가용량을 조정할 수 있습니다. 그래서 비용, 시간, 인력적인 면에서 많은 비용 절감이 가능하게 되죠.AWS EC2 인스턴스 생성하기EC2(Elastic Compute Cloud)는 사양을 고르고 원하는 시간만큼 사용 가능한 가상 서버입니다. 필요할 때마다 키거나 끌 수 있고, 사용한 시간에 대해서만 비용을 지급합니다. 시작하기 전에, 알아야 할 세 가지 개념을 알려드리겠습니다. AMI(Amazon Machine Image)EC2 인스턴스의 기반이 되는 이미지입니다. 운영체제를 설치하기 위해 CD나 ISO 파일을 만드는 것과 같은 원리입니다. 이것을 이용하여 원하는 운영체제, 환경이 구성된 서버를 설치할 수 있습니다. 즉, 자신이나 타인이 구성한 서버 환경을 이미지 파일로 만들어서 재사용할 수 있습니다. 보안 그룹(Security Group)보안을 위해 IP와 포트 번호를 이용해 정의하는 서버 접속 규칙입니다. 키 페어(Key pair)서버에 접속하기 위한 보안키입니다. 서버에는 공개 키(public key)를 두고 사용자는 개인 키(private key)를 들고 접속하게 됩니다. AWS에 로그인하고, AWS 콘솔에 접속하고 서버의 위치를 서울로 설정합니다. 왼쪽 위의 서비스를 눌러 펼치고, EC2를 선택합니다. 왼쪽 [인스턴스] 카테고리의 [인스턴스] 를 선택하고 [인스턴스 시작] 버튼을 클릭합니다. Amazon Linux 2를 선택합니다. CentOS 기반으로 AWS에 적합하게 튜닝한 Linux OS입니다. 프리티어가 사용 가능한 t2.micro를 선택하고, 오른쪽 아래의 [다음: 인스턴스 세부 정보 구성] 을 클릭합니다. 설정은 건드리지 않고 [다음: 스토리지 추가] 를 클릭합니다. 마찬가지로 [다음: 태그 추가] 를 클릭합니다. [다른 태그 추가]를 클릭하고 원하는 키와 값을 입력하고, 다음으로 넘어갑니다. [새 보안 그룹 생성] 을 누른 후 이름과 설명을 지정합니다. 그리고 소스 부분에 드롭다운 메뉴에서 [내 IP] 를 선택합니다. 보통은 회사의 IP를 이용합니다. [검토 및 시작] 을 누르고 [시작] 을 누릅니다. 그 후 [새 키 페어 생성] 을 선택하고 이름을 적고, 키 페어를 다운로드합니다. 이 파일을 이용해야 서버에 접속할 수 있기 때문에 분실되거나 유출되어서는 안됩니다. 전부 다 끝났다면 [인스턴스 시작] 을 누르면 완료입니다. [인스턴스 보기] 를 누르면 인스턴스 상태가 보이고, “실행 중” 이 될 때까지 기다립니다. EC2는 서버가 켜져있는 만큼 비용이 지불되므로, 사용하지 않을때는 꼭 [중지] 합니다. 이는 잠깐 꺼두는 명령이고, [종료] 는 인스턴스를 삭제하는 명령입니다. 단, 서버의 디스크를 점유하고 있기 때문에 해당 사항에 대한 사용료는 지불됩니다.이제 생성된 인스턴스에 접속하기 위해서는 SSH를 사용해야 하는데, 윈도우에서는 주로 PuTTY를 이용해서 접속하고 macOS나 Linux는 ssh 명령어로 접속합니다.인스턴스 ID를 클릭하면 세부 정보를 확인할 수 있는데, 여기서 퍼블릭 도메인과 IP는 별도의 설정을 하지 않으면 인스턴스가 꺼질 때 사라지고 켜질 때마다 새로 할당받습니다.윈도우에서 PuTTY로 SSH 접속하기이 링크 에서 사용중인 운영체제에 해당하는 파일을 다운로드합니다.PuTTY로 키 파일인 .pem 파일을 바로 사용할 수 없기 때문에 “PuTTY Key Generator”를 이용해서 변환해주어야합니다. “puttygen.exe” 이라는 이름이고, 실행 후 [Load] 를 눌러 .pem 파일을 찾아(안보인다면 확장자 선택을 [All Files (.)] 으로)서 선택합니다. Parameters에서 RSA를 선택하고 Actions에서 Save private key를 선택합니다. 참고로, 여기서 Key passphrase: 와 그 밑의 Confirm passphrase: 는 선택 사항이지만 키가 유출된 경우 비밀번호로 한번 더 보호하는 기능을 합니다.이제 “putty.exe” 를 실행하고, 카테고리에서 Session을 선택한 후에 “Host Name”에 [ec2-user@&amp;lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&amp;gt;] 를 입력하고, Connection type는 SSH, 포트는 22(SSH의 포트)를 입력합니다. 그리고 왼쪽의 카테고리에서 Connection -&amp;gt; SSH -&amp;gt; Auth 메뉴에서 “Private key file for authentication” 에 아까 변환한 .ppk 파일을 지정하고, 아래의 [Open] 버튼을 누릅니다. 서버의 fingerprint를 레지스트에 키로 등록하겠냐는 경고창이 나오면 [예]를 클릭합니다.참고) Session 카테고리에서 현재 세션의 정보를 Save해서 더블클릭으로 빠르게 접속할 수 있습니다.macOS/Linux에서 SSH 접속하기터미널을 실행하고, 다운로드한 키 페어 파일의 권한을 변경합니다.chmod 400 /path/to/&amp;lt;이름&amp;gt;.pemSSH의 접속하기 위해 명령어를 입력합니다.ssh -i /path/to/&amp;lt;이름&amp;gt;.pem ec2-user@&amp;lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&amp;gt;서버의 fingerprint 값과 함께 접속을 계속하겠냐는 메시지가 나오면 ‘yes’ 를 입력합니다.위의 모든 과정을 따라하셨다면 EC2 인스턴스의 생성과 접속까지 끝났습니다! AWS를 사용해서 웹 서버, 게임 서버 등 원하는 서버를 쉽고 간편하게 구축해 보세요. 투자시장의 흐름이나 추세에 따라 거래하는 사람들은 단기간에 수익을 내기 위해 주가의 단기 변동을 예상하려고 노력한다. 하지만 이런 방법으로 수익을 낼 수 있는 사람은 거의 없고, 어느 누구도 아직까지 완벽한 방법을 개발하지 못했다.시장의 추세를 찾으려고 노력하면 주가가 바닥을 치고 올라가는 시점에서 주식을 팔고 주가가 상승했다가 하락하는 시점에서 주식을 시작하는, 거꾸로 된 투자를 하게 된다 사람들은 자신이 운이 없기 때문에 이런 일이 생긴다고 생각하지만, 사실은 불가능한 일을 하려고 하기 때문이다.사람들은 또한 폭락이나 조정을 받을 때 주식에 투자하는 것은 위험하다고 생각하는데, 이 시기에 주식을 파는 것이 위험한 행동이다. 이들은 주가가 가파르게 상승하는 얼마 안 되는 짧은 시간에 주식에 투자할 수 있는 기회를 놓치는 위험을 안고 있는 것이다.주식을 살 때는 해당 기업이 많은 고객을 보유하고 앞으로도 늘어나는지를 보아야 한다. 그러니까, 해당 기업이 좋은 제품을 만드는지를 보아야 한다. 하지만 그 외에도, 자금을 현명하게 사용하는지, 부채의 규모는 어떤지, 매출이 어떤 속도로 증가/감소하고 있는지, 과거와 미래의 수익은 얼마인지, 주식이 어떤 가격에 팔리는지, 배당금은 어느정도인지도 보아야 한다. 수익, 매출, 부채, 배당금은 주식 종목을 선택하는 데 가장 중요한 숫자이다. TDD(테스트주도개발)의 3가지 법칙 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 조합 탐색combinatorial search동적 계획법과 그리디 기법은 한계가 있기 때문에 결국 완전 탐색으로 풀어야 할 때가 오는데, 이 때 완전 탐색을 최적화하기 위해 완전 탐색을 포함하여 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 “조합 탐색” 이라고 부른다. 이 조합 탐색들은 기본적으로 최적해가 될 가능성이 없는 답의 수를 줄이는 것을 목표로 하고, 이것을 위한 최적화 기법들이 여러가지 있다. 가지치기pruning탐색 과정에서 최적해로 연결될 가능성이 없는 부분을 잘라낸다. 예를 들어, 탐색들의 최적해를 기억해두고 있을 때 현재 상태의 최적해가 지금까지 구해놓은 최적해보다 좋지 않다면 이 탐색은 더이상 진행하지 않아도 좋다.휴리스틱heuristic 기준점과 조정 휴리스틱자신이 알고 있는 수치로 임의의 기준선을 설정한 후, 적절하다고 생각하는 것에 맞게 결정하는것. 가용성 휴리스틱사건의 가능성을 기억의 가용성에 근거해 추정하는 것. 즉, 기억에서 잘 떠오르는 대상에 대해 상대적으로 높은 평가를 내리는 것 대표성 휴리스틱어떤 집합에 속하는 임의의 한 특징이 그 집합의 특성을 대표한다고 간주해 빈도와 확률을 판단하는 방법 감정 휴리스틱어떤 사건이나 상황에 대해 판단을 할 경우 경험으로 형성된 감정에 따라 평가를 다르게 하는 것 메타 휴리스틱발견법은 해결하려는 문제마다 각기의 특성에 맞추어 개발해야 하는데, 특정 문제가 갖는 정보에 크게 구속되지 않고 다양한 문제들에 적용가능한 상위수준의 발견적 기법이다. 유전 알고리즘, 담금질 기법, 타부 서치가 있다. 드로잉“캐릭터”를 그린다는 것은 무언가 인물을 그리는 것이 아니라 실제로 의미 그대로 “어떤 성격”을 시각적으로 표현함을 의미한다. 사람의 성격은 너무 복잡하기 때문에 우리 인간은 대상을 관념화해서 “쟤는 소심한 애야, 과격한 애야, 나쁜 애야”라고 단순하게 생각하는데, 이를 그림으로 나타낸 것이 바로 캐릭터이다. 이 캐릭터의 성장기부터 하는 행동을 다 설명할 순 없으니 직관적으로 알아볼 수 있도록 만들어야 하는 것이다.그림을 그릴땐 모사(모작)부터 시작해야 하는데, 그 이유는 자신의 눈 앞에 있는것도 그릴 수 없는데 자신의 머리속에 있는 것은 그릴 수 없기 때문이다. 모사를 할 때의 방법은 수직/수평선어딘가에 수직/수평선을 그리면 그곳을 기준으로 어디가 더 들어갔는지, 나와있는지, 비율과 대략적인 위치를 더 정확히 가늠할 수 있기 때문에 유용하게 사용될 수 있다. 가끔 창작물에 나오는 화가가 연필을 세로나 가로로 세워서 보는 것이 이것을 하는 작업이다. 격자어떤 하나의 큰 그림을 그린다고 할때 이 그림은 한번에 그리는 것이 거의 불가능하니 격자로 부분을 나눠서 부분들을 그리다 보면 전체가 완성되는 것이다. 그래서 모사할 대상과 그릴 그림을 실제로 선으로 된 격자로 나눠 부분을 그리면 더 정확하게 그릴 수 있다. 실루엣안쪽이 아닌 바깥쪽을 보는 것, 무엇의 윤곽을 보는 것이다. 그러니 그리려는 대상의 전경을 그리는 것이 전체적인 틀을 잡기 더 쉬워진다. 변상증인간은 의미없는 것에 의미를 부여하기를 좋아한다. 왜냐면 알수 없는 개체가 나타났을 때 우리는 위협에 대비해야 하기 때문이다. 이를 응용하여 그림을 그릴때 부분들이 “무언가를 닮았다” 라고 생각하여 그리다 보면 이 부분들이 모여 하나의 완성된 그림이 된다.그림을 그릴 때, 특히 사람과 같은 복잡한 것을 그릴때는 그것에 대해 이미 가지고 있는 지식때문에 그림을 그리기가 힘든데, 그래서 대상을 대상으로 바라보지 않는, 그저 빛과 어둠(검고 흰것)으로 이루어진 도형이라고 인식하는 연습이 필요하다.위의 4가지 방법은 익숙해지면 실제로 수직/수평선을 그리거나 하지 않아도 자연스럽게 머리속에서 그려지게 된다.참고로 요약자의 경우 1년정도 취미로 모작을 했었는데, 단순 취미의 영역이라면 많이 하면 이 부분은 자연스럽게 가능해질 것이라 생각한다." }, { "title": "알고리즘 패러다임", "url": "/posts/algorithmic-paradigm/", "categories": "Lecture, Basic", "tags": "Essence", "date": "2022-04-02 00:00:00 +0900", "snippet": "알고리즘 패러다임알고리즘 패러다임(Algorithmic Paradigm) 혹은 알고리즘 디자인 패러다임은 자주 등장하는 알고리즘 접근법을 의미하며, 여러 문제에 통상적으로 사용될 수 있습니다. 이 게시글을 이해하기 위해서는 일반적인 자료구조와 재귀함수를 응용할 수 있어야 함을 알립니다.완전탐색브루트 포스(Brute Force) 알고리즘이며, 모든 경우의 수를 전부 탐색하는 것을 의미합니다.백트래킹분할 정복문제를 간단히 풀 수 있을 때까지 계속 분할하고, 분할된 문제의 해답을 찾아 그 해답을 합쳐서 문제를 해결하는 방식입니다. 다음과 같은 세가지 단계로 나뉠 수 있는데, 분할(divide) : 문제를 같은 방식으로 해결할 수 있는 부분 문제로 나눈다 정복(conquer) : 각 부분 문제의 해답을 구한다 결합(combine) : 정복한 결과를 결합하여 전체 문제의 해답을 구한다이진 검색 또한 분할 정복에 해당되기는 하지만, 이진 검색의 경우 특이한 케이스로 부분 문제의 해답이 그대로 전체 문제의 해답(값을 찾는다)이 되기 때문에 결합 단계가 필요하지 않습니다.분할 정복의 예시로 “병합 정렬” 을 들 수 있는데, 배열의 크기가 충분히 작아질 때까지 같은 크기인 2개의 부분배열로 분할 하고 부분 배열을 정렬하여 정복 하고 정렬된 배열들을 하나로 병합함으로써 결합 합니다. 병합 정렬에서는 결합과 동시에 정렬하기 때문에 정복과 결합이 동시에 이루어진다고 볼 수 있습니다.그리디 알고리즘선택의 순간마다 현재로서의 최적인 해답만을 구해나가는 알고리즘 패러다임입니다. 예를 들어 서울에서 인천까지 간다고 할 때, 각 교차로마다 가장 가까운 경로를 선택하는 걸 생각할 수도 있습니다. 이 경우, 완벽한 최단 경로는 아니지만 최단 경로에 근접한 값을 얻을 수 있죠. 알고리즘 풀이에서도 비슷하게 사용되는데, 보통 그리디 기법을 사용한 부분 문제의 최적해가 전체 문제의 최적해와 같은 문제들이 많이 존재하고, 어려운 문제의 경우 우선 그리디로 최적해 후보들을 구한 후에 정확한 답을 구하는 방법을 사용하기도 합니다.좀 더 구체적인 예를 들자면, 만약 은행이 있고 번호표를 뽑은 사람들과 그 사람마다의 일처리 시간이 존재할 때 대기시간을 최소로 한다면 그냥 일처리 시간이 제일 짧은 사람부터 먼저 처리하는 방법을 생각할 수 있죠.그리디 알고리즘을 사용하기 위해 필요한 조건으로는 “최적 부분 구조 속성” 과 “그리디 선택 속성” 이 존재합니다. 이 조건을 만족하지 못하면 완전한 최적해는 구할 수 없습니다. 최적 부분 구조(Optimal Substructure): 주어진 문제 P에 대한 최적의 솔루션이 P의 부분 문제들의 최적의 솔루션으로 구성되어야 한다 그리디 선택(Greedy Choice): 주어진 문제 P에 대한 지역적 최적 솔루션을 반복적으로 선택하여 전체 최적 솔루션을 구할 수 있어야 한다그리디의 예제로는 크루스칼의 최소 신장 트리를 들 수 있습니다.동적계획법동적 계획법은 주로 재귀적이고, 반복적인 문제를 해결하는 경우에 사용됩니다. 간단하게 요약하면 이미 한번 계산한 문제의 답을 저장(캐시, cache)해 두고, 다음에 같은 문제를 해결해야 할 때 저장해 둔 문제의 답을 사용하는 방식으로 사용됩니다.가장 간단한 예시로 피보나치 수열이 존재합니다. 피보나치 수열은 {0, 1, 1, 2, 3, 5, 8, 13, 21, ...} 과 같은 수열로, 규칙을 찾아보면 i번째 피보나치 수는 i-1번째 피보나치 수 + i-2번째 피보나치 수라는 F[i] = F[i-1] + F[i-2] 재귀적인 규칙, 즉 재귀 관계(Recurrence Relation) 을 가지고 있는 것을 알 수 있습니다. 여기서 F[0] = 0과 F[1] = 1 은 기저 조건(base case) 으로, 재귀가 존재하지 않아도 해를 구할 수 있는, 재귀가 종료되는 지점입니다.int Fib(int n){ if (n &amp;lt; 2) return n; return Fib(n - 1) + Fib(n - 2);}위 코드는 재귀함수로 피보나치를 표현한 것입니다. 재귀 함수를 사용한 경우를 하향식(Top-down) 이라고 하는데, 함수 호출을 트리로 표현한 경우 맨 꼭대기부터 기저 조건까지 아래쪽으로 이동하기 때문입니다.flowchart TD F5[&quot;Fib(5)&quot;] --&amp;gt; F4[&quot;Fib(4)&quot;] &amp;amp; F31[&quot;Fib(3)&quot;] F4 --&amp;gt; F32[&quot;Fib(3)&quot;] &amp;amp; F21[&quot;Fib(2)&quot;] F23 --&amp;gt; F14[&quot;Fib(1)&quot;] &amp;amp; F02[&quot;Fib(0)&quot;] F31 --&amp;gt; F22[&quot;Fib(2)&quot;] &amp;amp; F11[&quot;Fib(1)&quot;] F21 --&amp;gt; F13[&quot;Fib(1)&quot;] &amp;amp; F01[&quot;Fib(0)&quot;] F32 --&amp;gt; F23[&quot;Fib(2)&quot;] &amp;amp; F12[&quot;Fib(1)&quot;] F22 --&amp;gt; F15[&quot;Fib(1)&quot;] &amp;amp; F03[&quot;Fib(0)&quot;]동적 계획법은 위와 같이 문제가 여러개의 부분 문제/중간 문제로 분할되어 풀어져야 하고, 이 부분 문제들이 한 번 이상 반복해 나타난다는 중복되는 부분 문제(Overlapping Subproblem) 특성을 가지고 있습니다. 분할 정복과의 차이가 바로 이 점인데, 분할 정복에서는 각 부분문제가 서로 독립적이지만 동적 계획법에서는 같은 부분 문제를 반복해서 풀어야 합니다.또한 여러 부분 문제가 서로 완전히 동일하다는 것을 알 수 있는데, F[2] 를 구해야 할 때 이게 F[3] 에서 필요하던 F[2] 에서 필요하던 상관없이 같은 연산을 하기 때문입니다. 이를 최적 부분 구조(Optimal Substructure) 특성이라고 하며, 전체 문제에 대한 최적해가 부분 문제의 최적해의 조합으로 표현됨을 뜻합니다.동적 계획법으로 문제를 해결하기 위해선 위 2개의 특성이 만족되어야 하며, 각 부분 문제의 해를 기억해야 하기 때문에 입력의 수에 따라 공간복잡도가 증가하지만, 그만큼 시간복잡도를 낮출 수 있는 기법입니다.메모이제이션, 하향식(Top-down)메모이제이션(Memoization) 혹은 하향식이라는 기법은 처음에 설명한 것 그대로 “부분 문제의 해답을 찾으면 이를 저장(캐시, cache)해 둔다” 를 구현한 방법입니다. 재귀 함수를 이용한 하향식 풀이일 경우에 사용된 동적 계획법이 이에 해당합니다.int memo[100];int Fib(int n){ if (n &amp;lt; 2) return n; if (memo[n] != 0) return memo[n]; // C++에서 대입 연산자(=) 는 대입된 값, 즉 memo[n]을 반환합니다 return memo[n] = Fib(n - 1) + Fib(n - 2);}입력값 n 이 부분 문제를 결정하기 때문에 만약 입력값 n 에 대한 값이 이미 저장되어 있다면 저장된 값을 반환하고, 값이 저장되어 있지 않다면 계산하고, 저장해 줍니다. 메모이제이션으로 문제를 해결하고 싶을 때는 캐시에 인덱싱하는 방법이 유효하고, 유용해야 합니다. 이 문제의 경우는 n만이 현재 문제 단계의 상태(state) 를 나타내는데, 문제가 복잡해질 경우 상태를 결정하는 요인이 더 많아질 수 있습니다.또한, 재귀 호출이 너무 깊어질 경우 스택 오버플로(Stack Overflow) 가 발생할 수 있으며 이 경우는 메모이제이션을 사용할 수 없기 때문에 조심해야 합니다.타뷸레이션, 상향식(Bottom-up)타뷸레이션(Tabulation) 혹은 상향식이라는 기법은 메모이제이션의 반대 방법입니다. 메모이제이션은 문제를 계산했을 때 그 결과를 저장하지만, 타뷸레이션은 기저 조건부터 시작해 모든 부분 문제의 답을 저장하여 재사용하는 방법입니다. 그러니까, 이전에 구했던 최적해를 이용해서 다음 최적해를 구합니다.int Fib(int n) { int memo[100]; memo[0] = 0; memo[1] = 1; for (int i = 2; i &amp;lt;= n; i++) memo[i] = memo[i - 1] + memo[i - 2]; return memo[n];}타뷸레이션 풀이는 주로 i번째 해를 구하기 위한 점화식 을 만들어서 풀이하게 됩니다. 피보나치 수열의 경우 i번째 피보나치 수는 i-1번째 피보나치 수 + i-2번째 피보나치 수라는 F[i] = F[i-1] + F[i-2] 규칙을 그대로 사용한 것이 되죠. 하지만 보통 이 점화식을 직접 찾아내야 하며, 상태가 다차원이 되거나 상태 전환에 여러 조건식이 필요해 까다로운 방식입니다. 하지만 타뷸레이션은 메모리를 매우 효율적으로 사용할 수 있는데, 위 문제의 경우 다음 값을 구하기 위해 그 전과 전전번째 값만 필요하기 때문에 3가지 상태만 기억해두면 됩니다.int Fib(int n) { int a, b, c; a = 0; b = 1; for (int i = 0; i &amp;lt; n; i++) { c = a + b; a = b; b = c; } return a;}보통 메모이제이션으로 풀 수 있는 문제는 타뷸레이션으로도 풀 수 있으며, 타뷸레이션은 한번에 짜내기가 어렵기 때문에 우선 메모이제이션으로 풀이한 뒤 타뷸레이션으로 바꾸는 것도 가능합니다.동적 계획법 역추적스위핑" }, { "title": "[BOJ] 2481 해밍 경로", "url": "/posts/BOJ-2481/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2022-03-21 19:23:00 +0900", "snippet": "KOI 2010 M3이 문제를 풀기 위해서는 각 이진수들끼리의 서로 다른 비트의 개수를 구한 다음, 해밍 경로가 되는 이진수끼리 연결한 그래프를 만들어 BFS를 이용해 1번 이진수까지의 경로를 구해야 합니다. 입력 처리#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int main() { int N, K; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K; map&amp;lt;int, int&amp;gt; check; vector&amp;lt;int&amp;gt; v(N); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(N); string s; for (int i = 0; i &amp;lt; N; i++) { cin &amp;gt;&amp;gt; s; for (int j = 0; j &amp;lt; K; j++) v[i] = (v[i] &amp;lt;&amp;lt; 1) + s[j] - &#39;0&#39;; check[v[i]] = i; } for (int i = 0; i &amp;lt; N; i++) { for (int j = 0; j &amp;lt; K; j++) { int tmp = v[i] ^ (1 &amp;lt;&amp;lt; j); if (check.find(tmp) != check.end()) graph[i].push_back(check[tmp]); } }}문자열로 입력을 받는데, 만약 문자열로 모든 이진수끼리의 각 비트를 비교하는 작업을 하면 O(N^2*K) 의 시간이 걸리게 될겁니다.이 시간을 단축하기 위해 문자열을 실제 이진수 숫자로 변환해 주는데, 변환될 문자열의 가장 왼쪽 문자(비트) 부터 시작해서 저장될 변수의 비트를 왼쪽으로 한번 쉬프트(«) 하고, 문자를 숫자로 변환하여 더해주면 됩니다.그 후에 이진수들끼리 XOR연산을 하면 해밍경로를 쉽게 구할 수 있을거라 생각할 수 있지만, 이 또한 O(N^2) 의 시간이 걸리기 때문에 대신 해시 테이블 자료구조인 map 을 사용해서 이진수마다 각 비트를 반전해 보며 해당하는 비트와 같은 이진수가 존재하는지를 확인해줍니다. “비트가 하나만 다른 것” 이 해밍 경로이기 때문이죠. X이라는 이진수의 i번째 비트를 반전하기 위해서는 X ^ (1 &amp;lt;&amp;lt; i) 라는 식을 사용합니다.그리고 만약 경로가 존재한다면 그래프 상에서 연결해줍니다. 여기서 map에 현재 이진수가 몇번째 이진수인지 기억해놓았기 때문에 그를 이용합니다. 구현vector&amp;lt;int&amp;gt; path(N, -1);queue&amp;lt;int&amp;gt; q;q.push(0);path[0] = 0;while (!q.empty()) { int next = q.front(); q.pop(); for (int val : graph[next]) { if (path[val] == -1) { path[val] = next; q.push(val); } }}BFS를 구현해서 경로를 미리 계산해 놓는데, 어떤 경로를 통해 이동하였는지를 알아야 하기 때문에 val번째 이진수로 넘어온 next번째 이진수 를 기억해 두어 이후에 역추적하여 출력합니다. 결과 출력int M, J;cin &amp;gt;&amp;gt; M;for (int i = 0; i &amp;lt; M; i++) { cin &amp;gt;&amp;gt; J; if (path[J - 1] == -1) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl; else { vector&amp;lt;int&amp;gt; res; for (int j = J - 1; j != 0; j = path[j]) res.push_back(j); cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &#39; &#39;; for (auto it = res.rbegin(); it != res.rend(); it++) cout &amp;lt;&amp;lt; *it + 1 &amp;lt;&amp;lt; &#39; &#39;; cout &amp;lt;&amp;lt; endl; }}역추적하는 부분을 잘 이해해보도록 합시다. 여기서, rbegin() 과 rend() 는 역순으로 출력하는 reverse_iterator입니다." }, { "title": "[BOJ] 2461 대표 선수", "url": "/posts/BOJ-2461/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2022-03-21 18:34:00 +0900", "snippet": "KOI 2011 M3우선 시간을 고려하지 않은, 원초적인 풀이방법을 생각해 봅시다. 일단 각 반에서 최솟값인 학생들을 찾은 후에, 해당 학생들로 점수를 계산(최대값 - 최소값)합니다.그 후에, 지금 골랐던 학생들 중 점수가 가장 낮은 학생을 다음 학생으로 교체하는 것이죠. 그런데 이렇게 최솟값을 찾으면 기하급수적인 시간이 소요되기 때문에, 일단 각 반들을 정렬해놓고 푸는 방법을 생각할 수 있습니다.그런데 이제 각 반들을 정렬하고 현재 고른 학생들 중 최솟값을 다음 학생으로 바꾸는 작업 또한 최솟값을 찾아야 하기 때문에 시간초과가 나게 됩니다. 그래서 생각할 수 있는 다음 방법은, 전체 학생들을 정렬하는 것이죠. 입력 처리#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;struct student { int idx, num;};int main() { int N, M; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; vector&amp;lt;student&amp;gt; v(N * M); int len = 0; for (int i = 0; i &amp;lt; N; i++) { for (int j = 0; j &amp;lt; M; j++) { v[len].idx = i + 1; cin &amp;gt;&amp;gt; v[len].num; len++; } } sort(v.begin(), v.end(), [](const student&amp;amp; a, const student&amp;amp; b) { return a.num &amp;lt; b.num; });}우리는 모든 학생들을 정렬해야 하기 때문에 각 학생들이 어느 반에 속해 있었는지를 기억해 놓아야 합니다. pair&amp;lt;int, int&amp;gt; 타입을 사용하면 sort() 에 세 번째 매개변수는 필요하지 않지만, 구조체의 사용 예제를 보여드리기 위해 이용하였습니다. sort() 에 세 번째 매개변수로 주어진 코드는 람다 식 이라고 합니다. 코드 내부에서 임시로 함수를 만든다고 생각하면 되며, student는 제가 정의한 구조체이기 때문에 이와 같이 정렬 조건을 함수로 넘겨주어야 합니다. 구현vector&amp;lt;int&amp;gt; chk(N + 1);pair&amp;lt;int, int&amp;gt; pos{ 0, -1 };int validate = 0, result = 1000000000;do { if (validate &amp;lt; N) { pos.second++; if (chk[v[pos.second].idx]++ == 0) validate++; } else { result = min(result, v[pos.second].num - v[pos.first].num); if (--chk[v[pos.first].idx] == 0) validate--; pos.first++; }} while (pos.second &amp;lt; len - 1);cout &amp;lt;&amp;lt; result;이제 각 반에서 한명씩은 꼭 골라야 하는데, 이를 위해 각 반의 학생들이 최소 1명 이상 등장했는지를 확인해 주어야 합니다. 반마다 현재까지 나온 학생의 수를 기억해 주고, 제일 처음 학생과 현재 반복의 학생의 차를 계산해 줍니다.그리고 첫번째 학생이 속해있던 반의 현재 명수를 1 감소시키고, 만약 이 때 명수가 0이 된 반이 있다면 다시 모든 반에서 1명 이상이 될때까지 다음 학생들을 확인해줍니다. 전체 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;struct student { int idx, num;};int main() { int N, M; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; vector&amp;lt;student&amp;gt; v(N * M); vector&amp;lt;int&amp;gt; chk(N + 1); int len = 0; for (int i = 0; i &amp;lt; N; i++) { for (int j = 0; j &amp;lt; M; j++) { v[len].idx = i + 1; cin &amp;gt;&amp;gt; v[len].num; len++; } } sort(v.begin(), v.end(), [](const student&amp;amp; a, const student&amp;amp; b) { return a.num &amp;lt; b.num; }); pair&amp;lt;int, int&amp;gt; pos{ 0, -1 }; int validate = 0, result = 1000000000; do { if (validate &amp;lt; N) { pos.second++; if (chk[v[pos.second].idx]++ == 0) validate++; } else { result = min(result, v[pos.second].num - v[pos.first].num); if (--chk[v[pos.first].idx] == 0) validate--; pos.first++; } } while (pos.second &amp;lt; len - 1); cout &amp;lt;&amp;lt; result; return 0;}" }, { "title": "[BOJ] 2478 자물쇠", "url": "/posts/BOJ-2478/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2022-03-20 14:28:00 +0900", "snippet": "KOI 2010 E4반례가 많아 짜증나는 문제입니다. 일단 이 문제를 풀기 위해서는 뒤집어진 구간을 알아야 하고 뒤집힌 구간을 다시 뒤집고 1의 위치를 찾아 첫번째 k-왼쪽밀기 구하기를 해야합니다. k-왼쪽밀기는 각각 N으로 초기화 해 두고(N만큼 움직였다는 것은 제자리라는 뜻이기 때문에) 뒤집어진 구간이 어디고, 몇개인 지 알아내야 합니다. 이 때, 1. 에서 뒤집힌 구간이 2개라면 구간 뒤집기 후 두번째 k-왼쪽밀기를 했다는 뜻이기 때문에 이 경우에만 두번째 k-왼쪽밀기를 구하고 뒤집힌 구간이 1개라면 뒤집힌 구간을 뒤집고 1의 위치를 찾아서 k-왼쪽밀기를 구하면 끝이 납니다. 입력 처리#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;int&amp;gt; v(N + 1); vector&amp;lt;bool&amp;gt; check(N + 1); for (int i = 0; i &amp;lt; N; i++) cin &amp;gt;&amp;gt; v[i]; v[N] = v[0]; if ((v[N - 1] - v[0] + N) % N == 1) check[0] = true; for(int i = 0; i &amp;lt; N; i++) if ((v[i] - v[i + 1] + N) % N == 1) check[i] = check[i + 1] = true; check[N] = false;}입력을 받고, 뒤집혀진 구간을 찾아내기 위해 “숫자가 올바른 순서가 아니라면” true 라고 체크해줍니다. 여기서 (v[i] - v[i + 1] + N) % N == 1 이라는 식이 사용되었는데, 내림차순인지 검증해주기 위해 사용됩니다. {1, N} 의 경우도 확인할 수 있도록 이런 식이 완성되었는데, 정방향과 역방향에 대해 한번 직접 값의 변화를 생각하여 봅시다. 뒤집힌 구간 (p, q) 찾기int pq[4] = {}, idx = 0;bool prev = false;for (int i = 0; i &amp;lt;= N; i++) { if (prev != check[i]) { prev = check[i]; pq[idx++] = i; }}check 배열을 돌며, false에서 true 혹은 true에서 false로 바뀌는 순간을 “뒤집혀진 구간” 으로 처리합니다. 두번째 k-왼쪽밀기 역행int k1 = N, k2 = N;if (idx == 4){ vector&amp;lt;int&amp;gt; tmp(N + 1); k2 = pq[3] - pq[2]; pq[0] = 0; pq[1] += k2; for (int i = 0; i &amp;lt; N; i++) tmp[i] = v[(pq[2] + i) % N]; v = tmp;}만약 idx가 4, 즉 뒤집힌 구간이 2개라면 두번째 뒤집어진 구간을 오른쪽 으로 밀어줍니다. 또한, 뒤집어진 구간의 위치를 밀린만큼 수정합니다. 여기서 k-왼쪽밀기의 기본값은 N이어야 하는데, N번 밀면 제자리이기 때문에 k-왼쪽밀기를 해주지 않은 것처럼 됩니다. (p, q) 다시 뒤집기for (int i = pq[0]; i &amp;lt; (pq[0] + pq[1]) / 2; i++) { int tmp = v[i]; v[i] = v[pq[1] + pq[0] - i - 1]; v[pq[1] + pq[0] - i - 1] = tmp;}for (int i = 0; i &amp;lt; N; i++) if (v[i] == 1) k1 = N - i;p, q의 구간을 다시 뒤집으면 마지막으로 첫번째 k-왼쪽밀기의 위치를 1의 위치를 통해 찾아줍니다. 정답 출력cout &amp;lt;&amp;lt; k1 &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; pq[0] + 1 &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; pq[1] &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; k2;그 후 구한 결과를 출력하면 끝입니다. 전체 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;int&amp;gt; v(N + 1); vector&amp;lt;bool&amp;gt; check(N + 1); for (int i = 0; i &amp;lt; N; i++) cin &amp;gt;&amp;gt; v[i]; v[N] = v[0]; if ((v[N - 1] - v[0] + N) % N == 1) check[0] = true; for(int i = 0; i &amp;lt; N; i++) if ((v[i] - v[i + 1] + N) % N == 1) check[i] = check[i + 1] = true; check[N] = false; int pq[4] = {}, idx = 0; bool prev = false; for (int i = 0; i &amp;lt;= N; i++) { if (prev != check[i]) { prev = check[i]; pq[idx++] = i; } } int k1 = N, k2 = N; if (idx == 4){ vector&amp;lt;int&amp;gt; tmp(N + 1); k2 = pq[3] - pq[2]; pq[0] = 0; pq[1] += k2; for (int i = 0; i &amp;lt; N; i++) tmp[i] = v[(pq[2] + i) % N]; v = tmp; } for (int i = pq[0]; i &amp;lt; (pq[0] + pq[1]) / 2; i++) { int tmp = v[i]; v[i] = v[pq[1] + pq[0] - i - 1]; v[pq[1] + pq[0] - i - 1] = tmp; } for (int i = 0; i &amp;lt; N; i++) if (v[i] == 1) k1 = N - i; cout &amp;lt;&amp;lt; k1 &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; pq[0] + 1 &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; pq[1] &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; k2; return 0;}" }, { "title": "[BOJ] 2457 공주님의 정원", "url": "/posts/BOJ-2457/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2022-03-10 17:28:00 +0900", "snippet": "KOI 2011 E3/M2공주님의 정원은 그리디 방식으로 풀이할 수 있는 문제입니다. 내가 현재 고를 수 있는 꽃 중에서 끝나는 날짜가 가장 긴 꽃을 고르면 답을 구할 수 있습니다. 여기서 “내가 현재 고를 수 있는 꽃” 이란 이전에 골랐던 꽃의 끝나는 날짜보다 시작하는 날짜가 더 앞에 있는 꽃들을 의미합니다. 입력 처리#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v(N); int sm, sd, em, ed; for (int i = 0; i &amp;lt; N; i++) { cin &amp;gt;&amp;gt; sm &amp;gt;&amp;gt; sd &amp;gt;&amp;gt; em &amp;gt;&amp;gt; ed; v[i].first = sm * 100 + sd; v[i].second = em * 100 + ed; } sort(v.begin(), v.end());}우선, {시작월, 시작일, 종료월, 종료일} 을 입력 받습니다. 물론 이 4가지를 구조체로 만들어서 그대로 기억해도 되지만, 날짜의 비교를 원활하게 하기 위해 월 * 100 + 일 의 형태로 월일을 하나의 숫자로 압축하였습니다. 그 이유는, 나중에 날짜의 비교를 할 때 s1.month &amp;lt; s2.month || s1.month == s2.month &amp;amp;&amp;amp; s1.day &amp;lt; s2.day 와 같이 월이 같은 경우와 다른 경우를 따로 봐주어야 하는데, 이렇게 숫자로 변경하면 숫자의 대소비교 한번만으로 끝나기 때문입니다. pair&amp;lt;int, int&amp;gt; 는 구조체인데, first 와 second 를 멤버 변수로 지니고 있습니다. &amp;lt;int, int&amp;gt;는 first와 second의 타입을 의미합니다.구조체를 따로 만들지 않고 기본으로 제공하는 pair&amp;lt;&amp;gt;를 사용하였습니다. 그 후, 우리는 시작일을 기준으로 정렬해줍니다. 왜냐하면, 시작일이 순서대로 나열되어 있으면 내가 다음으로 골라야하는 꽃을 찾을 필요가 없기 때문이죠. sort() 는 에 속해있는 함수로서, 정렬을 원하는 시작주소와 끝주소 + 1을 넘겨주면 정렬을 해줍니다. 이 문제는 최소한 O(N log N) 의 정렬 알고리즘이 사용되어야 하기 때문에 내장함수를 이용하도록 합시다 구현int endf = 301, cnt = 0, i = 0;while (endf &amp;lt;= 1130) { int maxf = -1; for (; i &amp;lt; N; i++) { if (v[i].first &amp;lt;= endf) maxf = max(v[i].second, maxf); else break; } if (maxf == -1) break; endf = maxf; cnt++;}마지막으로 고른 꽃이 11월 30일을 넘기 전까지 계속해서 반복하며, i번째부터 시작해서 이전에 고른 꽃의 끝나는 날짜(endf) 를 넘지 않는 꽃들중 끝나는 날짜의 최대값 을 구합니다. i가 시작할 때만 초기화 되는 것을 주의해주세요. 3월 1일부터 피어있어야 하기 때문에, endf는 3월 1일을 의미하는 301을 넣어두었습니다.그리고, 만약 최대값이 갱신되지 않았다면 고를 수 있는 꽃이 없는 것이기 때문에 break 해주고, 그렇지 않으면 현재 최대값인 꽃을 골라줍니다. 즉, endf를 갱신해주고 꽃의 개수(cnt) 를 1 증가해줍니다. 정답 출력참고로, 문제를 자세히 읽어보지 않는다면 틀릴 수도 있는데, 어떤 꽃이 3월 1일에 피고 11월 30일에 진다면, 11월 30일을 포함 하여 그 이후로는 그 꽃을 볼 수 없다는 뜻입니다. 그래서 실제로는 12월 1일 이상인 꽃이 있어야만 합니다.if (endf &amp;lt; 1201) cout &amp;lt;&amp;lt; 0;else cout &amp;lt;&amp;lt; cnt; 전체 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v(N); int sm, sd, em, ed; for (int i = 0; i &amp;lt; N; i++) { cin &amp;gt;&amp;gt; sm &amp;gt;&amp;gt; sd &amp;gt;&amp;gt; em &amp;gt;&amp;gt; ed; v[i].first = sm * 100 + sd; v[i].second = em * 100 + ed; } sort(v.begin(), v.end()); int endf = 301, cnt = 0, i = 0; while (endf &amp;lt;= 1130) { int maxf = -1; for (; i &amp;lt; N; i++) { if (v[i].first &amp;lt;= endf) maxf = max(v[i].second, maxf); else break; } if (maxf == -1) break; endf = maxf; cnt++; } if (endf &amp;lt; 1201) cout &amp;lt;&amp;lt; 0; else cout &amp;lt;&amp;lt; cnt; return 0;}" }, { "title": "[BOJ] 7569 토마토", "url": "/posts/BOJ-7569/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2022-03-10 17:10:00 +0900", "snippet": "KOI 2013 E3이 문제는 BFS 알고리즘 을 사용하는 문제로써, 모든 1의 위치부터 시작해 3차원으로 인접한(상/하/좌/우/앞/뒤) 곳을 차례대로 방문하며 거리 를 계산해야 합니다. 거리를 계산하는 이유는 전부 채우는데 걸린 시간을 알아내기 위해서입니다. 이는 예제 입력 2 를 예시로 들자면,5 4 3 4 54 3 2 3 45 4 3 4 54 3 2 3 43 2 1 2 34 3 2 3 4이와 같이 각 토마토가 몇번째 날짜에 익었는지를 알아낼 수 있게 됩니다. 여기서 가장 오래걸린 날짜 5 - 1인 4가 정답인데, 시작 날짜를 포함하지 않기 위해서입니다.BFS를 잘 다룬다면 매우 간단한 문제이지만, 그렇지 않다면 어려울 수 있으니 BFS의 구현 방법과 구현에 사용되는 테크닉을 배워봅시다. 입력 처리#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int main() { int M, N, H; cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N &amp;gt;&amp;gt; H; vector&amp;lt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;gt; v(H, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(N, vector&amp;lt;int&amp;gt;(M))); for (int i = 0; i &amp;lt; H; i++) for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; M; k++) cin &amp;gt;&amp;gt; v[i][j][k]; return 0;}3차원 벡터를 사용하여 입력을 받았습니다. 벡터의 사용법을 모르신다면 [C++ STL] 벡터(Vector) 를 참고해주세요. BFS 구현/* include */struct point { int x, y, z;};int main() { /* 입력 처리 */ queue&amp;lt;point&amp;gt; Q; for (int i = 0; i &amp;lt; H; i++) for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; M; k++) if (v[i][j][k] == 1) Q.push({ k, j, i }); int dx[6] = { 1, -1, 0, 0, 0, 0 }; int dy[6] = { 0, 0, 1, -1, 0, 0 }; int dz[6] = { 0, 0, 0, 0, 1, -1 }; while (!Q.empty()) { for (int i = 0; i &amp;lt; 6; i++) { int x = Q.front().x + dx[i]; int y = Q.front().y + dy[i]; int z = Q.front().z + dz[i]; // 현재 보려는 좌표가 범위를 벗어나면 건너뛴다 if (0 &amp;gt; x || x &amp;gt;= M || 0 &amp;gt; y || y &amp;gt;= N || 0 &amp;gt; z || z &amp;gt;= H) continue; // 방문을 하지 않았을 때만 방문한다 if (v[z][y][x] == 0) { // 방문을 할 때, 자신이 가지고 있던 값 + 1 로 설정해줘서 거리를 나타낸다 v[z][y][x] = v[Q.front().z][Q.front().y][Q.front().x] + 1; Q.push({ x, y, z }); } } Q.pop(); } return 0;}BFS는 시작 정점들을 우선 Queue에 넣어두고, Queue에서 정점을 꺼내고, 꺼낸 정점들과 인접한 정점들을 다시 Queue에 넣어서 Queue가 비워질 때까지 반복하는 알고리즘입니다. 이 문제의 경우 3차원 좌표계이기 때문에 정점을 (x, y, z) 의 쌍인 struct point 로써 표현하였고, 인접한 정점들을 표현하기 위해 (x + 1, y, z), (x - 1, y, z), (x, y + 1, z)… 를 dx, dy, dz 라는 배열로 간단하게 반복문 으로 처리해 주었습니다. 만약 이 방법을 쓰지 않았다면 if문이 6개씩이나 될 것이고, 프로그래밍에서 중복은 좋지 않기 때문에 하나로 합쳐준 것이죠. 정답 출력int ans = 0;for (int i = 0; i &amp;lt; H; i++) for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; M; k++) { // 방문하지 않은 정점이 있다면 토마토가 전부 익지 못한 것 if (v[i][j][k] == 0) { cout &amp;lt;&amp;lt; -1; return 0; } ans = max(ans, v[i][j][k]); }cout &amp;lt;&amp;lt; ans - 1;BFS가 종료되면, 벡터를 반복하며 최대 거리(최대값) 를 찾아서 1을 빼주어 출력하면 끝입니다. 전체 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;struct point { int x, y, z;};int main() { int M, N, H; cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N &amp;gt;&amp;gt; H; vector&amp;lt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;gt; v(H, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(N, vector&amp;lt;int&amp;gt;(M))); for (int i = 0; i &amp;lt; H; i++) for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; M; k++) cin &amp;gt;&amp;gt; v[i][j][k]; queue&amp;lt;point&amp;gt; Q; for (int i = 0; i &amp;lt; H; i++) for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; M; k++) if (v[i][j][k] == 1) Q.push({ k, j, i }); int dx[6] = { 1, -1, 0, 0, 0, 0 }; int dy[6] = { 0, 0, 1, -1, 0, 0 }; int dz[6] = { 0, 0, 0, 0, 1, -1 }; while (!Q.empty()) { for (int i = 0; i &amp;lt; 6; i++) { int x = Q.front().x + dx[i]; int y = Q.front().y + dy[i]; int z = Q.front().z + dz[i]; // 현재 보려는 좌표가 범위를 벗어나면 건너뛴다 if (0 &amp;gt; x || x &amp;gt;= M || 0 &amp;gt; y || y &amp;gt;= N || 0 &amp;gt; z || z &amp;gt;= H) continue; // 방문을 하지 않았을 때만 방문한다 if (v[z][y][x] == 0) { // 방문을 할 때, 자신이 가지고 있던 값 + 1 로 설정해줘서 거리를 나타낸다 v[z][y][x] = v[Q.front().z][Q.front().y][Q.front().x] + 1; Q.push({ x, y, z }); } } Q.pop(); } int ans = 0; for (int i = 0; i &amp;lt; H; i++) for (int j = 0; j &amp;lt; N; j++) for (int k = 0; k &amp;lt; M; k++) { // 방문하지 않은 정점이 있다면 토마토가 전부 익지 못한 것 if (v[i][j][k] == 0) { cout &amp;lt;&amp;lt; -1; return 0; } ans = max(ans, v[i][j][k]); } cout &amp;lt;&amp;lt; ans - 1; return 0;}" }, { "title": "[BOJ] 10157 자리배정", "url": "/posts/BOJ-10157/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2022-03-07 17:20:00 +0900", "snippet": "KOI 2014 E2이 문제는 표를 보고 규칙을 찾고, 그 규칙을 코딩 가능한 단위로 나눠서 풀어야 합니다. 표를 전체적으로 보면 왼쪽 아래부터 시작해서 위쪽으로 나선형을 그리며 중앙으로 이동하는 형태인 것을 알 수 있습니다. 하지만 그 “나선형” 을 어떻게 코딩으로 해야할까요? 나선형을 구성하는 규칙들을 찾고, 코드로 바꿔봅시다. 세로 -&amp;gt; 가로 -&amp;gt; 세로 -&amp;gt; 가로 -&amp;gt; … 순서대로 이동한다 세로는 R, 가로는 C - 1 부터 시작해서 각 이동마다 이동횟수가 1씩 줄어든다 세로 -&amp;gt; 가로로 한번 이동한 후에, 이동 방향이 바뀐다아직 잘 와닿지 않을 수도 있지만, 단계적으로 코드를 작성해봅시다. 입력 처리int C, R, K;cin &amp;gt;&amp;gt; C &amp;gt;&amp;gt; R &amp;gt;&amp;gt; K;int x = 1, y = 0;여기서, y가 0부터 시작하는 이유는, 처음에 한번 좌표가 증가하며 (1,1) 은 1번 으로 시작하기 위함입니다. 그렇게 하지 않으면 R만큼 반복한 뒤에는 y가 R + 1이 되어버리기 때문에 이와 같이 처리해주었습니다. 세로 -&amp;gt; 가로 -&amp;gt; 세로 -&amp;gt; 가로 -&amp;gt; … 순서대로 이동한다while(true) { for (int i = 0; ; i++) { y += 1; } for (int i = 0; ; i++){ x += 1; }} 세로는 R, 가로는 C - 1 부터 시작해서 각 이동마다 이동횟수가 1씩 줄어든다while(true) { for (int i = 0; i &amp;lt; R; i++) { y += 1; } R--; for (int i = 0; i &amp;lt; C - 1; i++){ x += 1; } C--;} 세로 -&amp;gt; 가로로 한번 이동한 후에, 이동 방향이 바뀐다“이동 방향이 바뀐다” 라는 말은, 1을 더해주다가 1을 빼준다, 그러니까 1이 -1로, 그리고 그 반대로 부호가 계속 변한다 라는 것을 알 수 있습니다. 프로그래밍에서, 이렇게 값이 변한다면 변수 를 사용해 주어야 한다는 의미일 가능성이 높습니다.int sw = 1;while(true) { for (int i = 0; i &amp;lt; R; i++) { y += sw; } R--; for (int i = 0; i &amp;lt; C - 1; i++){ x += sw; } C--; sw = -sw;}그럼 벌써 기본적인 코드가 완성되었네요! 여기서 이제 매 이동마다 번호를 하나씩 세주고, 번호가 만약에 우리가 찾는 대기번호(K) 라면 결과를 출력하는 것 까지 해서 코드를 마무리 해 보겠습니다.int C, R, K;cin &amp;gt;&amp;gt; C &amp;gt;&amp;gt; R &amp;gt;&amp;gt; K;int x = 1, y = 0;int sw = 1, cnt = 0;while(true) { for (int i = 0; i &amp;lt; R; i++) { y += sw; cnt++; if (cnt == K) break; } if (cnt == K) break; R--; for (int i = 0; i &amp;lt; C - 1; i++){ x += sw; cnt++; if (cnt == K) break; } if (cnt == K) break; C--; sw = -sw;}cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; y;여기서 break 는 현재 반복문 만 나가주기 때문에, 바깥의 while까지 나가기 위해서 한번 더 break 해준 것에 유의해 주세요.전체 로직은 위와 같지만, 아직 마지막으로 할 일이 남았습니다. 반례 찾기이 문제는 반례를 문제에서 제시해 주었기 때문에 반례에 대한 처리만 해 주면 됩니다. 그 반례란 “입력받은 대기번호 K가 존재하지 않을 수 있다” 입니다. 그렇다면 끝까지 반복을 한 후에 찾았었는지 못찾았었는데 확인해 주어야 할까요? 훨씬 더 간단하게 할 수 있습니다. 나올 수 있는 최대 대기번호는 C * R이기 때문에, 만약 입력받은 K가 C * R보다 크다면 0을 출력하고 return 해 주어서 바로 끝내주면 됩니다. 전체 소스#include &amp;lt;iostream&amp;gt;using namespace std;int main() { int C, R, K; cin &amp;gt;&amp;gt; C &amp;gt;&amp;gt; R &amp;gt;&amp;gt; K; int x = 1, y = 0; int sw = 1, cnt = 0; if (C * R &amp;lt; K) { cout &amp;lt;&amp;lt; 0; return 0; } while(true) { for (int i = 0; i &amp;lt; R; i++) { y += sw; cnt++; if (cnt == K) break; } if (cnt == K) break; R--; for (int i = 0; i &amp;lt; C - 1; i++){ x += sw; cnt++; if (cnt == K) break; } if (cnt == K) break; C--; sw = -sw; } cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; y;}" }, { "title": "Clean Architecture - 시스템 설계", "url": "/posts/clean-architecture/", "categories": "Lecture, Basic", "tags": "Architect", "date": "2022-03-01 12:00:00 +0900", "snippet": "프로그래밍 패러다임구조적 프로그래밍structured programming1968년 Edsger Wybe Dijkstra가 발견했으며, 무분별한 점프(goto)는 프로그램 구조에 해롭다는 사실을 제시했고, 이런 점프들을 if/then/else와 do/while/until과 같은 것으로 대체하였다. 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.구조적 프로그래밍은 프로그래밍에서 반증 가능한 단위를 만들어낼 수 있으며, 그럼으로 인해 기능적 분해를 할 수 있게 해준다. 가장 작은 기능부터 가장 큰 컴포넌트까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록)만들기 위해 노력해야 한다.※ 테스트는 어떤 문제가 있다는 것을 알려줄 뿐이지 어떤 문제가 없다는 것을 알려주진 못한다.객체 지향 프로그래밍object-oriented programming1966년 Ole Johan Dal과 Kristen Nygaard에 의해 등장했으며, 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했고, 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다. 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 다형성이 등장하게 되었다. 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.객체지향 프로그래밍이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 이용해서 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부 사항을 포함하는 모듈에 대해 독립성을 보장할 수 있게 된다.함수형 프로그래밍functional programming위의 두 패러다임보다 먼저 만들어졌으며, 람다 계산법의 연구 결과에 직접적인 영향을 받아 만들어졌다. 람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이고, 이는 함수형 언어에서는 할당문이 전혀 없다는 뜻이기도 하다. 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.가변 변수는 동시성 프로그래밍(스레드, 프로세스 등) 에서 많은 문제를 일으킨다. 그래서 상태 변화를 일으키는 대신에 지금까지의 모든 트랜잭션을 이어붙이고, 값이 필요할 때는 이 트랜잭션을 전부 처리하는 식으로 할 수 있다.SOLID 원칙변경이 발생하는 부분을 변경이 발생하지 않는 부분과 분리해야한다. 변경이 발생하는 부분에서의 코드를 가능한 많이 변경이 발생하지 않는 부분으로 이동시켜야 한다는 뜻이다.SRP: 단일 책임 원칙Single Responsibility PrincipleConway 법칙에 따른 따름정리: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.여기서 액터란 사용자, 이해관계자 등을 의미한다.OCP: 개방-폐쇄 원칙Open-Closed Principle기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.소프트웨어 개체artifact는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.다시 말해 소프트웨어의 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.LSP: 리스코프 치환 원칙Liskov Substitution Principle하위 타입subtype에 관한 유명한 원칙이며, 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.S 타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.ISP: 인터페이스 분리 원칙Interface Segregation Principle소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.DIP: 의존성 역전 원칙Dependency Inversion Principle고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.컴포넌트 응집도REP: 재사용/릴리스 등가 원칙Reuse/Release Equivalence Principle재사용 단위는 릴리스 단위와 같다하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다. 컴포넌트는 재사용이 가능해야한다.CCP: 공통 폐쇄 원칙Common Closure Principle동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라SRP를 컴포넌트 관점에서 다시 쓴 것으로, 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다. 유지보수성maintainability 은 재사용성보다 훨씬 중요하며, 코드가 반드시 변경되어야 한다면 여러 컴포넌트 도처에서 분산되어 발생되는 것 보다는 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.CRP: 공통 재사용 원칙Common Reuse Principle컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다. 또한, 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다.세 원칙은 서로 상충하며, 이 원칙들이 균형을 이루는 방법을 찾아야 한다. 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 시간이 흐르며 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해해야 한다. 예를들어 프로젝트 초기에는 CCP가 REP보다 중요하다.REP - 재사용성을 위한 그룹CCP - 유지보수성을 위한 그룹CRP - 불필요한 릴리스를 피하기 위해 분리하기컴포넌트 결합ADP: 의존성 비순환 원칙(Acyclic Dependencies Principle)컴포넌트 의존성 그래프에 순환이 있어서는 안된다개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하면, 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다. 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다. 담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다. 그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자는 릴리스 된 버전을 사용한다.컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다. 새 릴리스가 적용할 준비가 되었다는 판단이 들었을 때 새 릴리스를 사용하기 시작한다. 따라서 어떤 팀도 다른 팀에 좌우되지 않게 된다. 단, 이 작업은 의존성 구조에 순환이 있으면 안된다.어느 컴포넌트도 시작해도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아가지 않는다면 된다.순환 끊기컴포넌트 사이의 순환을 끊고 의존성을 DAG로 원상복귀 하는 일은 언제라도 가능하다. 다음 두가지 방법이 있다. DIP을 적용하여, A-&amp;gt;B(A가 B에 의존적) 일 때 A가 필요로 하는 메서드를 인터페이스로 작성하고 이 인터페이스는 A에 위치시키고, B는 이 인터페이스를 상속시킨다. A와 B 모두가 의존하는 새로운 컴포넌트를 만들고, 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다. 하향식top-down 설계컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다. 컴포넌트 의존성 구조와 같이 큰 단위로 분해된 집단을 관찰하면 시스템의 기능적 측면을 컴포넌트가 어떤 식으로돈 표현하리라고 믿을 수 있지만, 이는 컴포넌트 의존성 다이어그램이 가진 속성이 아니다.컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 오히려 빌드 가능성과 유지보수성을 보여주는 지도와 같다. 그래서 이러한 이유때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다. 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문이다.SDP: 안정된 의존성 원칙Stable Dependencies Principle안정성의 방향으로(더 안정된 쪽에) 의존하라설계는 결코 정적일 수 없기 때문에, 공통 폐쇄 원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다. 이처럼 컴포넌트의 일부는 변동성을 지니도록 설계된다.안정성을 평가하는 방법은 Fan-in을 안으로 들어오는 의존성의 개수, Fan-out을 밖으로 나가는 의존성의 개수라고 하자. 이 때 개수의 단위는 클래스 개수이다. 그럼 불안정성 I는 I = Fan-out / (Fan-in + Fan-out) 라는 식으로 계산할 수 있으며 이 지표는 [0, 1] 범위의 값을 가지며 I가 0이면 최고로 안정된 컴포넌트라고 할 수 있다. 왜냐면 많은 컴포넌트가 하나의 컴포넌트를 의존하고 있을 수록 그 컴포넌트를 변경하기 힘들기 때문이다. SDP에서 컴포넌트의 I지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야한다.하지만 모든 컴포넌트가 안정적이어야 하는 것은 아니란 것을 염두하자.SAP: 안정된 추상화 원칙Stable Abstractions Principle컴포넌트는 안정된 정도만큼만 추상화되어야 한다고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 (I=0) 컴포넌트에 위치해야 하고, 불안정한 컴포넌트는 반드시 변동성이 큰 소프트웨어만을 포함해야 한다. 하지만 고수준이 안정된 컴포넌트에 위치되면 수정하기가 힘드므로, OCP 원칙에 따라 추상 클래스로 만들어야 한다.SAP는 안정성과 추상화 정도 사이의 관계를 정의하며, 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 이을 방해해서는 안된다고 한다. 또한, 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.SAP와 SDP를 결합하면 컴포넌트에 대한 DIP가 아닌가하고 생각할 수 있지만, 컴포넌트는 클래스와 다르게 부분적으로만 추상적일 수 있다.아키텍처독립성좋은 아키텍처는 다음을 지원해야 한다.유스케이스시스템의 아키텍처는 시스템의 의도를 지원해야 한다. 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않지만, 행위를 명확히 하고 외부로 드러내며 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만들어야 한다.운영어떤 과제가 있을 때, 이 과제를 해결할 수 있으면서 개선이 용이하도록 설계해야한다. 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.개발Conway의 법칙 “시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다”많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.배포아키텍처는 ‘즉각적인 배포’를 목표로 설계해야하며, 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다. 이를 위해서도 시스템을 컴포넌트 단위로 적절하게 분할, 격리해야 하며 마스터 컴포넌트로 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.// To-Do: 이후 추가 작성" }, { "title": "C대신 C++로 알고리즘 풀기", "url": "/posts/C-to-CPP/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2022-02-27 14:10:00 +0900", "snippet": "※ 이 강좌는 알고리즘 풀이만을 위해 C에서 C++로 빠르게 넘어갈 수 있도록 거의 대부분의 문법을 생략한 강좌입니다.C에서 알고리즘을 풀다가 C++로 알고리즘을 풀기란 매우 간단합니다. 왜냐하면 기본 문법과 거의 99% 유사하기 때문인데요, C++ 라는 이름에서 유추할 수 있듯 C++는 실제로 C에 기능이 추가된 언어입니다. 그래서 C와 C++는 같이 묶어서 설치&amp;amp;사용되기도 하죠. 우선 C로 작성된 코드와 C++로 작성된 코드를 봅시다. ex.c#define _CRT_SECURE_NO_WARNINGS#include &amp;lt;stdio.h&amp;gt;int main() { int N, M; scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M); printf(&quot;%d + %d = %d&quot;, N, M, N + M); return 0;} ex.cpp#include &amp;lt;iostream&amp;gt;using namespace std;int main() { int N, M; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; cout &amp;lt;&amp;lt; N &amp;lt;&amp;lt; &quot; + &quot; &amp;lt;&amp;lt; M &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; N + M; return 0;}C++에서는 모든 헤더파일에 .h를 붙이지 않으며, &amp;lt;stdio.h&amp;gt; 대신 &amp;lt;iostream&amp;gt; 을 사용합니다. scanf와 printf도 사용할 수 있지만, 주로 cin과 cout을 이용합니다.네임스페이스 namespace위 C++ 코드에서 namespace는 이름표와 같습니다. 다른 사람이랑 같이 작업을 하거나, 다른 사람의 코드를 가져오면 의도치 않게 같은 이름의 함수를 써버릴 수도 있습니다. 그 때 사용하는 것이 네임스페이스입니다.namespace &amp;lt;네임스페이스 이름&amp;gt; { /*... 내용 ...*/}namespace 안에 변수, 함수, 클래스 등을 넣으면 그 모든 요소들은 해당 네임스페이스에 종속됩니다.예를들어, My라는 네임스페이스 안에 print 라는 함수를 만들었다면, 그 함수를 호출하기 위해서는 My::print()를 사용하면 됩니다.#include &amp;lt;iostream&amp;gt;namespace My { void print() { std::cout &amp;lt;&amp;lt; &quot;Hello World&quot;; }}int main() { My::print(); return 0;}하지만, 만약 이 함수들을 자주 사용한다면 매번 앞에 네임스페이스 이름을 적어주는 것이 힘든데, 그 때는 위에 using namespace &amp;lt;이름&amp;gt;; 을 사용하여 명시해줍니다. 그러면 해당 네임스페이스는 앞에 이름을 생략하여도 좋습니다.문자열 타입 string#include &amp;lt;iostream&amp;gt;int main() { string s; cin &amp;gt;&amp;gt; s; cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &#39;\\n&#39;; for (int i = s.length() - 1; i &amp;gt;= 0; i--) cout &amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt; &#39; &#39;; return 0;}C++에는 문자열을 나타내기 위해 char의 배열[] 외에도 string 타입을 지원합니다. 입력된 문자열에 따라서 길이가 자동으로 바뀌고, .length() 함수를 통해 문자열의 길이도 알 수 있습니다. 그러면서도 배열과 같이 []로 접근할 수 있기 때문에 char의 배열을 쓸 이유가 없죠.문자열에 관련한 추가적인 함수가 필요하다면 &amp;lt;string&amp;gt; 라이브러리를 #include 해주면 됩니다. 자세한 내용은 여기서 다루지 않겠습니다.파일 입출력 fstream#include &amp;lt;iostream&amp;gt;#include &amp;lt;fstream&amp;gt;using namespace std;int main() { ifstream fin(&quot;input.txt&quot;); ofstream fout(&quot;output.txt&quot;); int N; cout &amp;lt;&amp;lt; &quot;몇개의 데이터를 불러올까요? &quot;; cin &amp;gt;&amp;gt; N; int *v = new int[N]; for (int i = 0; i &amp;lt; N; i++) { fin &amp;gt;&amp;gt; v[i]; if (fin.eof()) { N -= N - i - 1; break; } } for (int i = 0; i &amp;lt; N; i++) { fout &amp;lt;&amp;lt; v[i] &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; &quot;저장이 완료되었습니다. &quot;; delete[] v; return 0;}C++에서 파일 입출력을 위해 를 사용합니다. ifstream은 input file stream, ofstream은 output file stream으로 무조건 읽기만/쓰기만 하는 타입이라고 보시면 됩니다. fstream으로 직접 어떻게 읽어올지 명시해 줄 수도 있지만 그런 일은 희박하기 때문에, 위의 2 타입만을 이용하시면 됩니다. 이제 파일에서 뭔가를 읽어오려면 cin으로 값을 받아오듯이 입력하면 됩니다. eof는 End Of File의 약자로, 파일을 전부 읽었는지 확인해 주는 함수입니다.파일을 읽어올 때 위와 같이 ()안에 파일 이름을 입력하여 생성자로 파일을 열었을 경우, 현재 스코프(중괄호)를 벗어나면 파일이 암시적으로 닫히게 됩니다. open(“파일이름”) 멤버함수로 파일을 열었을 경우 close()로 명시적으로 닫아주어야합니다.여기서 new 연산자가 보이는데, C++에서는 동적 할당을 해줄 때 malloc과 같은 함수를 사용하지 않고, new를 이용해 바로 할당해 줄 수 있습니다. 또한, free함수 대신 delete 함수를 사용합니다. delete는 일반 변수도 할당 해제할 수 있기 때문에, delete[] 는 배열의 메모리를 해제 해줄 때 사용됩니다.이번 글에서 설명한 개념들만 알고 있어도 C++을 이용한 알고리즘 풀이에는 지장이 없습니다. 하지만 여기에 추가로 C++ STL 에 대해서 공부하는 것을 추천드립니다." }, { "title": "자료구조와 알고리즘", "url": "/posts/data-structure-and-algorithms/", "categories": "Lecture, Basic", "tags": "Essence", "date": "2022-01-27 12:00:00 +0900", "snippet": " Introduction to Data Structure코딩을 조금 하고 나면 프로그래밍은 데이터를 주로 다룬다는 것을 알 수 있습니다. 컴퓨터 프로그램은 데이터를 입력받고, 조작하고, 반환하는 게 끝입니다. “Hello, World” 라는 문자열과 숫자들이 바로 데이터이죠. 자료구조는 이런 데이터들을 조직하는 방법이며, 코드의 실행 속도에 영향을 미칩니다. 데이터를 어떻게 조직하는지에 따라 프로그램이 수백 수천배보다도 더 빠르거나 느리게 실행될 수 있기 때문이죠.즉, 자료구조는 데이터를 저장하고 정리하여 접근과 수정을 가능하게 해주는 것으로 자료구조는 모든 목적에 적합할 수 없기 때문에 장점과 한계들을 아는 것이 중요합니다.자료구조의 연산대부분의 자료구조는 코드와 자료구조가 상호작용하기 위해 네 가지 기본 방법을 사용하는데, 이를 연산 이라고 부릅니다. 읽기 : 자료 구조 내 특정 위치의 데이터를 가져오는 것입니다. 검색 : 자료 구조 내에서 특정 값을 찾는 것입니다. 삽입 : 자료 구조에 새로운 값을 추가하는 것입니다. 삭제 : 자료 구조에서 값을 제거하는 것입니다. 여기서 이 연산들이 얼마나 “빠른지” 측정하기 위해서는 시간 관점에서 연산이 빠른지가 아니라 얼마나 많은 단계가 필요한지를 보아야 합니다. 그 이유는, 어떤 연산이 정확히 몇 초가 걸린다고 할 수 없기 때문입니다. 같은 연산도 성능 좋은 컴퓨터에서는 더 빠르고, 반대의 경우 더 느릴 수 있기 때문이죠. 예를들어 연산 A에 5단계가 필요하고 연산 B에 500단계가 필요하면 모든 하드웨어에서 연산 A가 연산 B보다 항상 빠를 것을 알 수 있습니다.배열Array배열은 단순히 데이터 원소들의 리스트입니다. 예를들어 다음과 같은 배열은 요일의 이름을 나타내죠.weeks = [&quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thr&quot;, &quot;fri&quot;, &quot;sat&quot;, &quot;sun&quot;]배열의 인덱스(번호)는 특정 데이터가 배열의 어디에 있는지 알려주는 숫자입니다. 대부분의 프로그래밍 언어에서 인덱스는 0부터 시작합니다. “mon”은 인덱스 0에 위치하고 “sun”은 인덱스 6에 위치합니다.이제 이 배열에 대한 연산 들의 단계와 방법들을 알아보도록 하겠습니다.배열의 읽기배열에서의 읽기란 특정 인덱스에 어떤 값이 들어있는 지 찾아보는 것입니다. 읽기의 단계는 딱 한 단계인데, 컴퓨터는 배열 내의 특정 인덱스에 한번에 접근해서 볼 수 있기 때문입니다.이게 왜 가능한지 알기 위해서는 메모리 구조에 대해서 알아야 하는데, 메모리는 일정 간격으로 나뉜 셀들로 이루어져 있는 공간이라고 생각할 수 있습니다. 프로그램에서 배열을 선언하면 연속된 빈 셀들의 집합을 할당합니다. 위쪽의 weeks 배열을 예로 들면, 7개의 값이 들어가기 위한 7개의 연속된 빈 셀들이 있는 위치를 찾아 배열로 지정합니다.그리고, 컴퓨터 메모리 내의 각 셀에는 숫자로 이루어진 주소가 존재합니다. 편의를 위해 간단하게 설명하자면, 첫번째 셀의 주소가 0일때, 그 뒤의 주소는 1, 2, 3, 4… 이렇게 1씩 증가합니다. 그래서 만약에 배열의 시작 주소를 알 수 있으면, 시작한 위치부터 3칸 뒤의 주소가 바로 네 번째 데이터의 값(&quot;thr&quot;)이기 때문에, 한 번의 단계로 끝나는 것이죠. 이게 바로 인덱스가 0부터 시작하는 이유입니다. 참, 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있습니다.배열의 검색배열에서 특정 값을 찾기 위해서는, 인덱스 0부터 시작해서 차례로 읽기 연산을 하고, 찾던 값이 아니면 다음 인덱스로 넘어가 찾을 때까지 이를 반복합니다. 예를 들어 weeks 배열에서 &quot;wed&quot; 를 찾기 위해서는 0번째 -&amp;gt; 1번째 -&amp;gt; 2번째 만큼 움직여야지만 알 수 있으므로 총 3단계가 걸렸습니다. 우리는 눈으로 보고 바로 알 수 있지만 컴퓨터에는 눈이 없기 때문에 이렇게 할 수밖에 없죠.이와 같이 한번에 하나씩 확인하는 검색 연산을 선형 검색 이라고 합니다. 그럼 이 때 최대 단계 수는 어떻게 될까요? 간단하게 배열의 길이가 N이라면 N개의 단계가 필요하다고 할 수 있습니다.배열의 삽입배열에서 삽입을 할 때, 맨 마지막에 삽입한다면 그냥 배열의 맨 뒤에 추가하면 되기 때문에 한 단계만 필요하지만, 만약 중간 어딘가에 삽입한다면, 데이터를 삽입하고 원래 있던 데이터부터 끝에 있는 데이터까지는 전부 한 칸씩 뒤로 이동시켜 줘야 하기 때문에 많은 단계가 필요합니다. 각 데이터가 사람들이 서있는 줄이라고 할 때, 줄 중간에 들어가려면 사람들이 전부 뒤로 한칸씩 비켜줘야 하는 것을 생각할 수 있습니다.이 경우에도 최대 단계, 즉 최악의 경우에 N개의 단계가 필요합니다. 맨 앞에 데이터를 삽입하려면 모든 데이터가 뒤로 한칸씩 움직여야 하기 때문이죠.배열의 삭제삭제 또한 삽입과 똑같습니다. 중간에 데이터를 삭제하면, 삭제한 곳부터 뒤에있는 모든 데이터는 모두 앞으로 한 칸씩 이동시켜 줘야 하기 때문이죠. Introduction to Algorithm알고리즘이란, 단순히 어떤 문제를 해결하는 절차입니다. 예를 들어 유튜브를 보는 알고리즘은 다음과 같습니다. 웹브라우저를 연다 youtube.com에 접속한다 원하는 영상을 검색한다 영상을 클릭해서 시청한다컴퓨팅에서의 알고리즘도 이와 같이 특정 연산의 해결을 위핸 절차입니다. 자료구조에서 읽기, 검색, 삽입, 삭제를 위한 절차도 알고리즘이죠. 이 알고리즘을 어떻게 작성하냐에 따라 코드가 매우 빠르게 실행되기도, 느리게 실행되기도 합니다. 그럼 알고리즘의 예제를 살펴보도록 합시다. 기술적인 의미의 알고리즘컴퓨터가 무제한의 속도를 가지고 있고 메모리가 무비용이라고 해도 그래도 아직 알고리즘이 필요할까요? 그렇습니다. 메모리가 무비용이라도 개발한 기능이 올바른 답과 함께 종료되길 원할 것이고, 컴퓨터가 무제한의 속도였다면 아무 알고리즘이나 사용할 수 있겠지만 소프트웨어 공학적으로 잘 작성, 기술되어지길 원할 것이기 때문입니다.정렬된 배열배열인데, 숫자가 순서대로 정렬되어있어야 하는 자료구조를 생각해봅시다. 그러면 삽입 연산을 할 때마다 검색 연산이 필요하게 됩니다. 예를들어 아래와 같은 값들이 들어있는 배열이라 할때[10, 20, 40, 50]여기에 30을 삽입하기 위해서는, 우선 30보다 큰 값(40)을 검색하고 해당 위치에 삽입하게 됩니다. 그러면 40, 50은 전부 오른쪽으로 한칸씩 이동해야 해고 생긴 자리에 30을 넣을 수 있게 되는 것이죠.[10, 20, 30, 40, 50]여기까지만 보면 쓸데없이 정렬한다고 생각될 수 있습니다. 하지만 정렬된 배열의 진가는 탐색 연산에서 드러납니다.이진 검색배열의 검색 에서 사용된 방법은 선형 검색이었습니다. 첫번째 원소부터 끝번째 원소까지 전부 차례대로 확인하는 것이죠. 하지만 만약 배열이 정렬되어 있다면, 이진 검색을 사용할 수 있습니다.방법은 간단합니다. 예를들어 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 가 배열에 있다고 할 때, 9를 찾는다고 합시다. 그럼 우선 중간 인덱스(0+9/2 = 4) 에 있는 값(5) 을 봅시다. 9는 5보다 크니까 이제 인덱스 4부터 인덱스 9 의 중간 인덱스(4+9/2 = 6)의 값(7)을 봅시다. 9는 7보다 크니까 이제 인덱스 7부터 인덱스 9 의 중간 인덱스(7+9/2 = 8)의 값(9)를 봅시다. 찾았네요!선형 검색으로 처리했다면 9단계가 걸렸겠지만, 이진 검색으로는 3단계만 필요했습니다. 이는 숫자가 커지면 더 극적으로 차이가 벌어지는데, 원소가 10,000개인 배열에서 선형 검색은 최대 10,000단계가 필요하지만, 이진 검색은 13단계면 충분합니다. 왜냐면 이진 검색은 데이터를 두 배로 늘릴 때마다 단계가 최대 하나씩만 추가되기 때문인데, 이것을 두고 우리는 로그 형태의 단계가 들어간다고 합니다.만약 코딩 문법을 알고 있다면, C언어로 표현된 이진 탐색의 코드는 다음과 같습니다.int binary_search(int array[], int array_size, int value) { int lower_bound = 0; int upper_bound = array_size - 1; while (lower_bound &amp;lt;= upper_bound) { int mid = (lower_bound + upper_bound) / 2; if (value &amp;lt; array[mid]) upper_bound = mid - 1; else if (value &amp;gt; array[mid]) lower_bound = mid + 1; else return mid; // 결과 인덱스를 반환 } // while문 내에서 return되지 않았다면 값이 없는것이기 때문에 없다는 표시로 -1을 반환 return -1; }물론 그렇다고 우리가 정렬된 배열만 쓸 필요는 없습니다. 검색이 많이 필요한 상황이라면 정렬된 배열이 좋겠지만, 검색을 쓰지 않는 상황이라면 굳이 삽입 때 시간을 소모하지 않는 일반 배열을 쓰는 게 더 효율적이기 때문이죠. 그래서 자료구조들은 상황에 맞게 적재적소에 사용된다고 생각하시면 됩니다.빅-오 표기법우리가 어떤 알고리즘(자료구조의 연산 등) 의 효율성을 나타낼 때, 얘는 2000단계가 필요해요! 라고 말하지 않습니다. 전문적이지 않을 뿐더러, 상황에 따라 필요한 단계가 다르기 때문에 빅-오 표기법을 사용해서 “배열에 N개의 원소가 있을 때 선형 검색에 N단계가 필요합니다” 라는것을 “이 알고리즘는 O(N)” 이다. 와 같이 나타냅니다. 시간복잡도가 O(N) 이라고 하기도 하죠.어 그런데, 만약 내가 [1, 2, 3, 4, 5] 가 들어있는 배열에서 1을 검색할 때는 한 단계만 필요한데 N단계가 아니잖아요! 라고 할 수 있습니다. 네, 빅-오 표기법은 최악의 상황 을 가정해서 표기하게 됩니다. 최악을 대비함과 동시에 알고리즘 선택에 중요한 영향을 미치기 때문이죠. 물론, 평균적인 성능을 나타내기도 하지만 빅-오 표기를 어떻게 하는지와 그 종류에 대해서 알아보록 합시다.상수 시간O(1) 이라고 표기하며, 데이터가 얼마나 많든 상관없이 고정적인 단계를 가질 경우를 나타냅니다. 예를 들어, 배열에서 읽기는 O(1)입니다. 언제나 한 단계만 필요하기 때문이죠. 하지만 만약 10,000 단계가 필요했다고 해도 O(1)으로 표기합니다.선형 시간O(N) 이라고 표기하며, 데이터의 개수만큼 단계가 늘어남을 나타냅니다. 그래프로 그리면 완벽한 대각선(일차방정식)이 나오기 때문에 “선형 시간” 이라고 부릅니다.로그 시간O(log N) 이라고 표현합니다. 여기서 log의 밑은 2입니다. 이게 무슨 뜻이냐면, “2를 몇제곱해야 N이 되는가?” 입니다. 예를들어 log8 = 3 입니다. 2의 3승이 8이기 때문이죠. 하지만 수학문제가 아니기 때문에 대략 “2로 몇번 나눠야 1이 되는가?” 라고 생각하셔도 좋습니다.이 외에도 지수시간O(N^2) (N의 제곱) 등이 존재하지만, 보시면 아실 수 있습니다.빅-오의 특징여기서 빅-오의 특징으로, 빅-오에서는 상수를 무시해줍니다. 예를 들어 어떤 알고리즘의 시간복잡도가 O(N^2) 이고 여기에 100단계정도가 더 추가되더라도 그대로 O(N^2) 입니다. N의 값이 한없이 커짐에 따라 100은 의미가 없어지기 때문이죠.같은 이유로, 다항 시간ex) N^3 + N^2 + N 인 알고리즘의 경우 가장 높은 차수 만이 빅-오에 표시됩니다. 그래서 위같은 알고리즘의 빅-오 표기는 O(N^3) 이 됩니다. 이는 상수와 같은 이유로 N의 값이 한없이 커지면 N^3의 변화율을 N^2나 N이 따라오지 못하기 때문이죠. 이해가 잘 안되신다면, 정렬 알고리즘에 대해 공부해보면서 익혀봅시다.O(N^2)인 정렬 알고리즘정렬 은 프로그래밍에 있어서 매우 자주 사용되는 알고리즘이며, 그로인해 다양한 알고리즘들이 존재합니다. 여기서는 간단한 기초 알고리즘인 “버블 정렬” 과 “삽입 정렬” 에 대해서만 알려드리겠습니다.버블 정렬배열의 처음부터 배열의 길이 - 1 까지 연속된 두 원소를 비교해서, 만약에 오른쪽의 수가 더 작으면 두 수의 위치를 교환합니다. 예를들어 [ 3, 2, 1 ] 을 정렬한다면 인덱스 0과 1의 원소인 3 과 2 를 비교합니다. 2가 더 작으니 위치를 교환합니다. [ 2, 3, 1 ] 이제 인덱스 1과 2를 비교하면 3 과 1 중 1이 더 작으니 위치를 교환합니다. [ 2, 1, 3 ]. 이 작업을 배열의 길이 - 1 만큼 반복하면 됩니다. 왜냐면 최악의 경우 맨 오른쪽의 값이 맨 왼쪽까지 오려면 배열의 길이 - 1 만큼 이동해야 하기 때문이죠.int arr[10] = { 9, 2, 3, 8, 4, 1, 7, 10, 6, 5 };for (int i = 0; i &amp;lt; 9; i++) { for (int j = 0; j &amp;lt; 9; j++) { if (arr[j] &amp;gt; arr[j+1]) { int tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; } }}for (int i = 0; i &amp;lt; 10; i++) printf(&quot;%d &quot;, arr[i]);버블 정렬은 (N-1)^2 + N 의 단계가 필요합니다. 빅-오로 표기하면 O(N^2) 가 됩니다. -1은 N이 한없이 커질수록 값의 차이가 미미해지기 때문에, 빅-오에서 상수는 전부 무시해줍니다. 같은 이유로, N^2 + N 에서도 N=100 만 되어도 10000 + 100 이라는 100:1 이라는 큰 차이이기 때문에 빅-오에서는 가장 높은 차수만 사용해줍니다.[?] 혹시 “값의 교환은 왜 단계로 쳐주지 않나요?” 라는 의문점이 들었다면, 값의 교환 또한 단계가 있는 것은 맞지만 그것을 포함하더라도 많아야 2 * N^2 정도기 때문에 상수는 무시된 것입니다. 빅-오는 코드의 반복문의 반복횟수 로 계산해주면 됩니다.[?] 만약 버블정렬에서 한번 반복할 때마다 끝에서부터 값이 하나씩 정렬이 완료된다는 사실을 눈치채셨다면, 맞습니다. 하지만 O(N^2) 를 좀 더 효과적으로 설명해드리기 위해 여기서는 일부러 생략하였습니다.선택 정렬선택 정렬은 사실 버블 정렬보다 간단합니다. 일단 처음 인덱스부터 시작합니다. 그 다음 인덱스부터 배열의 끝까지 검색하면서 최솟값을 찾습니다. 검색이 끝나면, 처음 인덱스와 찾은 최솟값의 위치를 교환해줍니다. 예를 들어, 배열이 [ 5, 2, 1, 4, 3 ] 가 있었다면, 처음부터 끝까지 반복하면 최솟값의 인덱스는 2이라고 알 수 있습니다. 그럼 인덱스 0과 교환해주면 배열은 다음과 같이 됩니다. [ 1, 2, 5, 4, 3 ] 이 이후에는 인덱스 1부터 끝까지, 그 다음에는 인덱스 2부터 끝까지… 그러면 검색을 할 때마다 보아야 하는 원소의 개수가 하나씩 감소하는 것을 알 수 있습니다.int arr[10] = { 9, 2, 3, 8, 4, 1, 7, 10, 6, 5 };for (int i = 0; i &amp;lt; 10; i++) { int minidx = i; for (int j = i + 1; j &amp;lt; 10; j++) if (arr[minidx] &amp;gt; arr[j]) minidx = j; int tmp = arr[minidx]; arr[minidx] = arr[i]; arr[i] = tmp;}for (int i = 0; i &amp;lt; 10; i++) printf(&quot;%d &quot;, arr[i]);그래서 총 O(N^2 / 2) 가 되어야 할 것 같은데… 상수를 무시해주기 때문에 이 또한 O(N^2) 가 됩니다. 여기서 더 알아야 하는 점은, 이와 같은 이유 때문에 같은 시간복잡도의 알고리즘이라도 데이터의 상황에 따라, 알고리즘의 효율은 다를 수 있다는 점입니다. 만약 O(N^2) 과 O(N) 알고리즘 중에서 선택하라면 당연히 O(N)을 선택하는 것이 좋지만, 같은 O(N) 이라면 효율성 분석을 좀 더 자세히 하는 것이 좋습니다.삽입 정렬인덱스 1부터 시작하는데, 자신의 값을 임시변수에 저장해놓고, 0번째 인덱스까지 비교하며 만약 임시변수의 값보다 크다면 오른쪽으로 이동해줍니다. 그러다 만약 임시 변수의 값보다 작은 값을 만나면 그 다음 인덱스에서 멈춰줍니다. 글로 읽기에는 복잡할 수 있으니 한번 예시를 보여드리죠.[3, 2, 1, 5, 4]가 있을 때, 임시변수에 인덱스 1의 값을 저장합니다. tmp = 2그 후, 인덱스 0의 값을 보았더니 임시변수의 2보다 크기 때문에 오른쪽으로 이동해줍니다[3, 3, 1, 5, 4]어짜피 덮어씌워질테니 오른쪽으로 대입만 해도 괜찮습니다인덱스의 마지막(0) 에 도달했기 때문에 임시변수의 값을 넣습니다[2, 3, 1, 5, 4]임시변수에 인덱스 2의 값을 저장합니다. tmp = 1그 후, 비교를 하니 임시변수의 1보다 크기 때문에 오른쪽으로 이동해줍니다[2, 3, 3, 5, 4]그 후, 인덱스 0과 비교를 하니 1보다 크기 때문에 오른쪽으로 이동해줍니다[2, 2, 3, 5, 4]인덱스의 마지막(0) 에 도달했기 때문에 임시변수의 값을 넣습니다[1, 2, 3, 5, 4]이와 같은 과정을 끝까지 반복해주면 정렬이 완료됩니다.int arr[10] = { 9, 2, 3, 8, 4, 1, 7, 10, 6, 5 };for (int i = 1, pos; i &amp;lt; 10; i++) { int tmp = arr[i]; for (pos = i; pos &amp;gt; 0 &amp;amp;&amp;amp; arr[pos - 1] &amp;gt; tmp; pos--) arr[pos] = arr[pos - 1]; arr[pos] = tmp;}이제 지금까지와는 다르게 코드 하나하나의 단계를 자세히 살펴봅시다. 삽입 정렬은 최악의 경우에 N^2 / 2 번의 비교와 이동이 일어나므로 N^2 단계가 필요합니다. 임시변수에 값을 저장하고 다시 배열에 값을 삽입하는 횟수는 각각 N - 1번이므로 2N - 2 단계가 필요합니다. 그래서 총 N^2 + 2N - 2 단계가 필요하게 됩니다. 빅-오는 가장 높은 차수만 고려하고, 상수를 무시하기 때문에 O(N^2) 라고 할 수 있죠.최선, 최악, 평균여기까지만 보면 버블, 선택, 삽입 정렬중에서 선택 정렬이 가장 빨라보입니다. 최악의 경우에는 확실히 선택 정렬이 제일 빠르죠. 하지만 평균적인 경우 에서는 다릅니다. 왜냐하면 삽입 정렬은 최악의 경우(예를 들어 내림차순인 데이터를 오름차순으로 정렬할때) 모든 데이터를 비교&amp;amp;이동하지만 평균적인 경우(적당히 무작위인 숫자인 경우) 데이터의 절반정도만 비교해도 정렬이 완료될 것이기 때문이죠.선택 정렬의 경우 최선, 평균, 최악의 경우 모두 동일하게 O(N^2/2) 의 시간복잡도를 가집니다. 정렬이 되어있던 아니던 모두 비교해야하기 때문이죠. 하지만 삽입 정렬의 경우 최악에 O(N^2), 평균에 O(N^2 / 2), 최선에 O(N) 의 시간이 걸립니다. 데이터가 이미 정렬되어 있는 경우 반복을 도중에 종료할 수 있기 때문이죠.이것은 각 알고리즘에 대해 더 깊은 고찰의 여지를 남기는 내용이지만, 또한 알고리즘을 작성할 때에 “가능하면 도중에 종료한다” 와 같이 일반적인 수행을 고려한 내용을 넣어 주어야 한다는 말이기도 합니다. 예를 들어, 정렬 알고리즘의 각 반복마다 배열이 정렬되었는지 확인하고, 정렬되었다면 나가는 코드를 작성한다면 “일반적으로 정렬된 데이터가 들어오는” 상황에서 알고리즘을 O(N) 으로 단축시킬 수도 있게 되는 것이죠.결론적으로, 우리는 어떤 알고리즘의 최선, 최악, 평균 의 경우를 모두 따져봐야 한다고 할 수 있습니다.해시 테이블해시 테이블은 배열과 비슷하지만, 인덱스가 0부터 시작하는 숫자가 아닌 특별한 문자열이 사용될 수 있다는 점이 다릅니다. 그래서 특정 값을 볼 때 매우 빠르게 볼 수 있죠.예를들어, 사이트나 게임에서 아이디와 비밀번호를 입력하고 로그인하려 할 때 시스템에서 만약 배열을 사용한다면, 배열에서 아이디를 검색해서 해당 아이디에 저장된 비밀번호와 사용자가 입력한 비밀번호가 같은지 확인해야 할 겁니다. 이 과정마다 검색이 필요한데, 해시 테이블은 이 과정을 O(1) 만에 해결할 수 있습니다.이게 가능한 방법은 해시 함수를 사용하기 때문인데, 이는 문자열을 하나의 숫자로 변환하는 것이라 할 수 있습니다. 예를들어, A=1, B=2, C=3… 라고 한다면, “DAC” 라는 문자열은 413 이라고 할 수 있습니다. 여기서 이 413에 4 * 1 * 3 과 같은 작업을 하면 “DAC”의 해시 값은 12가 됩니다. 이는 해시 함수의 한 예일 뿐이고, 실제로는 더 복잡한 식이 사용됩니다.해시 함수가 유효하기 위해서는 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자 로 변환되어야 하는 조건을 가지고 있습니다. 일관적이어야 한다는 것이죠. 그런데 “CAD” 또한 3 * 1 * 4 로 12가 나와 해시 값에 충돌 이 있다는 것을 알 수 있습니다. 이는 잠시 후에 알아보도록 하죠.그럼 이제 해시 함수에 대해 알아보았으니, 해시 테이블이 어떻게 작동되는지 봅시다. 배열과 비슷하게 해시 테이블에 값은 다음과 같이 삽입합니다.dictionary[&quot;ABC&quot;] = &quot;Hello&quot;여기서 인덱스로 사용된 “ABC” 를 키(Key), 안에 들어간 “Hello”를 값(Value) 라고 합니다. 그러면 이는 dictionary 라는 해시 테이블의 “ABC” 번째, 즉 1 * 2 * 3 = 6 번째 인덱스에 “Hello” 라는 값을 삽입하게 됩니다. 그럼 값을 꺼낼때는 search = dictionary[&quot;ABC&quot;] 와 같이 할 수 있으며, 해시 테이블은 또한번 “ABC” 에 해시 함수를 적용시켜 6번째 인덱스의 “Hello” 값을 읽게 됩니다.해시 충돌 해결하기해시값의 충돌은 여러 방법으로 해결할 수 있지만, 여기서는 그 중 가장 간단하고 직관적인 방법을 알려드리겠습니다.해시 테이블에 실제 값이 아니라 “참조 값” 을 저장하게 합니다. 그러니까, 해시 테이블의 각 인덱스에는 배열이 있고, 삽입 시에 해시 값의 충돌이 일어나면 인덱스 안의 배열에 추가해주는 것이죠. 그리고 충돌이 있는 해시 값을 읽어오려고 할 때는, 해당 인덱스의 배열을 검색해서 입력받은 키(Key) 값과 일치하는 것을 찾습니다. 이를 체이닝(chaining) 이라고 합니다. 배열이 아니라 연결 리스트와 같은 자료 구조를 사용할 수도 있습니다.예를 들어 dict[&quot;ABC&quot;] = &quot;Pencil&quot;, dict[&quot;CBA&quot;] = &quot;Sun&quot; 이라고 한다면 6번째 인덱스에는 [&quot;ABC&quot; : &quot;Pencil&quot;, &quot;CBA&quot; : &quot;Sun&quot;] 과 같은 배열이 들어있게 됩니다. 여기서 dict[&quot;CBA&quot;] 를 읽어오려고 한다면, 위의 배열에서 &quot;CBA&quot; 를 검색 해서 “Sun” 을 반환하는 것이죠.하지만 이 경우, 해시 값의 충돌이 빈번하게 발생한다면 해시 테이블의 효율성이 떨어지게 됩니다. 그래서 가능하면 해시 테이블에 충돌이 없도록 해야합니다.해시 테이블은 3가지 요인에 의해 효율성이 정해집니다. 해시 테이블에 얼마나 많은 데이터를 저장하는가 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가 어떤 해시 함수를 사용하는가해시 테이블에 관해서는 더 깊고 자세히 알아볼 수도 있지만, 대부분은 언어 차원에서 기능을 지원하기 때문에 여기서는 원리만 이해해도 괜찮습니다. 해시 테이블은 언어에 따라 해시, 맵, 해시 맵, 딕셔너리(사전), 연관 배열 등으로 불립니다.스택, 큐 스택스택(Stack) 은 배열과 같지만, 다음과 같은 규칙이 존재합니다.스택의 끝에서만 데이터를 읽기, 삽입, 삭제할 수 있다책이 쌓여있는 것을 생각할 수 있습니다. 맨 위의 책의 표지만 볼 수 있고, 맨 위에 책을 올려서 쌓거나(Stack) 맨 위에서 책을 빼갈 수 있기 때문이죠. 여기서 스택의 끝을 탑(top) 이라고 부릅니다. 그리고 스택에 삽입하는 것을 푸시(Push) 한다고 합니다.스택은 LIFO(Last In First Out) 자료구조라고도 불리는데, “마지막에 들어간 게 먼저 나온다” 라는 후입선출의 형태를 가지고 있기 때문입니다.스택은 이렇게만 보면 어디다 쓸지 막막하지만, 실제론 알고리즘에서 자주 활용됩니다. 예를 들어, 괄호쌍이 제대로 이루어져있는지 확인하거나 계산식을 후위형으로 바꾸기도 합니다.괄호쌍을 예로 들면 [(){()}] 이란 괄호쌍이 올바르게 열리고 닫혔나 확인하기 위해서, 문자열의 인덱스 0부터 반복하며 왼쪽 괄호라면 푸시(Push) 하고 오른쪽 괄호라면 팝(Pop) 해주고, 팝해준 괄호가 오른쪽 괄호랑 같은 종류가 맞는지 확인해 주는 방법을 사용할 수 있습니다.이 외에도 실행취소(Ctrl+Z) 나 이전에 방문한 사이트들을 저장하는 일 등에도 스택이 사용됩니다. 큐큐(Queue) 또한 스택과 비슷한데, 이는 FIFO(First In First Out) 이라는 선입선출 형태를 가지고 있습니다. 대기열이라는 뜻을 가진 큐는 큐의 끝에서만 삽입할 수 있고, 큐의 앞에서만 읽고 삭제할 수 있다 라는 규칙을 가지고 있습니다. 큐에 값을 삭제/제거하는것은 언어마다 스택과 같이 Push/Pop 이라고 부르거나 Enqueue/Dequeue 라고 부르기도 하니 용어에 유의해주시기 바랍니다.큐의 맨 앞은 프론트(Front) 라고 부르고, 맨 뒤는 리어(Rear) 라고 부릅니다. 큐는 좀 더 직관적으로 게임에서의 대기열 등 선착순의 개념이 존재하는 알고리즘들에서 사용됩니다.재귀 호출함수는 자기 자신을 호출해서 반복할 수 있습니다. 여기서 함수가 자기 자신을 호출하는 것을 재귀(recursion) 라고 하고, 이런 함수를 재귀 함수라고 합니다.void print_something() { printf(&quot;Hello\\n&quot;); print_something();}위 코드는 &quot;Hello&quot; 라는 문자열을 무한히 반복하며 출력합니다. 왜냐면 print() 함수가 자기 자신을 호출하고 있기 때문이죠. 그럼 자기가 자기를 호출하고… 이렇게 무한 반복이 되는겁니다. 그래서 보통은 반복문을 쓸 때와 비슷하게 나가는 조건과 값을 변화시킬 식을 포함합니다.int fact(int n) { if (n == 1) return 1; return n * fact(n - 1);}위 코드는 팩토리얼(5! = 5*4*3*2*1) 을 계산해주는 재귀함수입니다. 재귀호출을 할 때마다 n이 1씩 감소하고, n이 1이면 더이상 재귀호출을 하지 않아 재귀가 멈추고, 지금까지 계산된 식이 전부 실행되며 결과가 계산되죠. 여기서 재귀 호출을 멈추게 하는 조건을 기저 조건(base case) 라고 하며, 위 코드의 경우 1 이 기저 조건입니다.재귀 함수를 사용해본 적이 없다면 위 코드가 읽기 난해할텐데, 재귀 함수를 쉽게 이해하는 방법이 존재합니다. 기저 조건을 찾는다 기저 조건에 맞을 경우의 함수의 상태를 본다 기저 조건의 바로 전의 함수의 상태를 본다 계속 단계를 올려가며 함수의 상태를 본다위 코드를 예로 들면, n에 1이 들어있을 경우에 함수가 어떻게 되는지 봅니다. 1을 반환하네요. fact(1) = 1 이란 것을 알았습니다. 재귀 호출에서 n - 1 을 넘겨주고 있기 때문에, 다음에는 n이 2인 경우를 봅니다. 2 * fact(1) 인데, fact(1) 은 1이므로 2 * 1 을 계산하여 fact(2) = 2 라는 것을 알 수 있습니다. 다음으로 3을 보면…이렇게 한 단계씩 살펴보면 좀 더 수월하게 재귀함수를 파악할 수 있습니다.여기서 추가적으로 알아야 할 것이 있는데, 바로 호출 스택 이라는 개념입니다. 코드에서 함수를 실행하면, 컴퓨터는 함수를 실행한 지점 등의 정보를 “호출 스택” 에 푸시(Push) 해줍니다. 그 이유는, 함수를 호출했다면 해당 함수가 종료된 후에 다시 함수를 호출한 곳부터 코드를 이어서 실행해야 하기 때문이죠.그래서 fact(3) 를 호출하면 [ fact(3), fact(2), fact(1) ] 와 같이 호출 스택에 들어가게 되고 fact(1) 부터 차례대로 팝(Pop) 하게 됩니다. 그래서 실행한 것의 역순으로 코드가 끝나게 되죠. 여기서 만약에 재귀 호출이 매우 많아져서 메모리에 공간이 부족해지면 스택 오버플로(Stack Overflow) 라는 오류가 발생합니다.자 그럼, 이 재귀함수가 왜 필요할까요? 재귀함수는 하나의 큰 문제를 작은 부분문제 들로 나눌 수 있습니다. 위의 팩토리얼 예제를 보아도 함수가 하나의 팩토리얼을 전부 계산하지 않고 현재 자신 번째의 값만 계산하고, 다음 값의 계산은 재귀호출로 처리하였습니다. 또는, 한 알고리즘에서 같은 알고리즘을 반복해야 하는 경우에도 사용됩니다. 예를 들어, 한 폴더를 지정해서 그 폴더 안의 모든 파일을 출력하는 알고리즘의 경우, 반복문으로는 풀기 힘듭니다.// ...생략for (i = 0; i &amp;lt; dir.count; i++) { printf(dir[i].name); if (dir[i].type == &quot;Folder&quot;) for (j = 0; j &amp;lt; dir[i].count; j++) { printf(dir[i][j].name); // ...중략 }}위는 실제 동작하지는 않는 의사 코드(Pseudo Code) 인데, 만약 보고있는 파일이 폴더라면 그 폴더에 대해 반복문을 추가로 돌아야 하는데, 폴더가 몇 단계까지 되어있는지도 모르고, 그렇다 하더라도 반복문을 계속 이어나갈 수는 없죠. 여기서 재귀 함수를 쓰면 훨씬 간단하게 처리할 수 있습니다.void printFileNames(Directory dir) { for (i = 0; i &amp;lt; dir.count; i++) { printf(dir[i].name); if (dir[i].type == &quot;Folder&quot;) printFileNames(dir[i]); }}읽은 파일 타입이 폴더일 경우, 자기 자신에 해당 파일(폴더)를 매개변수로 넣어 호출해주는 것이죠. 이로 인해 코드도 매우 작고 깔끔해졌습니다. 작동하는 코드가 아니라 작동 방식은 이해하기 힘들어도, 어떤 느낌인지는 파악했다고 생각합니다. 재귀 함수는 알고리즘 풀이에서 기초이자 필수인 부분으로, 꼭 여러 예제와 문제들을 살펴보아 복습하시길 바랍니다.연결 리스트연결 리스트는, 배열과 비슷하지만 내부 기능은 전혀 다른 자료구조입니다. 배열은 한번 선언하면 메모리 내에 연속적으로 존재하게 되어서 처음 인덱스부터 N칸 뒤의 메모리 주소에 접근하는 것으로 O(1) 만에 읽기가 가능하다고 했었습니다. 하지만 연결 리스트는 원소들이 전부 메모리에 따로따로 위치한 자료구조입니다.그럼 어떻게 값들을 저장하는 것일까요? 배열의 각 원소는 저장해야 할 값 뿐만 아니라 다음 원소의 주소 또한 지니고 있습니다. 그래서 만약 인덱스 4의 원소를 읽으려면 인덱스 0부터 시작해서 다음 주소, 다음 주소… 이렇게 0 - 1 - 2 - 3 인덱스를 참조해야 인덱스 4를 읽을 수 있습니다. 이 때 이 연속되게 위치하지 않은 원소들을 노드(Node) 라고 부릅니다.그래서 배열과 비교해서 연결 리스트의 장점은 무엇일까요? 우선 배열의 경우, 원소를 10000개 가지게 선언하려면 원소 10000개 만큼의 연속된 빈 메모리 공간 이 있어야 합니다. 하지만 연결 리스트는 연속되지 않더라도 10000개의 빈 공간만 있어도 되죠. 배열에서 읽기는 O(1)이지만, 연결 리스트에서 읽기는 O(N)입니다. 그래서 읽기를 많이 하는 경우라면, 배열이 더 좋겠죠. 검색은 둘 다 동일하게 O(N)이 걸립니다.하지만 삭제와 삽입의 경우, 배열은 O(N)이지만 연결 리스트는 O(1) 이 걸립니다. 왜냐하면, 배열의 경우 중간에 있는 원소를 삭제하거나 중간에 삽입하려면 원소들을 전부 한 칸씩 밀어주어야 하지만 연결 리스트는 그냥 “A-&amp;gt;B-&amp;gt;C 에서 B를 삭제하려면, A가 C를 가리키게 한다” 고 하면 끝이기 때문이죠. 삽입의 경우에도 “A-&amp;gt;C 사이에 B를 넣으려면 A가 B를 가리키게 만들고, B는 C를 가리키게 만든다” 라고 하면 끝입니다. 물론 삽입하는 공간을 찾기 위해서 O(N) 정도가 소요되기는 하죠.C언어와 포인터를 다루지 않았다면, 이를 직접 구현할 일은 없고 언어에서 지원하는 것을 사용하게 될 겁니다. 직접 구현한다 하더라도, C#과 Java처럼 가비지 컬렉터(Garbage Collector, 안쓰이는 메모리를 자동으로 해제) 가 있지 않다면 수동으로 메모리를 해제해야 한다는 것 또한 까다롭습니다. 그러니까 연결 리스트는 개념만 알아두도록 합시다!여기서 이중 연결 리스트 라는 것도 볼 수 있는데, 이는 노드 하나가 자신의 다음 번째 원소뿐 아니라 자신의 이전 번째 원소의 위치 또한 가지고 있게 하는 것입니다. 그래서 원래는 0번째부터 단방향 이었다면 이중 연결 리스트는 양방향으로 움직일 수 있다는 거죠.결론적으로, 연결 리스트는 “값의 삭제와 삽입이 빈번하게 일어나는 경우” 에 사용된다고 볼 수 있습니다. 적재적소에 필요한 자료구조를 사용하도록 합시다!이진 트리이진 트리(Binary Tree)는 트리(Tree) 자료구조의 한 종류로, 연결 리스트와 비슷하게 각 노드가 여러 노드의 주소를 지니고 있는 자료구조입니다.flowchart TD Food --&amp;gt; Fruit &amp;amp; Meat Fruit --&amp;gt; Apple &amp;amp; Mango Meat --&amp;gt; Beef &amp;amp; Pork이진 트리는 위와 같이 Food가 Fruit과 Meat로, Fruit가 Apple과 Mango로, Meat가 Beef와 Pork로 연결되어 있습니다. 여기서 가장 상위인 노드인 Food를 루트(Root) 라고 부르며, 트리의 꼭대기가 됩니다. 여기서 Food를 Fruit과 Meat의 부모 라고 하고, Fruit과 Meat는 Food의 자식 이라고 합니다. 그리고 트리에는 깊이를 뜻하는 레벨(Level) 이 있는데, 위 트리의 레벨은 3입니다.“트리” 의 경우, 한 노드가 여러 개의 자식을 지닐 수 있지만 이진 트리는 2개 이하로만 자식을 지닐 수 있다는 제약이 존재합니다. 이번 예제에서는 여기에서 더 나아가 “왼쪽은 부모보다 작은 값을 가지고, 오른쪽은 부모보다 큰 값을 가진다” 라는 조건을 더해보겠습니다. 그러면 루트부터 시작해서 원하는 값을 찾을 때, 현재 찾으려는 값이 노드의 값보다 더 크다면 오른쪽 자식으로, 작다면 왼쪽 자식으로 이동하며 이진 검색 과 동일한 구조를 보여줄 수 있죠. 이는 “정렬된 배열에서의 이진 검색” 과 비슷하지만, 연결 리스트와 같이 노드 기반의 자료구조이기 때문에 삽입과 삭제 시에도 O(log N)이 걸린다는 특징이 있습니다. (이를 “이진 검색 트리” 라고 합니다)이진 트리는 검색, 삽입, 삭제에서 모두 O(log N) 이기 때문에 안정적이면서 매우 효율적인 자료구조이고, 그로 인해 힙 트리(Heap) 등 다양한 분류가 존재합니다. 물론 이 외에도 트리 자체가 일상 생활에서 자주 보는 계층 구조를 가지고 있기 때문에 B트리, 레드-블랙 트리 등 다양하니 한번 더 찾아보는 것을 추천합니다!힙힙(Heap)은 완전 이진 트리 로써, 완전 이진 트리란 마지막 레벨의 노드를 제외하면 모두 두 개의 자식 노드가 있고 마지막 레벨에서는 왼쪽부터 차례대로 노드가 있는 트리입니다. 완전 이진 트리는 루트를 1번째부터 시작하면 자식 노드를 i * 2 + 1과 i * 2 + 2번째에 위치시킬 수 있어 배열로 간단하게 구현이 가능합니다. 여기서 힙의 특징은, 최대/최소값이 항상 루트에 존재해야 하고 부모 노드는 자식 노드보다 항상 크거나 작아야 합니다. 이를 각각 최대 힙과 최소 힙이라고 합니다. 힙의 삽입 연산최대 힙을 기준으로 설명하면, 힙의 조건을 만족하기 위해 마지막 노드의 오른쪽에 원소를 삽입한 후에 부모와 값을 비교하여 만약 부모보다 크다면 서로 위치를 교환합니다. 이를 재귀적으로 실행하여 자신의 값이 부모보다 작을 때까지 반복합니다. 힙의 삭제 연산힙에서는 가장 큰 원소만 삭제할 수 있기 때문에 루트 노드를 삭제해야 하는데, 이 후에 힙의 조건을 만족하기 위해 트리의 마지막 노드와 루트 노드를 교환하고, 마지막 노드를 삭제합니다. 그 후에 루트 노드부터 자식 노드들을 비교하며 둘 중 더 큰 노드와 위치를 교환합니다. 이를 재귀적으로 실행하여 루트 노드의 값보다 큰 값이 없을 때까지 반복합니다.힙의 삽입과 삭제는 모두 O(log N) 의 시간이 걸립니다. 여기서 추가로 힙의 초기화 연산에 대해서 알아보도록 하겠습니다. 힙의 초기화힙을 초기화한다고 하면, 원소를 전부 삽입하는 것을 떠오를 수 있습니다. 이는 O(N log N) 의 시간이 걸리는데, 힙 생성 알고리즘을 사용하면 O(N) 시간만에 초기화가 가능합니다. 개념은 간단한데, 트리의 맨 밑부터 완성해 나아가는 방식입니다. 보통 힙을 직접 구현할 일은 없기 때문에 언어 차원에서 지원하는 힙 초기화 알고리즘을 사용하면 됩니다.C++의 경우는 STL의 priority_queue를 사용하면 됩니다.세그먼트 트리아래 글과 같이 그림으로 각 단계별 설명을 보는 것이 나을 것이라 생각하여 링크를 첨부합니다.참고로, N이 입력값이고 H가 트리의 높이일 때 H = log2N이고 배열의 크기이자 노드의 최대개수는 2^H-1 라고 하는데, 문제풀이에서는 N*4 를 트리 배열의 크기로 해도 괜찮습니다. 적당히 비슷하지만 모자라지 않는 값이 나오기 때문이죠.BOJ Book - Segment Tree그래프그래프는 데이터의 연결관계를 나타내는 자료구조입니다.여기서 1, 2, 3 과 같은 각 노드(node)들을 정점이라고 부르고 각 선을 간선(edge) 라고 부릅니다. 여기서 정점은 편의상 노드라고 부르는 경우가 많습니다.그래프는 일반적으로 해시 테이블을 이용해 구현하는데, 예를들어 친구관계를 나타낼 때 다음과 같이 할 수 있습니다.friends[&quot;Tom&quot;] = &quot;Jerry&quot;;friends[&quot;Tom&quot;] = &quot;Clancy&quot;;friends[&quot;Jerry&quot;] = &quot;Tom&quot;;friends[&quot;Clancy&quot;] = &quot;Tom&quot;;하지만 일반적인 알고리즘 문제를 풀 때나, 단순 번호로 각 노드들을 나타낸다면 일반 배열도 사용할 수 있습니다.friends[0] = 1;friends[0] = 2;friends[1] = 0;friends[2] = 0;위와 같이 각 노드들이 전부 서로 연결되어 있는 무방향 그래프도 있지만, A에서 B로 갈 수는 있지만 B에서 A를 갈 수는 없는 그래프도 존재하는데 이걸 방향 그래프 라고 합니다. 또한, 간선마다 가중치(weight) 가 있어서 예를들어 A 도시에서 B로 가는 거리 등을 수치로 나타낸 것을 가중 그래프 라고 합니다.BFSA-B-C-D 로 연결되어 있을때, A와 연결된 모든 정점들을 알려면 어떻게 해야할까요? 이렇게 그래프를 탐색할 일이 많기 때문에 이를 위한 알고리즘이 존재합니다.BFS는 그래프 전체를 탐색하기 위한 방법이며 너비우선탐색(Broad-First-Search) 라고 불립니다. 너비우선탐색이라는 이름이 붙은 이유는 시작한 정점과 이어진 정점을 먼저 탐색하고, 그 다음에는 한 칸 떨어진 정점을 전부 탐색하고, 그 다음에는 두 칸… 이런식으로 거리가 i인 정점을 먼저 전부 방문해야만 거리가 i + 1인 정점을 방문하기 때문입니다. 이를 구현하기 위해 큐(Queue)를 사용하여 자신이 다음에 방문할 정점들을 저장합니다. 가장 가까이 연결된 정점들이 먼저 큐에 저장되고, 먼저 꺼내지기 때문에 가까이 있는 순서대로 방문하게 되는 것이죠.BFS를 구현하기 위해 우선, 시작하고 싶은 정점을 선택하여 큐에 넣습니다. 이 큐는 “앞으로 내가 방문해야 하는 정점들의 목록” 을 방문할 순서대로 넣어두기 위해 사용됩니다.그 후에 큐에서 정점을 꺼내서 해당 정점과 연결된 모든 정점들 중 방문하지 않은 정점들을 전부 큐에 넣고, 해당 정점들을 방문했다고 표시해줍니다. 이 때, 표시를 위해 별도의 배열(자료구조)이 필요합니다. 지금 이 과정을 큐가 완전히 비워질 때까지 반복하면 BFS는 끝이나게 됩니다.queue를 사용하기 위해 C++로 나타낸 코드는 다음과 같습니다.int graph[5][5] = { {1, 0, 1, 1, 0}, {0, 1, 1, 0, 1}, {1, 1, 1, 0, 0}, {1, 0, 0, 1, 0}, {0, 1, 0, 0, 1}};queue&amp;lt;int&amp;gt; q;q.push(0);bool visited[5] = {};while (!q.empty()) { int node = q.front(); q.pop(); visited[node] = true; // 만약 node-&amp;gt;i 의 경로가 있고 i를 방문하지 않았다면 for(int i = 0; i &amp;lt; 5; i++) if (graph[node][i] == 1 &amp;amp;&amp;amp; !visited[i]) q.push(i);}graph는 2차원 배열로, graph[a][b] 는 a에서 b로 연결되어 있는지를 나타냅니다. 1이라면 연결됨, 0이라면 연결 안됨입니다. 그래프 자체는 이 외에도 매우 다양한 방법으로 표현이 가능한데, 동적 배열을 이용해서 자신과 연결된 정점들의 번호만 저장하거나 해시 테이블을 사용하면 메모리를 훨씬 절약할 수 있습니다.DFSDFS는 BFS와 동일하게 그래프를 탐색하기 위한 알고리즘인데, 큐 대신 스택을 쓴다는 점이 다릅니다. 스택을 사용하기 때문에 마지막에 등록된 정점을 먼저 방문하며, 그로 인해 한번 탐색할 때 가능한 깊게 탐색하기 때문에 깊이우선탐색(Depth-First-Search) 라고 합니다. 그 외에는 BFS와 다른 점이 없기 때문에 설명을 생략합니다. 단, 스택을 사용한다는 특성상 DFS는 재귀함수를 사용해서 더 간단하게 코드를 작성할 수 있습니다.void DFS(int index) { cout &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &#39; &#39;; visited[index] = true; for (int i = 0; i &amp;lt; graph[index].size(); i++) if (!visited[graph[index][i]]) DFS(graph[index][i]);}여기서 graph[x] 는 x와 연결된 정점들의 번호를 가지고 있는 배열이며, size() 함수를 사용해 배열의 길이를 알 수 있습니다.만약 재귀함수를 사용하지 않는다면 BFS 예제와 동일하게 구현할 수 있습니다.stack&amp;lt;int&amp;gt; s;s.push(0);bool visited[5] = {};while (!s.empty()) { int node = s.top(); s.pop(); visited[node] = true; for (int i = 0; i &amp;lt; graph[node].size(); i++) if (!visited[graph[node][i]]) s.push(graph[node][i]);}다익스트라 알고리즘데이크스트라 알고리즘 혹은 다익스트라 알고리즘으로 불리는 Dijkstra Algorithm은 음의 가중치가 없는 그래프에서 한 정점부터 다른 모든 정점까지의 최단거리를 구하는 알고리즘입니다. 다음과 단계로 이루어지는데, 방문할 정점 목록에서 정점을 꺼내 현재 정점으로 한다 현재 정점과 인접한 모든 정점에 대해 각 정점이 가지고 있던 최단거리와 현재 정점을 거쳐서 가는 거리를 비교, 갱신한다 방문하지 않은 가장 거리가 짧은 정점을 현재 정점으로 한다위 작업을 반복하면 끝이 나게 됩니다. 시작 정점으로부터 모든 정점의 최단거리를 나타내는 배열과, 각 정점을 방문했는지 확인해주는 배열이 필요합니다. 이 때, 3번 작업을 선형 검색으로 한다면 비효율적이므로, 주로 힙을 사용하게 됩니다.벨만-포드 알고리즘음수 가중치가 있는 그래프는 다익스트라로 정확한 결과를 얻을 수 없습니다. 그래서 사용 되는 것이 벨만-포드(Bellman-Ford) 알고리즘인데, A 정점 -&amp;gt; B 정점의 최단 경로를 구할 때, 모든 간선에 대해 거리가 짧아지는 경우에 최단거리를 갱신하는 방법입니다.플로이드-와샬 알고리즘만약 모든 정점에서 모든 정점으로의 최단 거리를 구하고 싶다면, 플로이드-와샬 알고리즘을 사용합니다. 만약 A번 정점에서 B번 정점으로 가는 거리보다, A번 정점 -&amp;gt; i번 정점 -&amp;gt; B번 정점 을 거쳐가는 거리가 더 짧다면 거리를 갱신해주는 형태로 매우 간단합니다.// V는 정점들의 개수입니다const int MAX = 1e9;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; distance(V, vector&amp;lt;int&amp;gt;(V, MAX));// 그래프 가중치로 초기화for (int i = 0; i &amp;lt; V; i++) { for (int j = 0; j &amp;lt; V; j++) distance[i][j] = graph[i][j]; distance[i][i] = 0;}// 플로이드-와샬for (int mid = 0; mid &amp;lt; V; mid++) for (int start = 0; start &amp;lt; V; start++) for (int end = 0; end &amp;lt; V; end++) if (distance[start][end] &amp;gt; distance[start][mid] + distance[mid][end]) distance[start][end] = distance[start][mid] + distance[mid][end];단, 음수 가중치는 처리하지 못하므로 distance[i][i] 가 음수라면 음수 가중치 사이클이 있는것으로 판단합니다.존슨 알고리즘존슨 알고리즘은 다익스트라 알고리즘과 벨만-포드 알고리즘의 장점을 합한 것으로, 다익스트라 만큼의 시간복잡도를 가지고 있지만 음수 가중치 또한 계산될 수 있습니다. 그 방법은 전체 에지 가중치를 음수가 아닌 형태로 변환하는 것으로, 더미(dummy) 정점을 만들고 이 정점과 나머지 모든 정점 사이에 가중치가 0인 에지를 연결하여 벨만-포드 알고리즘으로 더미 정점과 최단 거리를 찾고, 기록합니다. 그리고 그래프의 최단 거리를 구할 때, 정점의 거리 사이에 아까 구해둔 최단거리를 추가하여 이렇게 만들어진 그래프에 다익스트라 알고리즘을 사용하여 구할 수 있습니다." }, { "title": "퍼즐 디자인", "url": "/posts/puzzle-design/", "categories": "Lecture, Game Dev", "tags": "Game Design", "date": "2022-01-02 12:00:00 +0900", "snippet": "퍼즐 디자인을 하는법 목적이 없는 무작위 규칙으로 시작한다 좋은 퍼즐에서, 행위에는 예상 가능한 결과를 가지고 있다 좋은 퍼즐에서, 규칙은 주로 별로 복잡하지 않다 특정 목적들로 실험을 한다. 반복적으로 규칙을 강화한다 게임 시스템에서 떼기 힘든 요소가 있다면, 그게 바로 목적이다(달성하기 힘든것) 좋은 퍼즐에서, 정답이 되는 행동의 순서를 찾는 것이 도전적이다 플레이어의 측면으로 학습한다. 점진적으로 어려워지는 퍼즐을 만든다 좋은 퍼즐은, 해결하기 위한 모든 정보를 포함한다(숨겨졌어도 찾아낼 수 있어야한다) 좋은 퍼즐은, 필요한 만큼만 복잡하며, 필요한 만큼만 거대하다 퍼즐을 디자인 하는 것 또한 퍼즐이다 좋은 퍼즐은, 플레이어의 예상을 가지고 논다 좋은 퍼즐은, 게임 시스템에 대한 새로운 것을 가르친다 예전 규칙을 완벽히 탐구했다면, 규칙을 확장하라 재정렬하고, 다듬어라. 완벽한 퍼즐이라고 확신할 수 없다좋은 퍼즐을 만드는 법 - GMT메카닉Mechanic모든 퍼즐 게임은 메카닉으로 시작한다. 그 게임이 어떻게 돌아갈지 정하는 탄탄한 룰을 의미한다. 그래서 기본적으로 메카닉이 얼마나 “영리하냐” 에 따라서 전체 퍼즐의 수와 난이도를 정한다.게임에는 또한 목표(Goal)가 존재하는데, 플레이어가 달성하려고 하는 것이 무엇인지 명확해야 한다.캐치Catch문제점/애로점좋은 퍼즐은 [캐치] 를 중심으로 만들어진다. 두 무엇이 언뜻 보기에 서로 직접적인 갈등관계에 있어보이는 논리적 모순을 의미한다. 예제를 들자면, 방에 [발판], [상자], [문] 이 있을때 발판 을 밟으면 문이 열린다. 그럼 발판을 밟고 문으로 나가면 될 것 같지만 발판에서 발을 떼면 문이 닫힌다. 그러니까 “한 가지를 하면 다른 한가지가 불가능하게 되는” 것이다. 그래서 당신은 상자를 발판 위에 올려놓아야 한다.발견Revealation정답을 위한 행동은 매우 간단하고, 수고가 들지 않지만 동시에 매우 어렵기도 하다. 틀 바깥에서 생각하도록 요구하고 게임이 동작하는 방식에 대해 다시 생각하게 하고, 게임의 컨셉을 측면에서 바라보도록 하기 때문이다. 또한 이것은 게임의 룰이 가능하게 하는 뻔하지 않지만 완전히 논리적인 결과를 드러내며 이후에 사용될 수 있는 도구이 된다. 이는 또한 이후에 더 크고 복잡한 퍼즐의 일부로 사용될 수도 있다.그래서, 퍼즐을 푸는 것은 발견을 하는 것과 같다. 룰에 대한 더 깊은 통찰을 얻는 것이다.추정Assumption플레이어는 퍼즐을 관찰하고 추정한다. 주로 가장 간단하게 생각해낼 수 있는 해법을 먼저 생각해낼 것이다. 플레이어가 잘못된 추정을 하도록 퍼즐을 디자인하면 이점들이 있다. 플레이어가 해법을 안다고 생각하게 유도함으로써 플레이어가 새 퍼즐을 시작할 때 압도당하지 않도록 한다 잘못된 추정을 실행하는 도중, 사실 퍼즐이 어떻게 동작하는지 깨닫고 이 수수께끼가 어떻게 만들어졌는지에 대한 정신적 모델을 만들게 된다. 이는 플레이어가 처음에는 퍼즐을 못 풀 것을 거의 보장한다. 플레이어가 퍼즐의 핵심에 집중할 수 있도록 해준다. 예를 들어 아까의 발판 문 퍼즐에서, 퍼즐은 “문으로 어떻게 나가지” 가 아니라, “어떻게 문을 열어두지” 이다.제시Presentation지금까지의 모든 것들은 적절하게 제시하지 않으면 퍼즐이 모두 무너질 수 있다. 이는 퍼즐을 풀기 위해 무엇이 가능한 지 보여주는 것을 의미한다. 예를 들어, 아까의 발판 문 퍼즐에서 발판과 상자가 2개라고 했을 때, 상자를 아무데나 던져놓을 수도 있지만, 상자 하나를 발판 위에 올려놓으면 “상자로 발판을 누를 수 있다” 를 제시할 수 있다. 이런 메카닉의 제시 외에도 복잡한 퍼즐의 경우는 퍼즐의 해결방법에 대한 제시 또한 가능하다.좋은 퍼즐은 꽤 미니멀리스트하여, 관련없는 요소는 거의 없다. 최고의 퍼즐이란 단지 몇개의 움직일 수 있는 요소만 있어서 플레이어가 가장 간단하게 퍼즐을 이해할 수 있도록 하는 것이다. 퍼즐의 제시 방법은 또한 명확한 피드백을 주어야 한다. 어떤 행위가 어떤 결과를 일으키는지를 추정할 수 있게 해야하기 때문이다.커브Curve그 어떤 퍼즐도 홀로 플레이어에게 주어지지 않는다. 이전에 있었던 퍼즐 위에 만들어지도록 구성된다. 퍼즐은 진행하며 배운 모든 요소를 사용하고, 퍼즐은 하나씩 점점 난이도를 높여가야 하기 때문이다.Square Enix Montreal에서 정의한 퍼즐의 난이도의 4가지 기준이 있다. 해답의 갯수가 많을수록 퍼즐이 쉬워진다 해결까지 필요한 단계 수가 높을수록 더 어렵지만, 너무 높으면 지루하다 매 순간에 플레이어에게 주어지는 선택지의 개수 플레이어가 어떤 메카닉들에 미리 친숙해져 있어야 하는지마무리좋은 퍼즐은 게임의 룰에 의해 파생되며, 첫 눈에 불가능해 보이는 캐치가 있다. 개발자는 플레이어의 추정을 예측하여 캐치에 다다르도록 유도할 수 있다. 캐치를 극복하고 갈등을 해소하려면, 최고의 퍼즐은 플레이어에게 수평적(측면적) 사고Lateral Thinking와 게임 룰에 숨겨진 지식을 밝혀내기를 요구한다. 모든 퍼즐이 이렇지 않지만, 잘 만들어진 퍼즐에는 이런 요소들을 발견할 수 있다. 잘 만들어지지 못한다면 갈등이 너무 쉽게 풀리거나, 추정 단계가 없어서 수직적 사고Vertical Thinking로 해법으로 바로 다가가거나, 충분한 제시가 없어서 그저 귀찮게 느껴지게 되어 있을 수 있다." }, { "title": "[BOJ] 2494 숫자 맞추기", "url": "/posts/BOJ-2494/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2021-12-27 17:15:00 +0900", "snippet": "KOI 2009 E5/M3 우선 이 문제는 완전탐색으로 구현할 줄 알아야 합니다. 문제에서 한 숫자나사의 회전을 할 때 무조건 왼쪽 혹은 오른쪽 방향으로만 움직일 수 있기 때문에 왼쪽으로 돌리는 경우와 오른쪽으로 돌리는 경우 두가지로 간단하게 구현할 수 있습니다. 완전탐색으로 구현을 하였다면, 이제 시간 초과를 해결하기 위해 동적 계획법(DP)를 사용해야합니다. 이 문제는 동적 계획법을 이용한 최적해와 그 최적해의 추적 문제입니다. 이 문제를 작은 부분 문제로 나누자면, 제일 위쪽 숫자나사부터 시작해서 왼쪽 혹은 오른쪽으로 회전하여서 원하는 상태가 되게 했을 때, 둘 중 더 총 회전횟수가 적은 것을 기억하게 해야하는 하향식 DP입니다.이 때, dp[idx][pos] 는 idx번째의 숫자나사가 pos면을 바라보고 있을 때 최적해 라고 나타낼 수 있습니다. 이 방식대로 DP를 진행하는데, 역추적을 위해 최적해가 결정되었을 때 현재 나사를 어느 방향으로 얼만큼 돌렸는가를 기억해야 합니다. 그러면 탐색이 종료된 후에 첫번째 나사부터 출력을 할 때 얼마나 돌렸는지를 출력하고, 왼쪽으로 돌려진 횟수를 누적해서 다음 나사도 회전시키면 되기 때문이죠.#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int N;vector&amp;lt;int&amp;gt; curr, dest;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dp;int search(int idx, int offset) { if (idx == N) return 0; int pos = (curr[idx] + offset) % 10; int&amp;amp; ret = dp[idx][pos].first; if (ret) return ret; int left = (dest[idx] - pos + 10) % 10; int right = 10 - left; int L = search(idx + 1, (offset + left) % 10) + left; int R = search(idx + 1, offset) + right; if (L &amp;lt; R) { ret = L; dp[idx][pos].second = left; } else { ret = R; dp[idx][pos].second = -right; } return ret;}int main() { cin &amp;gt;&amp;gt; N; string a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; curr.resize(N); dest.resize(N); dp.resize(N, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;(10)); for (int i = 0; i &amp;lt; N; i++) { curr[i] = a[i] - &#39;0&#39;; dest[i] = b[i] - &#39;0&#39;; } cout &amp;lt;&amp;lt; search(0, 0) &amp;lt;&amp;lt; endl; int offset = 0, pos = curr[0]; for (int i = 0; i &amp;lt; N; i++) { cout &amp;lt;&amp;lt; i + 1 &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; dp[i][pos].second &amp;lt;&amp;lt; endl; if (dp[i][pos].second &amp;gt; 0) offset = (offset + dp[i][pos].second) % 10; pos = (curr[(i + 1) % N] + offset) % 10; } return 0;}" }, { "title": "게임 디자인", "url": "/posts/game-design/", "categories": "Lecture, Game Dev", "tags": "Game Design", "date": "2021-11-29 12:00:00 +0900", "snippet": "게임의 구조게임의 요소에는 플레이어, 목표, 진행 방법, 규칙, 리소스(자원), 갈등, 경계(현실과 가상), 결과가 있으며 이것들은 ‘형식적 요소’ 라고 한다.게임에 플레이어를 참여시키기 위해서는 도전, 플레이, 전제, 캐릭터, 스토리가 있어야 하고 이것들은 ‘극적 요소’ 라고 한다.크리스 크로포드의 상호작용 정도에 따른 놀이 활동 분류 게임: 한 플레이어가 이기는 것이 목표인 규칙 기반 시스템 퍼즐: 게임처럼 규칙 기반 시스템이지만, 목표는 상대를 이기는 것이 아니라 해법을 찾는 것이며 다시 플레이 할 가치가 없다 장난감: 퍼즐처럼 조작할 수 있지만, 정해진 목표가 없다 스토리: 장난감처럼 상상을 바탕으로 한 놀이지만, 플레이어가 바꾸거나 조작할 수 없다형식적 요소플레이어 플레이어 수 : 인원에 따라 게임에서 고려할 것이 다르다 (유동적인가? 고정적인가?) 플레이어의 역할 : 보통 한가지지만, RPG에 나뉘는 직업군과 같이 여러개중 선택할 수도 있다. 성취가형, 탐험가형, 사교가형, 킬러형으로 나뉘기도 한다. 플레이어 상호작용 패턴 : 일인 플레이어 대 게임 시스템 멀티 플레이어 대 게임 시스템 플레이어 대 플레이어 일대다 대결 다자간 대결(개인전) 협력적 플레이 팀 대결 목표성취하려고 노력하는 대상. 게임 규칙 하에 플레이어가 무엇을 성취할지 정의. 어렵지만 성취할 만해 보이는 게 최선. 목표는 게임의 분위기를 결정한다. 목표의 분류(중 10가지) 획득 : 붙잡히거나 죽임을 당하지 않고 상대의 물건을 빼앗거나 파괴하는 것 추격 : 상대를 붙잡거나 상대를 피해 달아나는 것 레이싱 : 물리적이든 개념적이든 다른 플레이어보다 먼저 목표에 도달하는 것 정렬 : 게임 피스(piece)를 공간적으로 구성하거나 분류에 따라 개념적으로 정렬하는 것 (오목 등) 구출/탈출 : 정해진 유닛을 안전하게 만드는 것 (슈퍼마리오 등) 금지된 행동 : 상대방이 규칙을 어기게 만드는 것. 보통 디지털 게임에는 없다 건설 : 어떤 것을 구축-유지-관리 하는것. 직접적으로 대결하거나 간접적으로 경쟁할 수도 있다 탐험 : 게임 영역을 탐험하는 것. 대부분 더 경쟁적인 목표와 결합된다 해결 : 문제나 퍼즐을 경쟁자보다 빨리 또는 더 정확하게 푸는 것 지식: 지식을 얻고 사용하여 다른 플레이어를 이기는 것 대부분 목표는 혼합되며, 이 목표들은 참고용일 뿐 완벽한 분류가 아니며 이 외에도 더 있다진행 방법플레이하는 방법이자 플레이어가 게임 목표를 달성하기 위해 취할 수 있는 행동 시작 행동: 게임을 시작하는 방법 진행 행동: 시작 행동 후 사용하는 진행 방법 특수 행동: 다른 요소나 게임 상태에 따라 사용 가능 여부가 결정되는 행동 종료 행동: 게임플레이를 종료하는 행동규칙게임 개체와 플레이어가 할 수 있는 행동을 정의하는 것 개체와 개념을 정의하는 규칙 행동을 제한하는 규칙 : 게임 시스템의 허점을 보완해주기도 함 결과를 결정하는 규칙규칙은 플레이어가 분명히 이해할 수 있도록 명시하거나, 플레이어 대신 프로그램이 판단하는 경우 게임이 공정하다고 생각되도록 직관적으로 규칙을 파악할 수 있어야 한다.리소스어떤 목적을 이루기 위해 사용할 수 있는 자산. 유용성과 희소성이 필요하다. 생명 유닛 체력 화폐(게임 머니) 행동 파워업 인벤토리 특별 구역 시간갈등플레이어와 게임시스템, 혹은 플레이어-플레이어 간의 갈등으로 플레이를 하며 겪는 난관이다. 장애물 경쟁 상대 딜레마 : 플레이어의 선택을 기반으로 한 것. 고민하는 것.경계게임과 게임이 아닌 모든 것을 구분한다.결과플레이어가 계속 주의를 기울이게 만드려면 게임 결과가 불확실해야 한다. 일반적으로 불확실성은 측정 가능하고 차등적인 결과가 나오면서 해도되지만, 항상 그럴 필요는 없다.극적 요소플레이어가 게임 경험에 감정적으로 반응하고 원하는 결과를 얻으려 노력하게 만드는 요소이다. 시스템의 형식적 요소를 의미 있는 경험으로 바꾸어 게임플레이에 맥락을 부여한다.도전완수하는 것이 만족스럽고, 성취감과 즐거움을 느끼기에 적당한 수고가 요구되는 과제를 말한다.도전은 개인차가 있으며 변동적이어서(처음에 어려운 과제도 달성하면 쉬워진다) 게임은 고정되면 안된다. 그래서 개개인의 경험과 무관하게 도전을 살펴볼 수 있는 방법을 얻기 위해 심리학자 미하이 칙센트미하이가 연구한 “활동이 즐거우려면 필요한 조건” 은 다음과 같다. 보통 완수할 가능성이 있는 과제에 직면할 때 발생한다. 하고 있는 일에 집중할 수 있어야 한다. 과제의 목표가 분명하다. 즉각적인 피드백을 받을 수 있다. 일상의 근심 걱정이나 좌절에서 벗어나 깊이 그리고 별 다른 노력 없이 할 수 있다. 즐거운 경험은 자신의 행동을 스스로 통제한다는 느낌을 준다. 스스로에 대한 생각을 잊는다. 역설적이게, 몰입 경험 이후에는 자아감이 더 강해진다. 시간 흐름에 대한 느낌이 달라진다. 상대적으로 빠르게/느리게 느낀다.이 모든 요소의 조합은 깊은 즐거움과 매우 충만한 느낌을 주기 때문에 사람들은 이런 느낌을 얻기 위해 많은 에너지를 쏟을 가치가 있다고 생각한다. 기술을 요구하는 까다로운 활동많은 책에서 기술되었지만, 몰입은 “목표 지향적이고 규칙의 제약을 받으며, 적절한 기술이 있어야 완수할 수 있는 활동을 할 때” 가장 잘 발생한다. 행동과 인식의 결합“어떤 상황의 도전 과제를 해결하기 위해 자신이 가진 모든 관련 기술이 필요할 때 그 사람의 주의는 그 활동에 완전히 흡수된다” 또한, “사람들은 하고 있는 일에 너무나 몰입한 나머지 그 활동을 자연스럽게, 거의 자동으로 하게 된다. 사람들은 자신이 하고 있는 일과 스스로를 분리해서 인식하지 않는다.” 분명한 목표와 피드백무엇을 해야 하는지 명확히 알고, 목표를 얼마나 잘 달성하고 있는지 즉각적인 피드백이 필요하다. 눈앞의 과제에 집중하기몰입 상태에서는 눈 앞의 상황과 관련된 것만 인식한다. 일상의 다른 문제는 잊는다. 통제의 역설사람들은 어려운 상황에서 자신이 통제력을 발휘하는 느낌을 좋아한다. 그러나 어떤 결과가 나올지 모른다면 실제로 상황을 완전히 통제하지 못한다는 의미이며 자신이 통제한다는 느낌도 경험할 수 없다. “결과가 불확실한 상황에서 그 결과에 자신이 영향을 미칠 수 있을 때만 정말 통제하고 있다고 생각한다.” 자의식의 상실몰입 상태에서는 자아를 지키는 데 신경 쓸 여지가 없다. 또한 역설적으로 자아는 자아를 잊어버리는 행동을 통해 확장한다. 시간의 왜곡시간이 빠르게 지나가는 듯한 경험을 의미한다. 경험은 그 자체로 목적이 된다조건들 대부분이 충족되면 경험을 만드는 것이 무엇이든 즐기기 시작하며 활동 자체가 목적이 된다. 보통 일은 외재적 동기로 하지만 몰입하면 내재적 동기와 동화한다.” 목표지향적이고 규칙에 기반하며 명백한 초점과 피드백이 있는 활동 “플레이다소 엄격한 구조 안에서 움직일 수 있는 자유. 플레이의 성질놀이에는 많은 측면이 있으며 사회학자 로제 카이와는 놀이 활동을 6가지 기본 유형으로 분리하였다. 경쟁 놀이, 아곤(agôn) 운에 기반한 놀이, 알레아(alea) 역할 놀이, 미미크리(mimicry) 현기증 놀이, 일링크스(ilinx) 규칙에 바탕을 둔 놀이, 루더스(ludus) 자유로운 형태의 즉흥적인 놀이, 파이디아(paidia) 플레이어 유형※ 모든 유형이 있는 것은 아니다 경쟁자형게임의 종류와 상관없이 다른 플레이어를 이기려고 플레이 탐험가형세상에 대한 호기심이 많고 모험을 좋아함. 물리적이든 정신적이든 경계 밖을 탐구 수집가형아이템, 트로피, 지식 등을 획득. 컬렉션 만들기를 좋아함 성취가형다양한 수준의 성취를 위해 플레이. 단계와 레벨에서 동기부여를 받음 재담꾼형게임을 진지하게 대하지 않으며 재미를 추구함. 진지한 플레이어가 짜증날 수 있지만 게임을 경쟁적이기보다 사회적으로 할 수 있음 아티스트형창의력, 창조, 디자인 때문에 플레이 디렉터형무언가를 책임지고 플레이를 이끄는 것을 좋아함 스토리텔러형환상과 상상의 세계를 만들거나 이런 세계에서 지내는 것을 좋아함 공연가형다른 사람들에게 구경거리를 보여주는 것을 좋아함 공예가형뭔가를 만들고 가공하고 짜맞추는 것을 좋아함 참여 수준플레이어가 경기를 지켜보는 구경꾼이 되는 것 부터, 실제로 선수가 되어 플레이 할 수도 있다.전제배경 또는 비유 안에서 게임의 작동을 설명하며 설정한다.예를 들어 데이터 세트가 있고 다른 데이터 세트들과 상대하여 자신의 데이터가 분석에서 이기면 승리하는 게임이 있다고 하면 엄청 지루할 것이지만, 이것은 실제 게임을 형식적으로 관찰하면 이렇다. (RPG 게임 등)스토리와 세계관을 포함하는 상위 개념으로써 존재 하는것이 전제이다.캐릭터행위자이며, 플레이어는 캐릭터와 자신을 동일시하면서 이야기 속의 사건을 내면화하고 결말로 진행되는 과정에 공감한다.캐릭터를 이해하는 방식은 여러가지가 있는데, 캐릭터를 관객의 공포와 욕망을 비춰주는 거울로 보는 것과, 상징이나 종교같은 더 큰 개념을 나타낼 수도 있고 국가, 인종, 성별과 같이 특정 집단을 표현할 수도 있다.캐릭터의 특징이 잘 정의되어 현실에 있음직한 성격이거나, 스토리가 전개되는 동안 성격 면에서 중대한 변화를 겪는다면 ‘입체적’ 캐릭터라 할 수 있고, 특징이 별로 없고 피상적인 성격을 가진 캐릭터는 ‘평면적’ 캐릭터로 간주된다.캐릭터가 너무 복잡하거나 스토리에 제대로 표현되었는지 확인하고 싶을 때는 4가지의 질문을 이용하면 된다. 이 캐릭터는 무엇을 원하는가? 이 캐릭터에게는 무엇이 필요한가? 관객/플레이어는 무엇을 바라는가? 관객/플레이어는 무엇을 두려워하는가?스토리스토리의 결말도 불확실해야 하며, 게임과 다른 매체와의 차이점은 게임은 플레이어가 스토리를 진행하기 때문에 플레이어가 영향을 주게 할 수도 있다는 것이다.세계 구축보통 지도와 역사부터 시작해서 거주자, 언어, 신화, 정부, 정치, 경제 등에 대한 완전한 문화적 연구까지 포함될 수 있다.서사 구조서사 곡선, 감정 곡선이 스토리에도 존재하며 발단-전개-절정-하강-결말 의 구조로 기승전결이 주로 이루어진다. 감정을 어떻게 다룰지에 따라 스토리도 변화한다.시스템 역학시스템은 공통의 목표나 목적이 있는 요소들이 상호작용하며 통합된 전체를 이루는 집합으로 정의된다. 시스템의 기본 요소는 개체, 속성, 행동, 관계이며 각 요소들은 서로 상호작용하고 시스템 상태를 변화시킨다.[개체] : 시스템의 기본 구성 요소, Unity의 경우 게임 오브젝트[속성] : 물리적 또는 개념적 측면을 정의하는 성질이나 특징. 일반적으로 개체를 설명하는 값의 집합이다.[행동] : 주어진 상태에서 어떤 개체가 취할 수 있는 행동[관계] : 디자인에서 핵심 개념으로, 이 요소가 없으면 시스템이 아니라 컬렉션일 뿐이다. 예를들어 1부터 12까지 적힌 카드에서 ‘3’ 카드를 없애면 시스템 역학이 변한다.위의 요소중 단 하나라도 고립된 상태로 작동하지 않고, 시스템의 기능이나 관계에 영향을 주지 않고 요소들을 제거할 수 있다면 시스템이 아니라 컬렉션이다.재미와 이용의 용이성게임에서 재미의 요소를 고려하자면 다음같은 것들이 있다. 환상의 세계 체험대부분의 사람들은 자신이 아닌 다른 누군가가 되기를 꿈꾼다. 환상을 실현시켜라. 소셜 상호작용사람들은 다른 사람과 상호작용 하는 것을 좋아한다. 탐색과 발견미지의 세계로 뛰어들어 뭔가를 발견하는 것은 매우 흥미진진하다. 실제로 탐험을 해보며 어떻게 플레이어가 그 감정을 느낄 수 있는지 생각해보라. 수집플레이어를 몰입시키게 하기 위해서는 뭔가를 모으게 해라. 자극감각과 상상력을 자극하는 게임은 성공한다. VR게임같은 것이 있다. 하프라이프: 알릭스에서의 VR 컨트롤러에 진동은 실제 물체를 만지는 것 같은 느낌을 주었다. 개잘만들었다. 사서 하자. 자기 표현과 성과인간에게는 자신을 표현하고자 하는 욕구가 있다. 이를 캐릭터의 형태로 주로 표현한다. 건설/파괴건설은 플레이어가 열심히 게임을 플레이하게 만드는 뛰어난 도구다. 하지만 파괴도 좋아한다. 게임 프로토타입 기초 단계게임의 기본 아이디어가 재미있는지이다. 시스템의 핵심이 좋은 기초가 될 수 있다면 된다. 직접 플레이해보고 직관을 확인해라. 구조 단계이제 그 재미로 게임을 만들 수 있는지 확인한다. 기초가 탄탄한지, 플레이어의 경험에 시작, 중간 끝이 있는지, 플레이어가 목표에 도달할 수 있는지… 형식적 세부 사항 단계: 작동성, 완전성, 균형 작동성: 게임이 작동하는가?게임이 작동하지 않으면 완전성은 생각조차 하지 마라. 작동한다는 말은 그 게임을 전혀 모르는 사람이 게임을 할 수 있을 정도로 시스템이 구축되었다는 의미다. 이 말은 테스터가 게임과 상호작용할 수 있다는 뜻이다.완전성: 게임이 내부적으로 완전한가?작동은 하지만 불완전한 부분들이 존재한다. 예를 들어 게임의 이동과 공격 기능 등을 만들었는데 클리어 조건이 없다는 간단한 것 부터 플레이어가 시스템의 허점을 이용할 수 있는 것도 있다. 그렇기에 게임의 규칙들을 전부 문서로 작성하고, 빈틈을 해결해서 규칙을 완전하게 만들어야 한다.중요한 점으로, 탄막 게임에서 “무적 자리” 같은게 존재한다면 플레이어는 그곳을 이용하게 될 것이다. 이는 PVP 게임에서 핵을 사용하는 것과 비슷하다고 할 수 있다.균형: 게임의 균형이 잡혔는가?게임이 디자이너가 정한 플레이어 경험의 목표를 충족시키도록 만드는 과정이다. 디자이너가 의도한 가능성과 복잡도가 시스템에 구현되어 있고 원하지 않는 결과가 발생하지 않고 시스템 요소가 함께 잘 작동하는 것이다. 멀티플레이어 게임의 경우 시작 포지션과 플레이가 공평하고, 어떤 전략이 다른 전략보다 압도적으로 우세하지 않는다는 의미이고, 1인용 게임에서는 타깃 플레이어에게 맞게 레벨의 난이도가 적절히 조절되었다는 의미이다. 그래서 밸런싱의 네 가지 영역은 변수, 힘, 시작 포지션, 게임 실력으로 볼 수 있다.3가지 요소가 만족되었다면 개선 단계에서 처음의 게임의 재미가 남아있는지, 쉽게 할 수 있는지 등을 개선한다.Interactive Design: 상호작용하는 대화형 메카닉스게임에서는 조작-액션-리액션 이 존재하는데, 슈퍼마리오를 예시로 들자면 WASD 이동, 스페이스 바 점프, 쉬프트 달리기와 같은 간단한 조작에서 { 이동, 점프, 달리기, 달리기 점프, 웅크리기 } 등의 여러가지 복잡한 액션이 구현될 수 있고, 이 액션에 대한 리액션으로 { 블럭 밀기, 블럭 깨기, 블럭에 오르기, 블럭에 뛰어넘기, 블럭에서 떨어지기, 토관에 들어가기, 아이템을 꺼내기, 적을 뛰어넘기, 적을 밟기 } 와 같은 매우 다양한 상호작용이 존재하며, 이는 자유도의 척도가 될수도 있다. 액션에 대한 리액션(피드백)이 많기 때문에 여러가지 동작을 시도해보고 싶어지는 것이다. 리듬게임같은 사운드 게임에서는 조작-액션-리액션이 모두 매우 단순하고 명확하므로 자유도는 낮지만 목적이 그만큼 단순해서 단순히 반사 신경과 리듬감을 즐길 수 있다.하지만 단순히 많은 액션과 리액션이 존재한다고 플레이어가 이를 전부 사용하지는 않으며, 동작을 유도하기 위한 장치가 필요하다. 슈퍼 마리오의 경우에는 플레이어에게 동기를 이끌어내는 게임의 후크 (플레이어의 흥미를 끄는 미끼, 어포던스) 가 있기 때문인데, 예를 들어 기본 마리오가 블럭에 머리를 박치면 블록이 살짝 위로 밀려 올라가는데, 이로 인해 무언가 상호작용이 있다는 것을 암시할 수 있습니다. 또한 이 후크들은 연쇄되어 있을수록 좋은데, 블럭에는 스타(무적아이템)이 숨겨져 있기도 해서 이를 얻기 위한 후크가 될 수 있다.아무리 섬세하게 구현된 게임이라도 항사 얼마간의 긴장감이 없으면 플레이어는 ‘단순 작업을 반복하는 느낌’을 강하게 받는다. 적절한 긴장감을 유지하면서도 플레이어에게 플레이하기 쉬운 액션을 제공하는 것이 ‘섬세한 플레이어 액션’을 지탱한다." }, { "title": "게임 기획과 UX", "url": "/posts/ux-and-game-design/", "categories": "Lecture, Game Dev", "tags": "Game Design", "date": "2021-11-09 12:00:00 +0900", "snippet": " 글을 읽기 미리 앞서 UX/UI 가 아님을 유의하라. 필자는 UI와 UX를 분리하여 보아야 한다고 생각하며, UX는 게임의 모든 요소에 적용되어야 한다고 생각한다.게임 기획과 인지심리학 : 지각, 기억, 주의, 동기, 정서정보 ‘처리’ 와 학습은 자극에 대한 지각으로 시작해 궁극적으로는 시냅스 변경, 즉 기억에서의 변경으로 끝이 난다. 자극에 온전히 투입되는 주의 리소스 수준은 해당 자극에 대한 기억의 강도를 결정한다. 두 가지 다른 주요 요소, 즉 동기와 정서도 학습의 질에 영향을 미친다. 마지막으로 학습 원리를 적용하면 전체 ‘과정’ 을 향상시킬 수 있다.지각무언가를 인지하는 과정이다. 베버-페히너 편향: 두가지 자극의 차이를 인지하려면 적당한 상대역이 존재해야 하며, 이는 자극의 강도가 강할수록 인지하기 힘들다. 예를들어 1.1kg와 1.2kg의 물건을 양손에 올리면 무게의 차이를 인지하기 쉽지만 11kg와 12kg의 무게의 차이는 더 인지하기 힘들다. 게슈탈트 원리: 전경/배경(전경과 배경을 식별함), 다안정성(모호성이 있는 것을 보고 양쪽으로 인식가능함), 폐쇄성(분리된 조각이 아닌 전체 사물을 보는 경향, 열린 형태를 닫으려는 경향이 있음), 대칭(대칭을 기반으로 입력을 체계화함), 유사성(같은 특성을 가진 요소들을 한데 묶는 것), 근접(서로 가까운 요소를 같은 그룹으로 지각하는 것) 기억감각 기억, 작업 기억, 장기 기억 이 있으며 감각 기억은 1초 내외의 짧은 시간동안 감각적으로 기억하는 것이고, 작업 기억은 30초 정도 기억할 수 있으며 약 4가지 정도를 동시에 수행할 수 있는 연산하는 기억이기도 하다. 단기기억과 약간 다름. 장기 기억 반영구적으로 기억하는 것. 하지만 이것은 변질될 수 있다.기억의 망각 곡선은 20분이면 60%를 잊어버릴 정도기 때문에 반복적으로 지각시켜주어야 하고 지각이 반복될수록 점진적으로 반복의 간격도 넓어져도 된다.주의플레이어는 무언가 집중을 해야 그것의 기억의 강도가 강해지는데, 이때 뇌가 주의를 기울일 수 있는 자원(리소스)는 한정적이고, 멀티태스킹을 할수록 그 효율이 떨어지는데 여러가지 작업들을 동시에 처리할 때 그 작업들을 관리하는 데에도 리소스가 사용되기 때문이다. 또한, 주의는 처리할 특정할 입력을 선택하고 나머지는 걸러내는 성질이 있으며 이는 부주의맹을 일으킬 수 있다. 즉, 분명히 지각의 영역 안에 들어와 있음에도 주의 밖이면 인식하지 못할 수 있다.동기무언가 하기 위해서는 동기가 필요하며, 이 동기가 최고 수준에 이르는 몰입 단계가 이루어지려면 너무 쉽지도, 어렵지도 않은 과제가 필요하다. 또한, 동기는 4가지로 조정할 수 있는데 정적 강화: 보상을 주면 행동 빈도의 증가를 유도 부적 강화: 처벌을 철회하면 행동 빈도의 증가를 유도 정적 처벌: 부정적인 처벌을 주어 행동 빈도의 감소를 유도 부적 처벌: 긍정적인 것을 제거하는 방식으로 행동 빈도의 감소를 유도할 수도 있음또한, 이전에 강화되었던 행동이 더이상 강화되지 않으면 행동 빈도는 감소하며 변동 비율은 행동 유도에 가장 효율적이다. (무작위 수의 반응 후 무작위의 보상)정서감정과 비슷하지만 상황과 상관 없이 좀더 원초적인 단계에서 발생한다(가짜 거미를 봐도 일단 회피한다) 불공평한 감정은 가능한 회피하여야 한다. 유저의 정서에 따라 잘못된 귀인을 할 수 있으며, 로딩이 느리다는 등의 이유로 게임플레이 전체가 나쁜 것 처럼 느껴질 수 있다.학습 원리 플레이어에게 적절히 보상하라 플레이어가 새 메커니즘을 학습할 때에는 처벌을 피하라 인지과학의 지식으로 인간의 능력과 한계(지각,주의,기억,동기,정서)를 고려한 학습 환경을 조성하라 플레이어가 상황에서 목적을 갖고 실전을 통해 배우게 해라 플레이어에게 가르쳐야 하는 중요한 요소는 깊게 처리해라. 깊게 처리될수록 학습이 깊게 된다(머리를 쓰고 노력을 요하는 과제일수록 더 확실히 학습됨)마크 르블랑의 게임쾌락 분류감각(sensation)감각의 쾌감은 오감으로 느끼는 것들주로 미적 요소가 영향을 미치며, 이런 쾌감은 형편 없는 게임을 좋게 만들어주지는 못하지만, 종종 좋은 게임을 더 낫게 만들어줄 수 있다.판타지(fantasy)공상의 세계, 그리고 자신을 자신이 아닌 다른 무언가로 상상하는 것서사(narrative)선형적인 이야기가 아니라, 일련의 사건이 벌어지는 극적인 전개, 스토리와 연출도전(challenge)모든 게임에는 본질적으로 해결해야 할 문제가 있으며 도전과 리스크를 통해 재미를 느끼게 된다친교(fellowship)우정, 협력, 커뮤니티 등에서 얻을 수 있는 모든 종류의 즐거움때로는 게임과 상관 없이 이것이 게임을 하는 가장 큰 요인이자 원인이 될 수 있으며, 플레이어가 게임을 오래 즐길 수 있게 해주는 요인이기도 하다발견(discovery)새로운 것을 발견하는 것. 탐험하는 것이나 전략을 수립하는 것 등의 모든 종류의 발견이다이 또한 도전과 같이 게임 플레이의 핵심으로 볼 수 있으며, 학습하는 재미이다표현(expression)스스로를 표현하는 쾌락과 무언가를 창조하는 쾌락자신의 캐릭터를 커스터마이징하거나 레벨 에디터로 자신만의 맵을 만드는 등의 것복종(submission)현실 세계를 떠나서 새롭고 더 재미있는 규칙과 목적이 있는 가상의 세계로 들어가는 것게임에만 존재하는 규칙에 복종하여 얻는 재미이다. 보드게임을 생각해 보면 원하는 행동으로 원하는 결과를 내는 것이 아닌, 게임의 규칙에 따라 이기기 위해 가장 좋은 선택을 해야하기도 한다닐슨 노르만의 10가지 사용자 휴리스틱 - 사용성을 평가할 수 있는 척도 시스템 상태의 가시성: 시스템은 수행할 수 있는 행위에 대한 정보를 사용자에게 전달해야 하고, 사용자가 상호작용을 한 후에는 신속하고 적절한 피드백도 있어야 한다. 시스템과 현실 세계와의 일치: 시스템은 타깃 고객에게 익숙한 언어와 개념을 갖고 소통해야 한다. 또한, 현실 세계에 대한 메타포(은유)나 유추도 사용해야 한다. 예를 들어 배낭으로서 구현한 인벤토리는 친숙한 메타포이다. 사용자 통제와 자유: 사용자는 실수를 하거나 생각을 바꿀 수도 있다. 쇼핑을 할 때 사고 싶은 것을 추가한 후 삭제를 편하게 하는것 등이 해당된다. 일관성 및 표준: 플랫폼 관례에 따르는 것은 중요하다. 익숙한 단어, 아이콘, 액션 등은 사용자가 시스템의 작동 방식을 이해하는 데 도움이 되기 때문이다. 오류 방지: 시스템은 사용자 오류가 발생하지 않는 방식으로 설계되어야 한다. 예를 들어 사용자가 변경을 저장하지 않고 파일을 닫는 등의 잠재적 위험이 있는 작업을 완료하기 전에 시스템에서는 확인을 요청해야 한다. 재인(recognition) 보다는 회상: 사용자의 기억 부하를 최소화하기 위해 개체, 동작, 옵션을 볼 수 있게 만드는 것은 중요하다. 사용자가 대화를 하다가 다른 쪽 이야기를 억지로 기억하게 해서는 안 된다. 사용자는 웹이나 앱 등에서 자신의 현재 위치를 추적할 수 있어야 하는데, 이를 브레드크럼 트레일(breadcrumb trail), 주로 “이동 경로” 라고 한다. 예를 들어 컨트롤러의 전체 이미지와 함께 특정 상황에서 사용자가 눌러야 하는 버튼을 밝게 표시하면 플레이어가 버튼의 위치를 떠올릴 필요가 없기 때문이다. 사용의 유연성 및 효율성: 사용자가 인터페이스에 옵션을 더하거나 없애 커스트마이징하여 자신의 경험을 재단할 가능성을 기꺼이 제공하라. 게임에서 커스텀 키매핑을 지원하는 것 등이 속한다. 미적이고 미니멀리스트에 입각한 디자인: 정신을 산만하게 하고 관계 없는 모든 정보를 없애라. 구글의 기본 탭은 이를 잘 구현한 훌륭한 사례이다. 사용자가 오류를 인식, 진단, 복구하도록 도움: 에러 메시지는 문제를 정확하게 설명하고 해결책을 제시하기 위해 이해할 수 있도록 써야 한다. 404 오류보다는 “찾고 있는 페이지를 찾을 수 없습니다” 와 같은 표현을 사용하고, 그의 해결책 또한 제시해라. 도움말 및 문서화: 문서 없이도 시스템을 사용할 수 있어야 하지만, 사용자에게 필요할 때 효과적이고 쉽게 이해할 수 있는 도움말을 제공하는 것은 중요하다. 사용자가 무언가 잊어버렸을 때 참고할 수 있도록 모든 툴팁을 모아 두면 좋다. UX 디자인은 ‘사용성’과 ‘몰입도’ 라는 주요 요소로 나눌 수 있다.다음은 위의 휴리스틱을 게임에 적용하였을 때 공통으로 주로 나타나는 [게임 휴리스틱] 의 예이다. 컨트롤은 커스터마이징 가능해야 하고, 업계 표준으로 디폴트 설정해야 한다. 피드백은 사용자 컨트롤을 표시하기 위해 즉각적으로 제공해야 한다. 플레이어에게 압박감을 주되 불만이나 좌절감을 주지 않도록 게임 페이스를 조절한다. 명확한 목표를 제공하고 게임 내내 단기 목표뿐만 아니라 중요한 목표를 이른 시기에 제시한다. 게임에는 플레이어가 게임에 더 몰입할 수 있도록 그들의 역량을 증가시키고 그들의 능력을 커스터마이징 해서 확장할 수 있는 보상이 있어야 한다. 플레이어는 게임플레이의 일부로 이야기를 찾아낸다. 한꺼번에 많은 텍스트를 쓰지 않는다. 플레이어는 자신감에 차 있어야 한다. 즉, 위협과 기회에 반응할 시간과 정보가 필요한다. 플레이어가 꼼짝 못하거나 헤매기 쉽게 만들지 마라. 사용자 인터페이스(UI)는 게임 안에서 그리고 게임 간에 일관되어야 한다. 게임에서 사용되는 용어와 언어는 이해하기 쉬워야 한다. 사용자 인터페이스(UI)는 플레이어가 게임 플레이의 일부가 아닌 실수나 잘못을 하지 않도록 설계해야 한다.The Gamer’s Brain의 7가지 UX 사용성사인 및 피드백플레이어에게 게임의 진행 상황을 알리거나, 특정 행위를 해내도록 권장하는 모든 신호를 나타낸다. 정보 제공용 사인 : 플레이어에게 시스템 상태를 알린다. 체력, 레벨, 미니맵, 장착중인 무기, 점수 등에 해당한다. 이들은 쉽게 알아볼 수 있어야 하지만 게임의 주요 행위에 대한 플레이어의 주의를 방해하거나 분산하면 안된다. 권유용 사인 : 플레이어가 특정한 행위를 해내도록 설득하는 것. NPC 의 머리 위 노란 느낌표는 플레이어가 해당 NPC와 상호작용 하라는 뜻일 수 있다. 대부분의 권유용 사인은 플레이어의 주의를 끌어야 하기 때문에 다른 요소들과 대비를 이뤄야 한다. 또는 숨겨진 장소로 가는 살짝 금이 간 벽은 의도적으로 눈에 띄지 않도록 제작될 수 있다. 일부 정보 제공용 사인은 즉각적인 주의를 요할때 권유용 사인으로 바뀔 수 있는데, 예를 들어 치명상을 입어 체력이 적을 경우 이를 강조하여 엄폐하거나 회복을 유도할 수 있다. 피드백 : 플레이어 행위에 대한 시스템의 반응을 플레이어에게 알리는 특정한 사인이다. 예를들어 플레이어가 움직일 때 캐릭터의 애니메이션은 피드백의 한 예이다. 벽에 막혀 지나갈 수 없다면 벽을 미는듯한 행동을 보이거나, 플레이어가 공격받아 체력이 감소하는 HUD 등도 피드백이다. 모든 플레이어 행위는 그 결과를 알리는 즉각적이고 적절한 피드백이 있어야만 한다. 예를 들어 스킬을 사용했을 때 그 스킬의 쿨다운을 시각적으로 보여주어야 하며, 스킬을 사용시 사용이 되지 않을 때는 효과음과 함께 아이콘이 빨간색으로 짧게 변하며 좌우로 흔들리는 듯한 효과를 주면 확실히 알릴 수 없다. 반대로 이게 없다면 버그로 키가 눌리지 않은 것인지, 또는 쿨타임이라는 것이 있다는 것도 알기 힘들 수 있다. 게임에 있는 모든 기능과 가능한 상호작용은 연결된 사인과 피드백이 있어야 한다.명료성게임에서 지각적 관점에서 모든 사인과 피드백을 이해하는 플레이어의 능력과 관련된다. 가독성 좋은 폰트, 눈에 띄는 효과, 간료한 텍스트 등이 있다. 많은 정보는 한 눈에 파악할 수 있도록 인포그래픽을 사용하는 것이 좋다(글머리 기호, 막대 그래프 등). 게슈탈트 원리 또한 이에 응용할 수 있으며, 또한 혼동을 피하기 위해 고려해야 하는 것이다.사인 명료성에 대해 고려해야 하는 것으로 신호 탐지 이론도 존재하는데, 모든 추론과 의사 결정은 일정 수준의 불확실성이 있을 때 일어난다는 것이다. 간단하게, 강조해야 하는 것이 많을 경우 그 조절을 잘해야 한다.기능에 따르는 형태게임(형태)에 주어진 모든 캐릭터, 아이콘 또는 심벌의 형태가 어떻게 그 의미(기능)를 전달하느냐를 나타낸다. 게임 요소의 시각적 표현은 플레이어가 해당 요소와 어떻게 상호작용하는지 직감적으로 알수 있어야 한다. 플레이어는 아이콘의 의미가 혼동돼 잘못 이해했음을 알게 됐을 때보다 기대했던 것이 거짓임을 알게 되었을 때 훨씬 더 불만이나 좌절감을 갖기 때문에, 게임의 스킬 아이콘과 같은 것에서 혼동을 일으키게 할 바에는 새로운 표현을 배우게 하는게 낫다.직관적인 모든 것은 배울 필요가 없고, 인지 부하를 최소화 하는데 좋으므로 가능한 한 형태를 통해 기능성을 전달하도록 노력하라. 아니면 적어도 플레이어의 기대를 기만하지 않는지 살펴보아야 하는데, 어떤 구역이 탐색할 수 있을 듯 보이는데 실제로는 보이지 않는 벽이 막고 있다면 짜증이 날 수 있다.일관성비디오 게임의 사인, 피드백, 컨트롤, 인터페이스, 메뉴 네비게이션, 월드 룰, 전체 규약은 반드시 일관성이 있어야 한다. 게임에서 문을 열 수 있으면 모든 문은 열 수 있어야 하고, 만약 일부 유형의 문만 열릴 수 있다면 헷갈리지 않도록 시각적인 처리를 달리 해야 한다. 두가지 요소가 비슷한 형태를 보인다면 플레이어는 둘이 비슷한 기능을 갖거나 비슷한 행동 방식을 보일 것이라 기대할 수 있다.만약 이미 있는 게임 규약(비슷한 장르의 공통 규범이나 자사 게임에서 만든 규약)을 바꿀 때에는 정확한 의도가 있어야 한다. 그렇지 않다면 이미 있는 규약을 다시 만드느라 쓸데 없이 시간을 낭비하지 말아라.최소한의 작업 부하플레이어의 인지 부하(주의와 기억) 및 신체적 부하를 반드시 고려하고, 언제나처럼 게임 자체의 도전이 아닌 이상 최소화해야 한다.신체적 부하를 해결하는 예제중 하나로 HCI(Human-Computer Interaction)분야의 피츠Fitts의 법칙이 있는데, 작은 버튼은 큰 버튼을 가리킬 때보다 시간이 더 걸리고, 서로 너무 가까이 붙은 두 개의 버튼은 사용자가 다른 하나를 클릭할 때 실수로 클릭할 위험이 높고, 화면 한쪽 코너에 위치한 버튼은 조준하기 더 쉬운데 화면 끝까지 마우스를 움직이면 지나칠 일이 없기 때문이다. 또한 힉-하이먼 법칙으로 사용자가 의사 결정하는데 걸리는 반응 시간은 화면에 표시된 옵션의 개수에 따라 로그log로 증가한다는 것이 있다.인지 부하를 해결하기 위해서는 인지심리학에 따른 인간의 지각, 기억, 주의, 동기, 정서의 한계와 영향으로써 해결해야 한다. 가능하면 사용자가 생각하지 않아도 되도록 하는 것이 좋다. 인지 부하가 증가되면 그것이 무엇이든 작업을 방해하기 때문이다. 하지만 과정의 깊이가 깊을수록 파지가 향상된다는 점(인지 부하가 높을수록 기억이 오래가고 이해가 깊어진다) 또한 있다는 것을 알아야 한다. 그래서 핵심 경험에 더 많은 인지적 리소스를 할당할 수 있도록 핵심 경험에 직접적으로 연관되지 않은 모든 과제에만 “최소한의 작업 부하 원칙” 이 적용된다는 것이다.오류 방지 및 복구플레이어는 비디오 게임에서 실수를 하고, 죽을 수도 있다. 이것은 게임 경험의 일부지만, 인지 부조화로 인해 플레이어가 자신이 무엇을 잘못했는지 완벽하고 명확하게 이해하지 못하면 “에이 똥겜이네”를 외치며 게임을 떠날 수 있다. 실패의 아픔을 느끼면서도 게임을 진행하게 만드는 무언가에 정말로 동기부여 되지 않는 한에는(유명한 게임이라 친구들이 다 해서 어쩔수없이 하는 등) 오류 방지위에서도 언급되었지만 게임 다운로드 99%에서 다운로드 취소나 확인/취소 같은 극적인 기능 의 버튼들을 서로 가까이 배치하고 색깔도 똑같이 한다는 등의 실수를 하지 못하도록 확인 메세지를 출력하고, 실수로 클릭하지 않도록 해야한다.그리고 플레이어의 오류를 방지하기 위해서 정보를 주어야 한다. 저장하지 않고 나가려 한다면 저장하지 않은 데이터는 모두 삭제된다는 팝업, 체크포인트가 있는 게임에서 다음 체크포인트까지 도달하지 않으면 일어나는 일, 매칭메이킹에서 매치를 포기하면 어떤 일이, 왜 일어나는지 등으로 플레이어가 지식의 부재로 오류가 일어나서는 안된다. 오류 복구게임에서 실패했을 때 재도전 할 수 있게 해주는 것, 리그오브레전드의 상점에서 지원하는 Undo 기능 등, 오류를 복구해 줄 수 있는 기능에 속한다.유연성게임 설정에서 플레이어가 마음대로 선택할 수 있는 사용자 지정(커스터마이징) 및 조정을 말한다. 왼손/오른손잡이를 위한 마우스 반전 기능, 색맹/색약자를 위한 색 팔레트 변경 기능 등이 이에 속한다. 하지만 이것도 알아야 하는게, 대부분의 사람은 가장 쉬운 길로 가고, 옵션 설정을 전혀 변경하지 않는다. 파워 유저만이 이런 고급 설정들을 가지고 놀 것이다.또한, 플레이어가 플레이하고 싶은 난이도를 결정할 수 있게 하는 것도 포함된다. 어떤 플레이어는 큰 도전을 해보고 싶어하는 한편, 다른 플레이어는 그저 가볍게 돌아보고 싶어한다. 일정량의 게임 플레이를 해야만 열리는 특수 스테이지(개어려움)에 플레이어가 접근할 수 있는 것도 고려해볼만 하다. 개인적으로 나는 게임에 난이도 조절을 넣는 것은 완전한 메카닉 변화로 인한 색다른 경험을 줄 수 있지 않는 한은 없는 것이 맞다고 생각한다. 유저가 자기한테 어떤 난이도가 맞을지 어떻게 알겠는가?마지막으로 80/20 규칙으로 알려진 파레토 원칙(Pareto Principle)이 있는데, 기본적으로 시스템 변수의 20%가 결과의 80%를 차지한다는 것으로 예를 들어 제품 기능의 20%가 제품 사용의 80%를 담당한다. 따라서 대부분의 사람들은 게임 기능 중 약 20%만 사용할 것이다. 그렇기 때문에 가능한 디폴트 UI를 단순하게 유지하고, 게임 진행에 꼭 필요한 위젯만 필요한 순간에 표시하고, 파워 유저가 커스터마이징이 가능하도록 하라.몰입도engage ability게임이 너무 쉽지도, 너무 어렵지도 않은 도전을 통해 자신만의 몰입 존flow zone 으로 들어가게 하여 계속 빠져있게 하는 것이 목적이다.동기 - 내재적 동기유능성, 자율성, 관계내재적 동기는 다른 것을 얻기 위한 수단이 아닌, 활동 그 자체를 위한 활동을 추구할 때 일어난다. 이러한 관점에 기반한 게임은 유능성, 자율성 및 참여할 관련성에 대한 기본 심리적 욕구 충족을 목표로 해야 한다.유능성유능성은 능숙해지고 명확한 목표를 향해 나아가는 느낌을 의미한다.이를 충족하기 위해 가장 중요한 방법 중 하나는 플레이어가 능숙한 느낌과 통제력, 그리고 발전하고 숙달된 느낌을 갖게 하는 것이다. 그래서 게임의 중기 및 장기 목표를 확실하게 표현하면서 단기 목표가 무엇인지 나타내는 것이 중요하다. “의미있는” 목표를 “분명하게” 표현하라. 플레이어는 어느 순간에 어떤 목표가 더 중요한지 확실히 알지 못하고, 이는 주관적이기 때문에 명확하게 할 필요가 있다. 많은 동기에 관한 문제는 목표가 플레이어에게 의미/가치가 없기 때문이 아니라 표현이 명확하지 않기 때문이다. 예를 들어 무기나 스킬이 명확하게 어떤 기능을 하는지 간단한 영상 등으로 보여주면 좋다.유능성을 평가하는 방법은 플레이어가 단기, 중기, 장기의 목표 중 얼마를 식별할 수 있는지, 특정 보상의 획득을 기대하며 그것이 자능성을 어떻게 증가시킬 지 아는지를 알아보는 것이다. 그렇지 않다면 목표가 없거나(게임 디자인 문제), 있지만 식별되지 않거나(사용성: 명확성 문제), 식별되지만 명확하게 이해되지 않거나(사용성: 기능을 따르는 형태 문제), 그것도 아니면 플레이어 관점으로 별로 의미가 없는 목표인 인게이지 어빌리티(몰입도) 의 문제이다. 그러니까 플레이어의 진행과 특히 어떤 목표가 완성에 가까운지 명확한 피드백을 주어라. 진행 상황과 남은 목표의 명확한 정보가 유능성에서 결정적인 요소이다. 정리하면, 핵심 요소는 플레이어가 게임에서 자신의 목표에 대한 목적 의식을 느끼게 하고, 진행 상황에 대한 명확한 피드백을 주면 성취감을 느낄 수 있다. 그리고 마지막으로 플레이어가 게임에서 능숙해지는 방법을 이해하는가를 확인하라. 게임 룰을 명확하게 이해하지 못해서 죽거나 목적에 실패하는 플레이어는 숙달된다는 느낌을 전혀 받지 못한다.자율성자율성은 의미 있는 선택과 자기표현을 위한 장소가 주어지는 느낌과 관련된다.이를 충족하기 위해 보통은 의미 있는 결정을 할 수 있고, 자유 의지를 갖지만 게임 시스템 역시 명확하게 만들어 자신감에 차 목적 의식을 경험할 수 있게 하는 것이 포함된다. 플레이어가 할 수 있는 가장 강력한 의미 있는 선택 중 하나는 창의력을 표현하는 것이다. 게임에서 플레이어의 선택은 의미가 있어야 하며, 의사 결정 중에 그 목적을 이해할 수 있어야 하고, 전체적으로 미치는 영향을 인식할 수 있어야 한다. 또한, 자율성에는 반드시 가이드가 있어야 한다. 완전한 자유라는 명목으로 아무런 지침이 없어 플레이어가 혼란스럽거나 압도되면 자율성도, 유능성도 느끼지 못하기 때문이다.관련성관련성은 주로 다른 사람들과의 관계를 느낄 필요성을 나타낸다. NPC로도 가능하다.게임에서 의미있는 사회적 상호작용을 제공한다는 뜻이다. 협력형 게임의 경우 함께 할 라운드와 협력의 정도는 비례한다. 신뢰 관계를 유지할 필요가 없을 때 트롤하거나 이용해먹을 가능성이 높아지기 때문이다. 인간은 자신의 사회적 그룹에 속한 가까운 사람들인 내집단ingroup 을 편애하는 내집단 편향이 있기 때문에, 친구가 하고 있는 미션이나 매치에 바로 쉽게 참여할 수 있도록 하여라. 플레이어가 자신의 상태를 그룹에게 과시할 수 있는(최근 완료한 미션, 얻은 보상, 성과 등)방법을 제공하라. 이는 플레이어의 유능성을 사회적 맥락에서 확정할 수 있게 해준다. 또한, 이는 다른 사람들에게 도발이 될 수도 있다(또래 압박peer pressure). 마지막으로, 플레이어끼리 서로 쉽게 도움을 줄 수 있도록 해라(아이템에 핑을 찍어 팀원이 쉽게 확인할 수 있거나 서로에게 선물을 줄 수 있게 하거나 등).경쟁 또한 관계에 포함되는데, 패자가 되는 것은 좌절감을 불러오고 게임이 불공정하다고 느끼거나 굴욕감을 느끼게 할 수 있기에 약간 위험하다. 그래서 가능하면 패배를 긍정적으로 묘사하고, 배워서 발전할 기회로 바꿀 방법을 찾아야 한다. 다른 사람들과 비교했을 때 가장 잘한 것이나 개인적 척도에서 얼마나 향상되었는지 강조하는 게 좋다.협력이나 경쟁이나 악성 유저들을 방지할 수 있도록 애초에 트롤하지 못하도록 막는 것이 좋다. 그리고 트롤의 피해가 된 유저에게 트롤을 차단하거나 신고하는 등의 권한을 주고, 신고 조치 등을 했을 때 내용을 확인했 고 조치가 취해졌다는 피드백을 주어라. 또한, 예의바른 플레이어를 칭찬할 수 있게 하면 좋다.의미유능성, 자율성, 관계에서 ‘의미’ 라는 개념이 중요한데, 이는 “목적의식, 가치의식, 영향에 대한 의식을 갖는 것” 이다. 플레이어가 해야하거나 배워야하는 모든 일의 배경 근거를 주는 것이 중요하다. ‘회복약을 먹으면 체력이 회복된다’는 기능적 근거보다는, ‘체력이 감소했기 때문에 치료해야 하고, 회복약을 사용하면 가능하다’ 라는 의미 있는 근거를 말한다. 명확한 사인과 피드백을 이러한 요소와 연결하면 더 좋다.동기 - OCEANBig 5 성격 특성으로, 인간이 가지는 성격 특성이며 실제 게임 기획을 할 때 고려해볼만한 가치가 있다. 경험에 대한 개방성 얼마나 창의적이고 호기심이 많은지. 점수가 낮으면 실용적이고 관습적이지만 점수가 높으면 창의적이고 상상력이 풍부하다. 성실성 얼마나 효율적이고 조직적인지. 점수가 낮으면 충동적이고 부주의하지만 점수가 높으면 조직적이고 자기주도적이다. 외향성 얼마나 외향적이고 활동적인지. 점수가 낮으면 내성적이고 조용하지만 점수가 높으면 외향적이고 열정적이다. 친화성 얼마나 우호적이고 동정심이 많은지. 점수가 낮으면 의심 많고 냉담하지만 점수가 높으면 사람을 믿는 경향이 있고 공감한다. 신경증 얼마나 예민하고 불안해하는지. 점수가 낮으면 정서적으로 안정되지만, 점수가 높으면 분노와 불안감을 쉽게 느낀다. 동기 - 외재적 동기학습된 욕구, 그리고 보상외재적 동기는 환경에 의해 형성되는 학습된 욕구에 관한 것으로, 환경을 경험하고 어떤 행동이 긍정적/부정적 결과를 가져오는지 식별하며 환경에 대해 배운다.과제가 창의적이고 이를 완료하려는 동기가 주로 외재적일 때 창의성은 약화된다. 과잉정당화 효과의 일부로, 내재적 동기로 하던게 외재적 동기가 되면 게임을 하는 이유가 외재적 동기라는 잘못된 귀인을 할 수 있게 된다. 외재적 동기로 게임을 오늘 하고싶진 않은데 일일 보상을 받기 위해 게임을 들어갈 수도 있다. 내재적 동기로 시작했는데 활동의 보상이 외재적으로 받아들여지고 있다가, 그 보상이 중단되면 처음부터 외재적 동기를 가지던 사람에 비해 동기가 더 떨어진다. 그래서 그 일일 보상이 연속 개근이 필요한데 하루를 놓쳐서 못 받게 되면 보상을 빼앗겼다고 생각하게 되어 내재적 동기에 영향을 줄 수 있다.이 글의 필자는 외재적 동기는 내재적 동기에 나쁜 영향을 미치지 않는다 하며, 경우에 따라 성과와 창의성을 실제로 향상시킬 수 있다 한다. 그렇기 위해서 외재적 보상이 플레이어의 목표에 있어 방편으로써 중요하고 가치 있는 것이어야 한다. 과제의 보상은 플레이어의 관점에서 의미 있는지 확인하고, 보상으로 무엇을 할 수 있는지 이해해야 한다. 핵심 보상을 받는 것은 다음 목표의 시작점으로 받아들여져야 한다. 과제의 난이도에 따라 보상도 변경되어야 한다. 또한, 칭찬과 같은 작은 보상의 경우 플레이어의 기술에 대한 정보를 주는 것이 좋다. “잘했어!” 보다는 “더블 킬”이 더 유익하다.정서도널드 노먼 - “디자인의 정서적인 면은 제품의 실용적인 요소보다 성공에 더 중요할 수 있다.”비디오 게임의 정서적인 면은 시각적 미학, 음악, 내러티브narrative를 통해 자주 다뤄진다. 이는 ‘게임 필’ 이라고 불리며 이는 ‘숙달과 미숙에 대한 느낌, 그리고 가상 물체와 상호작용하는 촉각’ 을 포함한다. 조작감 또한 많이 중요하다. 스티브 스윙크는 훌륭한 느낌이 드는 게임은 플레이어에게 컨트롤의 미적 감각, 스킬(기술)을 배우는 즐거움, 감각의 확장, 정체성의 확장, 게임과 독특한 물리적 현실을 상호작용 하는 5가지 타입의 경험을 전달하는 것이라 한다. 3C - Control, Camera, Character “조작감을 잘좀 챙겨라” 현장감 물리적, 정서적, 서술적 현장감으로 느끼며 물리적은 실제로 플레이어가 가상 공간에 있음을 느낄 때 일어나고 정서적 현장감은 가상에서 일어나는 일이 플레이어에게 일어나듯이 느껴지고, 정서적 무게로 다가오는 느낌이다. 서술적 현장감은 플레이어의 선택과 액션이 게임의 사건에 실제 결말을 가져올 때처럼 플레이어가 이야기에 스며들어 캐릭터가 믿을 만하고 우호적이라 여길 때 일어난다. 물리적 현실과 살아있는 가상 세계 물리적으로 현실적이게 만들어라. 총알이 금속 표면에 맞은 것과 아무것도 맞지 않은 것의 소리가 같으면 안된다. 게임플로Game Flow칙센트미하이의 몰입의 경험의 8요소 스킬이 필요한 도전적인 활동: 완벽해질 기회가 있음을 알고 있는 스킬 행위와 의식의 합체: 사람의 주의는 활동에 의해 완전히 흡수된다 명확한 목표: 목표가 달성하기 어렵고 의미 있는 경우 직접적인 피드백: 피드백은 즉각적이고 목표와 관련이 있다 직면한 과제에 집중: 우리는 삶의 즐겁지 않은 측면과 과제에 무관한 정보를 잊는다 통제감: 과제를 숙달하기에 충분한 스킬 개발 자의식의 상실: 자기 관찰의 여지가 없다 시간의 변형: 시간 가는 것을 잊는다게임플로 모델은 집중, 도전, 플레이어 스킬, 컨트롤, 명확한 목표, 피드백, 몰입, 소셜 이라는 8가지 핵심 요소로 구성되어 있다.또한, 어려운 정도(난이도 곡선)과 압박의 양(페이스)로 되어 있고, 레벨 디자인을 통해 실제로 해보는 분산 학습(학습 곡선) 이 필요하다. 또한, 플레이어가 이전에 느낀 압박(예: 어려운 기믹을 배움)에 따라 피로도가 있을 수 있기 때문에 이를 고려하여 난이도를 설계해야 한다.어포던스affordance어떤 행동을 유도하는 것으로 행동유도성이라고도 한다. 물체의 어포던스를 인지하면 사람들이 해당 물체를 사용할 수 있는 방법을 결정하게 되는데, 예를 들어 컵의 손잡이는 잡는 행동을 유도한다. 여기서 하트슨은 이 어포던스를 4가지로 분류하였다. 물리적 어포던스 : 무언가를 하는데 도움이 되는 물리적 특성 페트병은 병따개가 필요 없고 맨손으로도 열 수 있다. 물리적 행위를 용이하게 하는 방식이다. 예를 들어, 버튼의 크기를 충분히 크게 할 수 있다. 인지적 어포던스 사용자가 배우고, 이해하고, 무언가를 알고, 그것으로 무엇을 할 수 있는지 결정하는데 도움을 준다. 버튼 레이블Label이나 기능 전달에 사용되는 메타포Metaphor 등은 모두 인지 어포던스이므로, 기능에 따른 형태는 인지 어포던스에 관한 것이다. 감각적 어포던스 : 사용자가 무언가를 감지하는 데 도움이 되는 기능 무언가 보고, 듣고, 느끼는 데 돕는 것으로 텍스트의 가독성을 좋게 하는 것, 중요한 아이콘을 눈에 띄게 하는 것 등 명확한 사용성의 주요 구조부는 감각적 어포던스에 관한 것이다. 기능적 어포던스: 사용자가 특정 과제를 수행하는 데 도움이 되는 디자인 기능 인벤토리에서 아이템을 정렬하는 기능, 아이템 비교 기능, 필터링, 고정하기 등이 이에 속한다. 거짓 어포던스는 없어야 하며(맵의 어떤 영역에 접근할 수 없다면 접근할 수 있는 것 처럼 보이게 하면 안된다) 개발 초반에 설계하는 게 좋다." }, { "title": "C언어 총정리", "url": "/posts/C-lecture/", "categories": "Lecture, Basic", "tags": "CPP, Essence", "date": "2021-09-29 12:00:00 +0900", "snippet": "이 강좌는 C언어의 기초 필수 문법을 설명합니다. 초보자가 쉽고 빠르게 이해할 수 있도록 구성되어 있으며, 꼭 지금 알 필요 없는 어려운 개념들은 부록으로 정리하였습니다. 내용이 많이 함축되어 있기 때문에 모든 내용을 정확히 이해하고 넘어가도록 합시다!Visual Studio 시작하기Visual Studio위 링크에서 Visual Studio Community 버전을 받아줍니다. 업데이트가 됨에 따라 이름에 2019, 2022 등 년도가 다를 수 있지만 최신버전을 받아주면 됩니다. 만약 컴퓨터 사양이 많이 낮다면, Visual Studio Code를 이용할 수도 있습니다.실행 후, [C++를 사용한 데스크톱 개발] 을 체크해준 후에 설치를 진행합니다.Visual Studio을 실행시킨 후, [새 프로젝트 만들기(N)] 를 클릭한 후에 언어를 C++으로 설정하고 [빈 프로젝트]를 고른 뒤에 프로젝트 이름과 경로는 아무렇게나 설정해준 뒤에 “만들기” 를 누릅니다그 후에 “솔루션 탐색기” 라고 아래와 같은 구조로 되어있는 창에서프로젝트명├── 외부 종속성├── 리소스 파일├── 소스 파일 &amp;lt;---└── 헤더 파일[소스 파일] 을 선택한 후, 우클릭-&amp;gt;추가-&amp;gt;새 항목 을 선택합니다. (또는 단축키 [Ctrl+Shift+A])그리고 [C++ 파일(.cpp)] 을 선택한 후(자동으로 선택되어있습니다) 원하는 이름으로 설정해 주되 확장자를 .cpp에서 .c로 변경합니다. .cpp는 c plus plus로 C++을 의미합니다.그러면 방금 만든 파일이 열리면서 텍스트를 적을 수 있게 됩니다.이제 이곳에서 첫 프로그램을 작성해보도록 하겠습니다. 영타가 느리다면 복사 붙여넣기를 해도 괜찮지만 더 잘 기억하기 위해 가능하면 따라서 적어보세요!기초 사항#include &amp;lt;stdio.h&amp;gt;int main() { printf(&quot;Hello, World!&quot;); return 0;}위 코드를 작성하고 [Ctrl+F5] 단축키를 누르면 콘솔 창(cmd, 명령프롬프트)이 열리며Hello, World!라는 문장이 출력됩니다. 이제 각 코드가 무엇을 의미하는지 한번 알아보도록 합시다. #include 는 다른 코딩파일을 가져오겠다는 뜻이고, &amp;lt;stdio.h&amp;gt; 는 [Standard Input/Output library] 로써 C언어를 사용하기 위해 필수로 가져와야 하는 파일입니다. int main() { ... } 는 함수 라고 하는데, 이는 한참 뒤에 설명될 개념이니 그 전까지는 꼭 적어줘야 한다고 알아두시면 됩니다. 모든 프로그램은 이 main 함수에서 시작합니다. return 0; 또한 함수에서 배우는 내용입니다. 그리고 각 문장을 보시면 끝에 ;(세미콜론) 이 보이는데, 이는 프로그래밍에서 “문장의 끝”을 나타냅니다. 몇몇 언어마다 차이는 있지만, 대부분 ;를 적어주지 않으면 그건 문장이 끝나지 않았다라고 판단하게 됩니다. 그러니까, 프로그래밍에서 아무리 띄어쓰기를 하던 줄바꿈을 하던 ;가 있으면 상관없습니다. 또한 중괄호 {} 도 비슷한 역할을 하는데, 여러 줄의 코드가 한 문장 안에 들어가야 할 때 사용됩니다. 일단은 익숙해지기 위해서 앞으로 예제들을 보며 익혀봅시다.주석Comment더 자세한 설명을 하기에 앞서 “주석(Comment)” 이라는 개념에 대해서 설명해 드리겠습니다.주석이란, 코드를 읽는 사람을 위해 적어주는 것으로 실제 프로그램에는 아무런 영향이 없는 글자입니다. 주석을 작성하기 위해서는 // 나 /* */ 을 사용하게 되는데,#include &amp;lt;stdio.h&amp;gt;int main() { // printf(&quot;실행 안됨&quot;); /* printf(&quot;이것도&quot;); printf(&quot;실행&quot;); printf(&quot;안됨&quot;); */ return 0;}//는 한줄만, /* */는 여러 줄을 주석처리하기 위해 사용합니다.변수Variable프로그래밍에서는 여러가지 값들을 기억해둘 필요가 있습니다. 게임을 예로 들자면 체력이나 공격력, 돈 같은 능력치가 있을수도 있고, 웹사이트의 경우 아이디나 비밀번호 등이 될 수 있죠.이 값을 기억하기 위한 공간이 변수입니다. 변수는 특정한 자료형(data type)의 값을 저장하는 공간의 이름으로, 컴퓨터의 메모리인 램(RAM)에다 정보를 저장합니다. 자료형, 혹은 타입(type) 이라 불리는 내용은 나중에 설명됩니다.#include &amp;lt;stdio.h&amp;gt;int main() { int a; a = 5; return 0;}위 코드는 a라는 변수를 작성하고, 5를 대입하는 코드입니다.int a; 와 같이 작성하는 것을 “변수를 선언한다” 라고 하고, &amp;lt;자료형&amp;gt; &amp;lt;변수이름&amp;gt; 의 형태로 선언합니다.이 때, 변수 이름에는 규칙이 있는데 변수 이름은 대소문자를 구별한다 a와 A는 서로 다른 변수입니다. 변수 이름은 숫자로 시작할 수 없다 1coin 은 불가능하지만, coin1 과 같이 첫번째에 있지만 않으면 됩니다. 변수 이름에는 _ 를 제외한 특수문자가 들어갈 수 없다 sigening2774@naver.com, test value, hashtag# 등은 전부 안되고 _ 만 가능합니다. 그리고 가능하면 한글 변수는 작성하지 말아주세요. 이 선언하는 작업을 하면 컴퓨터는 메모리(RAM)에서 비어있는 공간을 알아서 찾아서 자료형의 크기만큼의 공간을 확보하고, 그 공간의 주소를 변수(예제에서는 a)가 가리키게 합니다. 그럼 a = 5; 처럼 변수를 다룰 때는 a가 가지고있는 메모리(RAM)의 주소에다가 값을 넣는다는 것과 같은 의미입니다. 또한 RAM은 Random Access Memory로, 빈 장소를 무작위로 빠르게 찾아주기 때문에 붙은 이름입니다.자료형DataType프로그래밍에서는 자료형이라는게 존재하는데, 메모리의 양도 한정되어있어서 크기가 적당해야 하는 이유도 있고, 자료형별로 연산이 다르기 때문에 존재하는 등 여러가지 이유가 있습니다. 이 자료형은 크게 3가지가 있는데, 정수형, 실수형, 문자형 입니다. 종류 명칭 크기 값 범위 정수형 short 2 -32768 ~ 32767 int 4 -2147483648 ~ 2147483647 long 4 -2147483648 ~ 2147483647 문자형 char 1 -128 ~ 127 부동소수점형 float 4 1.2E-38 ~ 3.4E38 double 8 2.2E-308 ~ 1.8E308 1바이트는 8비트에 해당하고, 1비트는 0과 1만을 가지고 있는데, 이를 이용해 2진수를 만들어 1바이트의 경우 2의 8승을, 4바이트의 경우 2의 32승의 숫자까지 표현할 수 있음을 의미합니다.정수형 short, int, long 이 해당되며, “정수형” 은 말 그대로 정수이기 때문에 소수점이 없는 숫자만 저장할 수 있습니다.문자형 char 가 해당되고, 일단은 숫자를 저장하는 정수형이지만 문자를 저장하는데 사용됩니다. 문자의 경우, 컴퓨터는 문자를 저장할 수 없기 때문에 각 문자에 대응하는 숫자가 있고, 문자를 저장할 때는 이에 해당하는 숫자로 저장되며 출력을 할 때는 그 숫자에 해당하는 문자를 출력합니다. 이 때 이 숫자들을 아스키 코드(ASCII Code) 라고 부릅니다.부동소수점형 float, double 이 해당되며, 실수형이라고도 불리며 소수점을 가질 수 있는 자료형입니다. 부동 소수점(floating point) 은 말 그대로 소수점이 부동(float) 할 수 있음을 의미합니다. 주의할 점은, 실제 소수점 값을 가지고 있기에는 값의 범위가 커서 실제로는 계산식을 통해 소수점을 예측하여 계산합니다. 그래서 오차가 발생할 수 있으며, float의 경우 약 8자리, double의 경우 약 16자리까지 정확하게 표현할 수 있습니다.여기서 변수가 아니라 3, 5 처럼 직접 적어준 값을 상수 라고 하는데, 만약 2.0 이라고 적으면 이 값은 float형 상수일까요 double형 상수일까요? 정답은 double형입니다. 기본적으로 double형이 사용되고 만약 float형 상수를 사용하고싶다면 2.0f 과 같이 숫자 뒤에 f를 붙여주어야 하죠.또, 문자 타입의 경우 A라는 문자를 표현하고 싶을때는 &#39;A&#39; 라고 작은 따옴표로 묶어주시고, 문자가 여러개인 문자열을 사용하고 싶으시면 &quot;Hello, World&quot; 처럼 큰따옴표로 묶어주시면 됩니다.살짝 팁을 알려드리자면 보통 int, double, char만 사용해도 아무 문제가 없습니다.부록: 2진수 계산과 오버플로우자료형이 가질 수 있는 최대 숫자보다 더 큰 값을 입력하면 오버플로우가 발생해서 해당 자료형이 가질 수 있는 최소 값으로, 반대로 최소 숫자보다 작은 값을 입력하면 언더플로우가 발생해서 해당 자료형이 가질 수 있는 최대 값으로 이동됩니다.#include &amp;lt;stdio.h&amp;gt;int main() { short over = 32768; short under = -32769; printf(&quot;Overflow : %d\\n&quot;, over); printf(&quot;Underflow : %d\\n&quot;, under); printf(&quot;More Overflow : %d\\n&quot;, over + 32768); return 0;}하지만 단순히 최대/최소가 되는 것이 아니라, 넘은 만큼 더 이동하게 됩니다. 이를 이해하기 위해서는 메모리 구조와 2진수를 알아야 하는데 1바이트를 기준으로 설명해드리겠습니다.0 0 0 0 | 0 0 0 01바이트는 위와 같이 8비트로 이루어져 있습니다. 만약 0111 1111 이라면 이는 2^7인 128이 되는거죠. 그런데 2진수로는 음수를 표현할 방법이 없어서 맨 왼쪽에있는 비트(MSB) 를 가지고 0이 양수, 1이 음수와 같은 식으로 판단하는거죠. 그렇다면 char의 최대값인 127에 해당하는 0111 1111 에 1을 더하면 어떻게될까요? 일의자리부터 자리올림되어서 1000 0000 이 되는데, 이는 음수의 최솟값인 -128에 해당됩니다. 언더플로우와 더 자세한 설명은 2진수의 음수 표기방식인 2의 보수에 관련해서 찾아보시면 알 수 있습니다.scanf_s(), printf()로 입/출력하기변수를 입력받을때는 scanf_s() 라는 함수를 쓰고, 변수를 출력할때는 printf() 라는 함수를 씁니다. 제일 처음에 Hello, World! 라는 메세지를 출력한 함수도 printf()인데, 어떻게 쓰는지 제대로 알아봅시다.#include &amp;lt;stdio.h&amp;gt;int main() { int a, b; printf(&quot;숫자 2개를 입력하세요: &quot;); scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b); printf(&quot;덧셈 결과는: %d&quot;, a + b); return 0;}printf()에 변수나 값을 출력하는 경우나 scanf_s()로 입력받을 경우에는 안에 %d, %f와같은 형식 지정자 들이 들어가는데, 받으려는 자료형과 똑같은 형식지정자를 적어줘야 합니다. 자주 사용되는 형식 지정자들은 다음과 같습니다.%d : 10진수 정수를 읽습니다 (decimal, 10진수)%f : 실수를 읽습니다 (float)%lf : 실수를 읽습니다 (double, lf는 long float의 약자)%c : 문자를 읽습니다 (char)%s : 문자열을 읽습니다 (string)그래서 만약 int형 변수 3개에 값을 입력받고 출력한다면 다음과 같이 하면 됩니다.#include &amp;lt;stdio.h&amp;gt;int main() { int a, b, c; scanf_s(&quot;%d%d%d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c); printf(&quot;a: %d, b: %d, c: %d&quot;, a, b, c); return 0;}%d가 3개기 때문에 3개의 값을 입력받고, 순서대로 a, b, c에 넣어줍니다. 이 때, scanf_s()는 공백&#39; &#39;, 탭키&#39;\\t&#39;, 줄바꿈&#39;\\n&#39; 을 입력받았을때 하나를 입력받았다고 처리합니다. 여기서 scanf_s에 변수를 적어줄 때 변수의 이름 앞에 &amp;amp;을 적어주는데, 이는 변수의 주소 를 가져오라는 의미입니다. 무슨 말이냐면, 그냥 a, b, c라고 적어버리면 그건 a에 있는 값을 쓰겠다는 말인데 우리는 변수 a가 가지고 있는 공간, 즉 변수 a의 주소에 값을 넣어줘야하기 때문에 &amp;amp;을 쓰는거죠.printf()의 경우에도 많이 헷갈릴 수 있는데, &quot;a: %d, b: %d, c: %d&quot; 라고 적어줬을 때 여기서 &quot;a: , b: , c: &quot;라고 적어준 부분은 그대로 출력되고, %d와 같이 형식지정자가 적힌 부분이 자동으로 오른쪽에 ,로 넣어준 값으로 순서대로 치환됩니다. 여기서 변수가 아니라 값이라는 단어를 쓴 이유는, 굳이 변수를 적지 않아도 무언가 값이 있다면 출력할 수 있기 때문이죠.이해하기 힘들다면 어떻게 입력, 출력받는지 여러가지 방법으로 시도해 봐서 사용법을 완벽히 익히는 것이 중요합니다.이스케이프 문자이스케이프 문자는 줄바꿈이나 문법상 출력할 수 없는 문자를 출려가기 위해 만들어졌습니다. 보시면 바로 이해가 될거에요. \\ (역슬래쉬) 의 경우 엔터키 바로 위에있는거로, 글꼴에 따라 원화표시가 나오지만 상관없습니다.\\0 : NULL 문자 (아무것도 아닌 문자)\\n : 줄 바꾸기 (엔터키 누른것과 동일)\\t : 수평탭 문자 (탭키 누른것과 동일)\\\\ : 백슬래쉬(\\)\\&#39; : 작은 따옴표\\&quot; : 큰 따옴표(쌍 따옴표)%% : 퍼센트(%)예시 코드:printf(&quot;안녕하세요.\\n시즈닝입니다.&quot;);출력 결과:안녕하세요.시즈닝입니다.문자 타입을 받고 싶으실때printf()와 다르게 scanf_s()에는 _s가 붙어있는데, 이는 safe의 약자입니다. 문자 타입을 받을 때 멈추지 않고 계속 받을 위험성이 있기 때문인데요, 그래서 문자타입을 받으실땐 최대 몇글자까지 입력받을것인지 뒤에 숫자로 적어줘야합니다.예시 코드:char a, b;scanf_s(&quot;%c%c&quot;, &amp;amp;a, 1, &amp;amp;b, 1);printf(&quot;%c %c&quot;, a, b);char타입은 어짜피 한글자밖에 받지 못하기 때문에 그냥 1이라고 적어주면 되고, 문자열의 경우 나중에 배열/문자열 챕터에서 알려드리겠습니다.그런데 위의 코드를 실행하면 a에 입력받은건 잘 나오는데, b에 입력받은건 나오지 않을 수가 있습니다. AB 같이 입력하면 잘 나오는데, A B 와 같이 중간에 문자가 껴있으면 나오지가 않죠. 그 이유는 이전에 A라는 문자를 입력받았다고 할때, 그 뒤에 입력의 종료를 나타내는 문자도 같이 입력받기 때문이죠 (공백&#39; &#39;, 탭키&#39;\\t&#39;, 줄바꿈&#39;\\n&#39;)그래서 이 문자들을 무시해준다는 의미로 형식지정자 앞에 띄어쓰기를 해줄 수 있습니다.char a, b;scanf_s(&quot;%c %c&quot;, &amp;amp;a, 1, &amp;amp;b, 1);printf(&quot;%c %c&quot;, a, b);연산자(Operator)대입 연산자(Assignment Operator)위에 변수에서 배웠던 = 는 수학에서 사용되던 좌변과 우변이 같다 와 완전히 다른 의미입니다. 할당 연산자라고도 불리는 이것은, 오른쪽(r-value)에 있는 값을 왼쪽(l-value)에 넣어준다는 뜻이죠. 그래서 a = 1205 와 같이 하면 1205라는 값이 a라는 변수에 들어가게 됩니다. 이런 이유로 l-value라고 불리는 왼쪽값에는 값을 저장할 수 있는 변수만이 들어올 수 있어요.또한, 오른쪽에있는걸 왼쪽에 넣는것이기 때문에 다음과 같은 것도 가능합니다.a = b = c = d = e = 5대입 연산자는 오른쪽에 있을 덧셈, 뺄셈 등의 연산을 기다려야하기 때문에 오른쪽부터 차례대로 계산되어 5개의 변수에 모두 5가 저장됩니다.산술 연산자(Arithmetic Operator) + : 두 값을 더합니다. 3 + 5 // 8 - : 두 값을 뺍니다. 7 - 5 // 2 * : 두 값을 곱합니다. 2 * 3 // 6 / : 두 값을 나눕니다. 17 / 3 // 5 % : 두 값을 나눈 나머지를 구합니다. 123 % 10 // 3키보드에는 나눗셈 기호가 없기때문에 /를 나눗셈 연산자로 사용하고, 곱셈을 x라고 적기에는 문자 X와 비슷하니 *가 사용되었습니다.특이하게 나머지 연산자가 존재하는데, 이게 프로그래밍에서는 매우 유용하게 쓰입니다. 실수형은 나머지를 구하는 방법이 다르기 때문에 정수형에만 지원이 되죠. 변수는 사용되기 전에 무조건 초기화가 되어 있어야 합니다. 대입 연산자로 아무 값도 넣어주지 않았다면 그 변수는 0을 가지고 있는게 아니라, 알수 없는 쓰레기 값을 가지고 있기 때문에 오류가 발생합니다.예제 코드:#include &amp;lt;stdio.h&amp;gt;int main() { int a, b; a = 10; b = 3; printf(&quot;a + b 는 : %d \\n&quot;, a + b); printf(&quot;a - b 는 : %d \\n&quot;, a - b); printf(&quot;a * b 는 : %d \\n&quot;, a * b); printf(&quot;a / b 는 : %d \\n&quot;, a / b); printf(&quot;a %% b 는 : %d \\n&quot;, a % b); return 0;}여기서 위의 설명과 예제 코드를 실행하셨다면 볼 수 있겠지만, 17 / 3 은 5 고, 10 / 3 도 3.333…이 아니라 3입니다. 왜냐면 a의 자료형도 int, b의 자료형도 int기 때문에 연산 결과도 int가 나와서 소수점이 버려지게 됩니다.그럼 만약 소수점이 필요하면 어떻게 해야할까요? 두 변수중 한 변수만 실수 타입이면 됩니다.예제 코드:int a = 10, c = 4;float b = 3;printf(&quot;a / b 는 : %f \\n&quot;, a / b);printf(&quot;a / 3 는 : %f \\n&quot;, a / 3);printf(&quot;a / 3.0 는 : %f \\n&quot;, a / 3.0);printf(&quot;a / c 는 : %f \\n&quot;, a / c);printf(&quot;a / c 는 : %f \\n&quot;, (double)a / c);5개의 printf중 1번째, 3번째, 5번째줄에서는 소수점이 잘 계산되는것을 보실 수 있습니다. 그런데 왜 2개중 하나만 실수형이어도 계산이 될까요? 또 (double)은 뭘까요?암시적 형변환, 명시적 형변환프로그래밍에서는 “형번환” 이라는 개념이 존재합니다. 여기에는 암시적 형변환과 명시적 형변환이 존재하는데, 암시적 형변환은 자동으로 바뀌는거라 보시면 됩니다. 범위가 더 작은 타입에서 범위가 더 큰 타입으로는 자동으로 변환이 됩니다. 그래서 int와 double과 연산할때는 int가 double로, float와 double과 연산할때는 float가 double로 형변환이 되죠.하지만 int / int과 같이 같은 타입끼리 연산을 할 때 등에 형변환이 필요해질 때는 명시적 형변환을 해주면 됩니다. 간단하게 값 앞에 (&amp;lt;자료형&amp;gt;) 을 적어주면 그 줄에서만 해당 값이 정해준 타입으로 바뀌게 됩니다. 그래서 5번째는 int끼리 나뉘어도 소수점이 계산된 것이죠.대입-산술 연산자(Assignment-Arithmetic Operator)이름은 거창하게 지었지만(보통 그냥 대입연산자에 포함합니다) 표현을 축약한 것 뿐입니다. 만약 어떤 변수에 값을 계속 누적하고싶으면 어떻게 해야할까요?int a = 0;a + 3;a + 5;이러면 a에 8이 들어가있을까요? 아닙니다. a는 그대로 0이죠. 왜냐면 a에는 0밖에 대입 하지 않았기 때문이에요. 그래서 값을 누적하려면int a = 0;a = a + 3;a = a + 5;와 같이 해주어야 합니다. 그런데 프로그래밍을 하다보면 이런 연산을 자주하기 때문에 a = a + 3 와 같은 식을 축약한 a += 3 가 존재합니다. -=, *=, /=, %= 또한 당연히 존재하고, “변수의 값을 계산하고 바꿔준다” 라는 의미로 해석하거나 익숙해질때까지 축약이 안된 버전을 기억해두시는 것도 좋습니다.지금까지는 값이 2개 필요한 이항 연산자를 배웠고, 이제 값 하나에만 쓰이는 단항 연산자를 보겠습니다.부호 연산자(Sign Operator)-, + 라는 연산자들이 이에 해당합니다. 사용법은+a -a와 같이 사용되는데, +는 사실 의미가 없고 -의 경우에는 부호를 반대로 바꿔줍니다.증감 연산자(Increment and Decrement Operator)++, -- 라는 연산자들이 이에 해당합니다. 사용법은a++ ++a a-- --a처럼 앞에(전위형)붙냐 뒤에(후위형)붙냐의 차이인데, 일단 무슨 역할을 하는 것인지 알아봅시다.a++는 a += 1, 즉 a = a + 1과 같은 의미입니다. ++a도 a += 1과 같은 의미이죠. 그런데 여기서 차이는 연산 순서에 있습니다. 앞에 붙는 전위형의 경우 변수에 들어있던 값을 사용하기 전에 먼저 변수에 1을 더하고(해당 줄의 다른 모든 연산을 하기 전에 먼저 변수에 1을 더하고), 뒤에 붙는 후위형의 경우 변수의 값을 먼저 쓰게 한 뒤에 변수에 1을 더합니다(다른 모든 연산이 끝나고 1이 더해짐).말로만 들으면 헷갈리기 때문에 예제 코드를 보여드리겠습니다.int a = 1;printf(&quot;%d\\n&quot;, ++a); // 2printf(&quot;%d\\n&quot;, a++); // 2printf(&quot;%d\\n&quot;, a); // 3a++;++a;printf(&quot;%d\\n&quot;, a); // 5첫번째에는 먼저 더하고 변수를 썼기 때문에, a에 1을 더한 값인 2가 출력됩니다. 두번째에는 변수를 먼저 가져다 쓰고 이후에 더했기 때문에, 이전의 값인 2가 그대로 출력됩니다.세번째에는 두번째에서 출력이 끝나고 더해졌기 때문에 3이 나오고, 주변에 다른 식이 없을경우 a++나 ++a나 그게 그거기때문에 마지막에는 5라는 값이 나오게 됩니다. 한번 여러가지 방법으로 계산해 보고 이해해보세요.마지막으로, 연산자는 수학의 연산순서를 그대로 따라갑니다. 그래서 곱셈과 나눗셈, 나머지 등을 먼저 계산하고 덧셈과 뺄셈은 나중에 계산하죠. 그래서 괄호 연산자 또한 존재합니다.(a + b) / 3 * (c - d)와 같은 식도 만들 수 있게 되죠.조건문프로그래밍에서 특정한 경우에 특정한 결과가 일어나게 하려면 어떻게 해야할까요? 예를들어, 비밀번호에 숫자 최소 하나, 특수문자 하나, 대소문자 하나씩 필요하다는 것을 어떻게 확인할까요?바로 이런 “만약에 … 하면” 이라는 것을 코드로 가능하게 해주는 게 조건문입니다. 조건문에는 if문과 switch문이 있으니 한번 공부해봅시다.if, else, else ifif문의 사용법은 다음과 같습니다.조건문 예제1int a;scanf_s(&quot;%d&quot;, &amp;amp;a);if (a == 0) { printf(&quot;입력받은 숫자는 0입니다.&quot;);} else if (a &amp;lt; 0) { printf(&quot;입력받은 숫자는 음수입니다.&quot;);} else { printf(&quot;입력받은 숫자는 양수입니다.&quot;);}위 프로그램은 정수를 하나 입력받아, 0인지 음수인지 양수인지를 구분해 주는 프로그램입니다. “만약” 이라는 뜻을 가진 if를 사용하고 있으며, 안쪽에는 주로 조건식이 들어가게 됩니다. (조금있다 알려드리겠습니다)if (&amp;lt;값&amp;gt;) { &amp;lt;실행될 코드&amp;gt; }if문의 ()안쪽에는 숫자가 들어가는데, 0은 거짓(False)를 의미하고 0이 아닌 모든 숫자는 참(True)를 의미합니다. 그리고 만약 값이 참(True)이라면 뒤에 이어진 중괄호의 내용을 실행하죠.else if문은 if문의 바로 다음에만 쓰일 수 있고, 전에 있던 if문의 조건이 만족하지 않을 경우에만 넘어옵니다. 그리고 if문과 같이 조건을 추가로 확인하죠. 위의 코드를 예로 들자면, a가 0이 아닐 경우 else if문으로 넘어오고, 이 else if문은 a가 0보다 작은지(음수인지) 확인합니다.else문 또한 if문이 있어야지만 사용될 수 있고, if ... else if ... else 의 순서대로 사용되어 맨 마지막에 위치됩니다. 왜냐하면 else는 위의 if, else if문의 조건이 전부 만족하지 않았을 때 조건 없이 무조건 넘어오게 되는 부분이기 때문이죠. if, else if, else는 선택사항이고 if와 else 사이에는 else if가 무한개가 올 수 있습니다.그리고 if문 안에는 얼마든지 많은 if문이 들어올 수 있습니다. else if를 쓰지 않는다면 다음과 같이도 표현할 수 있죠.if (a == 0) { printf(&quot;입력받은 숫자는 0입니다.&quot;);} else { if (a &amp;lt; 0) { printf(&quot;입력받은 숫자는 음수입니다.&quot;); } else { printf(&quot;입력받은 숫자는 양수입니다.&quot;); }}하지만 이러면 코드가 길어지고 가독성이 떨어지기 때문에 else if라는 구문이 등장하게 되었습니다.추가로, 중괄호{}는 세미콜론; 의 역할을 대신하기 때문에, 세미콜론을 적어주지 않아도 됩니다. 또한, 중괄호는 여러 줄의 코드가 포함될 때 적어주는 것이죠.그래서 맨 위의 if문은 사실 중괄호를 생략할 수 있습니다. 각 if문 안에 한줄씩밖에 없기 때문이죠.if (a == 0) printf(&quot;입력받은 숫자는 0입니다.&quot;);else if (a &amp;lt; 0) printf(&quot;입력받은 숫자는 음수입니다.&quot;);else printf(&quot;입력받은 숫자는 양수입니다.&quot;);혹시라도 if (a == 0); 과 같이 세미콜론을 붙이지 않도록 해주세요. 세미콜론은 문장의 끝을 의미하기 때문에, 이렇게 하면 이 if문은 아무런 코드 실행 없이 조건만 확인하고 끝나게 됩니다.조건식 관계 연산자A == B // A와 B가 같은가?A != B // A와 B가 다른가?A &amp;gt; B // A가 B보다 큰가? (B를 포함X)A &amp;gt;= B // A가 B 이상인가? (B를 포함함)A &amp;lt; B // A가 B보다 작은가? (B를 포함X)A &amp;lt;= B // A가 B 이하인가? (B를 포함함)위는 조건 연산자들입니다. 프로그래밍에서 = 는 대입 연산자로 사용되기 때문에, 수학적인 의미로 두 값이 서로 같냐는 것을 계산하고 싶다면 == 을 사용하셔야 합니다. 꼭 기억해주세요!한번 저 계산결과 자체를 출력해보면 알 수 있지만, 조건이 맞을경우 1, 조건이 틀릴경우 0이 나옵니다. 아까 말씀드렸다시피 if문같은 조건문은 0은 거짓, 0이 아닌 모든 숫자는 참이기 때문에 조건이 만족할 때 코드가 실행되는 것이죠. 논리 연산자!&amp;lt;조건식&amp;gt; // NOT 연산&amp;lt;조건식&amp;gt; || &amp;lt;조건식&amp;gt; // OR 연산&amp;lt;조건식&amp;gt; &amp;amp;&amp;amp; &amp;lt;조건식&amp;gt; // AND 연산논리 연산자는 조건식 자체에 사용되는 연산자입니다. 조건식 앞에 ! 를 붙이면 예) !(a == b)조건식의 결과를 반전합니다. 위의 경우 “a와 b가 같지 않을경우” 가 됩니다. 이를 NOT 연산이라고 합니다.조건식 2개 사이에 ||(역슬래시\\ 를 쉬프트누르고) 를 넣으면 예) a == b || a == 0두 조건식 중 하나라도 참일 경우 참을 반환하고, 아니면 거짓을 반환합니다. 위의 경우 “a가 b랑 같거나 또는 a가 0일 경우” 가 됩니다. 이를 OR 연산이라고 합니다.조건식 2개 사이에 &amp;amp;&amp;amp; 를 넣으면 예) 1 &amp;lt;= a &amp;amp;&amp;amp; a &amp;lt;= 10두 조건식이 모두 참이어야 참을 반환하고, 아니면 거짓을 반환합니다. 위의 경우 “a가 1 이상이면서 10 이하일 경우” 가 됩니다. 이를 AND 연산이라고 합니다. 조건 연산자삼항 연산자라고도 불리며, &amp;lt;조건식&amp;gt; ? &amp;lt;코드&amp;gt; : &amp;lt;코드&amp;gt; 와 같이 사용됩니다. 밑의 예제로 알아봅시다.int a;scanf_s(&quot;%d&quot;, &amp;amp;a);// 절댓값a = a &amp;lt; 0 ? -a : a;printf(&quot;%d&quot;, a);위의 코드는 a가 음수일 경우 -를 붙여서 양수로, 양수일 경우 a를 그대로 써서 절댓값을 구해줍니다. 복잡해 보이죠? 실제로도 그렇습니다. 조건 연산자는 &amp;lt;조건식&amp;gt; ? &amp;lt;참일경우 코드&amp;gt; : &amp;lt;거짓일경우 코드&amp;gt;; 처럼 쓰입니다. if ... else 문을 한줄로 적었다고 생각해도 편하죠. 또한, 삼항 연산자도 2개 이상 중첩될 수도 있지만 이는 가독성이 안좋기 때문에 잘 사용하지 않습니다.switchswitch문은 사실 거의 쓰지 않고, 주로 사용되는곳이 한정되어 있기 때문에 이런것이 있다라고만 아시고 if문만 쓰셔도 됩니다. switch문의 구조는 다음과 같은데요int menu;scanf_s(&quot;%d&quot;, &amp;amp;menu);switch(menu){ case 1: printf(&quot;1번 메뉴를 선택했습니다!&quot;); break; case 2: printf(&quot;2번 메뉴를 선택했습니다!&quot;); break; case 3: printf(&quot;3번 메뉴를 선택했습니다!&quot;); break; default: printf(&quot;그런 메뉴 없는데요?&quot;);}switch(&amp;lt;값&amp;gt;) 처럼 괄호 안에 값이 들어가고, 밑에 case &amp;lt;값&amp;gt;: 이 있고 switch에 넣어준 값이 case 뒤의 값과 같은 경우 해당 구문 안으로 들어가게 됩니다. 그런데 한번 들어가기 시작하면 밑에까지 전부 실행해버리기 때문에 break문으로 switch문을 나가주어야 합니다. 이 break문에 대해서는 바로 다음 강의인 “반복문” 에서도 쓰이게 됩니다.default: 의 경우 else문처럼 case에 해당하는 부분이 없더라도 무조건 들어가집니다. 어짜피 마지막 줄이기 때문에 break를 해줄 필요도 없죠.반복문이 반복문까지의 내용은 매우 중요하기 때문에, 이해가 될 때까지 처음부터 반복해서 읽고 실습해보는 것을 추천드립니다. 왜냐하면 이 이후의 내용을 1도 몰라도 반복문까지만 완벽히 안다면 이론상 모든 프로그램을 제작할 수 있기 때문이죠.반복문에도 2가지 종류가 있는데, 반복문은 이름 그대로 코드를 반복하기 위해 만들어진 구문입니다. 다음 코드를 보시죠int a, b;scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);printf(&quot;a + b의 값은 = %d\\n&quot;, a + b);scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);printf(&quot;a + b의 값은 = %d\\n&quot;, a + b);scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);printf(&quot;a + b의 값은 = %d\\n&quot;, a + b);a와 b를 입력받아서, a + b의 결과를 출력하고 싶은데, 이걸 계속 처리하려면 위와 같이 복사해서 사용했어야 합니다. 하지만 이건 엄청 비효율적이고, 사용자는 이걸 3번만 해보고 싶을수도, 100번도 넘게 사용할 수도 있기 때문에 한계가 있죠.while, do … whilewhile문은 주로 “특정 조건이 만족하는 동안” 반복하기 위해 사용됩니다. while (&amp;lt;조건식&amp;gt;) { &amp;lt;실행될 코드&amp;gt; } 와 같이 사용되고, 바로 위의 코드를 “사용자가 0을 2개 입력할 때까지 계속 실행하게” 변경해 보겠습니다.int a, b;scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);while (a != 0 &amp;amp;&amp;amp; b != 0) { printf(&quot;a + b의 값은 = %d\\n&quot;, a + b); scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);}이제 실행해 보면 0 0 을 입력하기 전까지 계속 계산이 되는 것을 볼 수 있습니다. 조건문에 “a가 0이 아니면서 b가 0이 아닐경우” 라고 적어 주었기 때문에, while문은 해당 조건이 만족하는 동안 계속 코드를 반복합니다.이제 다 좋은데, while문은 조건을 먼저 확인하고 코드를 실행해서 처음에 a와 b에 값이 들어있지 않으면 알수없는 쓰레기값으로 계산이 되어 오류가 나기 때문에, 입력을 미리 받고 출력을 나중에 했습니다. 물론 int a = -1, b = -1; 처럼 0이 아닌 값을 미리 넣어줄 수도 있지만, 저는 반복문 안에서 전부 처리되었으면 좋겠습니다. 그럼 어떻게 해야할까요?int a, b;do { scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b); printf(&quot;a + b의 값은 = %d\\n&quot;, a + b);} while (a != 0 &amp;amp;&amp;amp; b != 0);do … while 문은 조건을 확인하기 전에 먼저 실행(do) 하고, 그 후에 조건을 확인합니다. 그래서 일단 한번은 실행하고 조건을 봐줄 수 있다는 장점이 있죠. 만약 눈썰미가 좋으시다면, 위처럼 코드를 바꾼 경우에 처음부터 0 0으로 나가려고 한다면 아까와 다르게 0+0을 출력하고 나가게 된다는 것을 알 수 있습니다. 이는 나중에 break 문을 설명드리면서 고쳐보도록 하죠.forfor문은 주로 “특정 횟수만큼” 반복하기 위해 사용됩니다. 그래서 while보다는 for문이 많이 사용되지만, 상호간의 변환이 간단합니다. for문의 구조는 for (&amp;lt;초기식&amp;gt;; &amp;lt;조건식&amp;gt;; &amp;lt;증감식&amp;gt;) { &amp;lt;실행될 코드&amp;gt; } 입니다. for문은 초기식 -&amp;gt; 조건식 -&amp;gt; (조건이 참이면)코드실행 -&amp;gt; 증감식 -&amp;gt; 조건식 -&amp;gt; 코드… 의 순서대로 반복되고, 초기식/조건식/증감식은 선택사항이어서 비워둘 수 있습니다. 이렇게 이론으로만 들으면 어렵기때문에 실제 코드로 알아봅시다.int a;scanf_s(&quot;%d&quot;, &amp;amp;a);for (int i = 1; i &amp;lt;= 9; i++) { printf(&quot;%d * %d = %d\\n&quot;, a, i, a * i);}위의 코드는 입력한 숫자의 구구단을 출력하는 for문입니다. int i = 1 이 먼저 실행되어서 i가 1이 되고, 조건을 확인하고, 조건이 참이므로 a * 1 을 출력하게 됩니다. 그 후에 i에 1을 더하는 증감식 i++ 을 만나고, 다시 조건을 확인하고… 그렇게 i가 1부터 9까지 반복되면서 구구단을 출력하는거죠.위에서 for문 부분만 아래처럼 while문으로 바꿀수도 있습니다.int i = 0;while (i &amp;lt;= 9) { printf(&quot;%d * %d = %d\\n&quot;, a, i, a * i); i++;}이제 for문을 다시 보면 그냥 while문에 변수 선언&amp;amp;초기화와 변수 증가/감소 식 부분이 추가된 것이란 걸 아실 수 있습니다.다시 더 간단한 for문 예제를 보여드리면, &quot;Hello, World&quot; 를 5번 출력하는 코드는 다음과 같습니다.for (int i = 0; i &amp;lt; 5; i++) printf(&quot;Hello, World\\n&quot;);i가 0부터 5보다 작을때까지, 즉 0,1,2,3,4 까지 증가하면서 밑의 코드를 호출하고, 그 후에 증감식을 다시 만나면 i가 5가 되어서 조건이 만족하지 않게 되어서 반복문을 빠져나가게 됩니다.또, 위의 코드를 보면 반복문도 한줄만 있을 경우 중괄호{}를 생락할 수 있다는 걸 아실 수 있습니다.break, continuebreak문을 만나면 현재 진행중인 반복문 을 빠져나가게 됩니다. while, for, switch에만 사용됩니다.int a, b;while (1) { scanf_s(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b); if (a == 0 &amp;amp;&amp;amp; b == 0) break; printf(&quot;a + b의 값은 = %d\\n&quot;, a + b);}위의 코드는 [무한 반복문] 이라는 기법인데, 조건에 그냥 1을 넣어 무한대로 반복시키고 if문과 break문을 활용해서 특정 조건에 빠져나가도록 하는 것이죠. 그럼 아까 말씀드렸던 0 0을 입력했을때 0+0이 출력되던 문제도 해결됩니다! 출력을 하기전에 조건으로 확인을 해서 빠져나가기 때문이죠.continue문을 만나면 바로 다음 반복으로 건너뜁니다. while문의 경우 밑의 코드들을 넘기고 바로 조건식으로 가고, for문의 경우 증감식으로 갑니다.for (int i = 1; i &amp;lt;= 10; i++) { if (i % 2 == 0) continue; printf(&quot;%d &quot;, i);}위의 코드는 i를 2로 나눈 나머지가 0인 경우, 즉 i가 짝수인 경우에 건너뛰도록 되어서 홀수만 출력되게 됩니다. 조건이 만족하면 바로 i++부분으로 넘어가기 때문이죠.중첩 반복문나중에 머리를 싸매게 될 난관이자, 이해하기 난해한 기법입니다. 중첩 반복문이란 말그대로 반복문 안에 반복문을 넣는것을 의미합니다. 그럼 뭐가 달라질까요?예제 코드:for (int i = 0; i &amp;lt; 5; i++) { for (int j = 0; j &amp;lt; 5; j++) { printf(&quot;*&quot;); } printf(&quot;\\n&quot;);}실행 결과:*************************바깥쪽 반복문이 1번 반복할 때, 안쪽 반복문은 처음부터 끝까지, 그러니까 0부터 4까지 총 5번 반복합니다. 그런데 바깥쪽 반복문이 5번 반복하니까 총 반복횟수는 5x5 = 25가 되는것이죠.안쪽 j변수 반복문이 5번 반복해서 별을 5개 출력하고 나면, i변수 반복문에서 줄바꿈 문자를 출력해서 위와 같은 별 사각형이 출력되게 됩니다.중첩 반복문을 자유롭게 다룰 수 있게 되면 할수있는 것이 더욱 많아지기 때문에, 연습문제를 도전해서 실력을 쌓으면서 익숙해지는 것을 추천드립니다!배열(Array)배열이란? 단순하게 여러개의 변수를 한꺼번에 선언해주는 기능입니다.int arr[5];arr[0] = 10;arr[1] = 20;arr[2] = 30;arr[3] = 40;arr[4] = 50;printf(&quot;%d %d %d %d %d&quot;, arr[0], arr[1], arr[2], arr[3], arr[4]);만약 위의 코드를 배열없이 만드려면 어떻게 했어야할까요? int a0, a1, a2, a3, a4 와 같이 일일이 써줘야 했을겁니다. 그리고 배열의 경우 []안의 숫자만 바꿔주면 크기가 바로 바뀌는데 변수로 선언하면 그런것도 불가능하죠.배열의 선언 방법은 변수와 완전히 똑같지만, 변수 뒤에 [&amp;lt;크기&amp;gt;] 를 적어줌으로써 해당 숫자크기의, 해당 타입의 배열을 만들 수 있습니다. 또, 배열의 원소(값)를 쓰고 싶다면 &amp;lt;배열이름&amp;gt;[&amp;lt;번호&amp;gt;] 와 같은 방법으로 쓸 수 있죠. 여기서 중요한 점은, 배열은 1번째가 아니라 0번째부터 시작한다는 점입니다.또한, 위의 코드를 반복문을 사용하도록, 그리고 배열의 원소에 입력을 받도록 만들어 더 간단하고 유용하게 만들 수 있습니다.int arr[5];for(int i = 0; i &amp;lt; 5; i++) scanf_s(&quot;%d&quot;, &amp;amp;arr[i]);for(int i = 0; i &amp;lt; 5; i++) printf(&quot;%d &quot;, arr[i]);위에서 보시면 아시다시피 배열은 대부분 반복문과 같이 쓰입니다. 0번째부터 원하는 번째까지 간단하게 접근할 수 있기 때문이죠.만약 배열을 변수처럼 선언과 동시에 초기화해주고 싶다면(배열도 초기화를 하지 않으면 쓰레기값을 가지고 있습니다) 다음과 같이 해줄 수 있습니다.int arr1[5] = {1, 2, 3, 4, 5};int arr2[] = {1, 2, 3, 4, 5};int arr3[5] = { 0 };선언을 할때 중괄호{} 와 안에 값을 적어주면, 0번째부터 순서대로 해당 값으로 초기화가 됩니다. 또한, arr2 처럼 크기를 적어주지 않으면 뒤에 적어준 값의 개수만큼 초기화가 됩니다. 그럼 arr3 은 어떻게 되는걸까요? 첫번째 원소의 값이 0으로 바뀝니다. 그런데, 이 중괄호로 초기화를 하면 나머지 모든 원소들도 자동으로 기본값인 0으로 초기화가 됩니다. 그래서 arr[3]의 원소들은 { 0, 0, 0, 0, 0 } 이 되는거죠.배열을 쓰시면서 주의하실 점은, 배열의 범위를 벗어나는(음수번호 포함)값을 번호(인덱스)로 넘겨주면, 배열의 범위를 벗어났다는 오류가 발생하게 됩니다.배열의 내용은 이게 끝입니다. 하지만 배열이 어려워지는 이유는 바로 활용과 다차원 배열에 있죠. 이제 다차원 배열을 선언하는 법을 알아봅시다.N차원 배열2차원 배열은 우리 주변에서 간단하게 볼 수 있습니다. 표의 형태를 가지고 있기 때문이죠. 변수가 점이면 배열은 선, 2차원 배열은 면, 3차원 배열은 도형… 이런식으로 기하학적으로 표현할 수도 있습니다. 그런데 2차원 배열이란 정확히 무엇일까요?2차원 배열을 컴퓨터적으로 살펴보면 배열의 배열 이 됩니다. int형 배열이라는 것은 각 원소가 int형인 변수라는 뜻이잖아요? 그러면 int형 배열의 배열은 각 원소가 int형 배열 인 것입니다.int arr[5][10]; 위와 같이 선언하면 크기가 10인 int형 배열이 5개 있다 라는 뜻이 됩니다. 왼쪽(앞쪽) 에 있을수록 차원이 높고, 오른쪽(뒤쪽) 에 있을수록 차원이 낮기 때문이죠. 그러면 0번째에 있는 배열의 4번째 원소는 어떻게 접근할까요?arr[0][4] 와 같이, 접근할 때에도 대괄호를 2개 써서 접근합니다. 사용법이 잘 이해가 되시나요? 그렇다면 3차원, 4차원 배열도int arr[2][5][10][10]; 이런식으로 얼마든지 늘릴 수 있게 됩니다. 하지만 4차원 이상은 코드를 이해하기 버거워지기 때문에 대부분 2차원까지만, 가끔 3차원을 씁니다. 그런데 2차원 배열을 쓰면 메모리 상에서 어떻게 되어있을까요?int arr_d2[2][3] = {{1, 2, 3}, {4, 5, 6}}; // {1, 2, 3, 4, 5, 6} 도 됩니다int arr_d1[6] = {1, 2, 3, 4, 5, 6};1차원이나 2차원이나 메모리 상에서는 숫자가 순서대로 들어가 있습니다. 그래서 사실 1차원을 쓰냐 2차원을 쓰냐의 차이는 배열의 원소에 접근할 때 쓰이는 번호(인덱스)가 1개냐 2개냐의 차이이죠.마지막으로 3차원 배열의 반복문 접근예제만 보여드리겠습니다.int arr[3][2][5], cnt = 0;for(int i = 0; i &amp;lt; 3; i++){ for(int j = 0; j &amp;lt; 2; j++){ for(int k = 0; k &amp;lt; 5; k++){ arr[i][j][k] = ++cnt; } }}for(int i = 0; i &amp;lt; 3; i++){ for(int j = 0; j &amp;lt; 2; j++){ for(int k = 0; k &amp;lt; 5; k++){ printf(&quot;%d &quot;, arr[i][j][k]); } printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;);}함수함수는 수학에서도 있는 개념이며, 주로 f(x)으로 표현되죠. f(x)가 무슨 뜻인가요? 값 하나를 넘겨주었을때 안에서 모종의 계산을 취한 후 결과를 만들어주는 것이죠. 더하기 빼기같은 사칙연산도 함수라고 할 수 있습니다! 값 2개를 넘겨주면 안에서 두 값을 더하고 결과를 주기 때문이죠.그러면 프로그래밍에서의 함수는 어떨까요? 완전 똑같습니다. 원하는 값들을 변수로 입력받고, 안에서 코드를 실행한 후, 원하는 자료형을 반환하죠. 함수의 정의부터 살펴보도록 합시다.&amp;lt;반환 자료형&amp;gt; &amp;lt;함수 이름&amp;gt;(&amp;lt;매개변수 목록&amp;gt;){ &amp;lt;실행될 코드들&amp;gt; }와 같이 생겼습니다. 함수를 사용하는 것을 함수를 호출한다 라고 하고, 함수에 넘겨주는 값들은 매개변수 라고 부릅니다. 예제코드를 보고 더 자세히 알아보도록 하죠!// start부터 end의 합을 구해서 반환(return)하는 함수int GetSum(int start, int end){ int sum = 0; for (int i = start; i &amp;lt;= end; i++) sum += i; return sum;}int main() { int result = GetSum(1, 10); printf(&quot;1부터 10까지의 합: %d&quot;, result); // result에 안넣고 바로 GetSum(1, 10)을 넣어도 됩니다. return 0;}GetSum()을 보시면 int형 값 2개를 매개변수로 받는데, 각각의 변수 이름이 start 와 end 이고, 함수의 자료형은 int인 GetSum 이라는 함수를 만들었다고 할 수 있습니다. 안쪽에서는 start부터 end까지의 합계를 구해서, return 이라는 구문으로 계산된 값을 반환합니다.여기서 return 이란, 처음에 말씀드린 계산한 결과를 호출한 곳으로 돌려주는 역할을 합니다. int result = GetSum(1, 10); 이라고 하면, 여기서 GetSum에 1과 10을 넣어서 호출했고, 그 계산된 결과가 이곳으로 돌아오는(return, 반환되다)거죠. 이쯤에서 함수의 자료형이 무슨 역할을 하는지 설명해드리면, 반환되는 값의 타입을 의미합니다. 만약 return 5.5; 를 해주었는데, 그 함수의 자료형이 int 타입이라면 5.5가아니라 5가 반환됩니다.그리고 함수는 return을 만나면 즉시 종료하게 됩니다.int GiveSomething(){ printf(&quot;5를 드릴게요!&quot;); return 5; printf(&quot;10은 안되나요?&quot;); return 10;}위의 함수는 5를 반환하고 밑의 모든 코드를 실행하지 않습니다.그런데 GetSum()의 코드를 보시면서 느끼신 점이 있지 않나요? 네, 지금까지 계속 적어주던 int main(){ } 도 사실은 함수입니다. 왜 굳이 main이라는 이름이냐면, 프로그램을 실행하면 컴퓨터가 정확히 main이라는 이름의 함수를 실행시키면서 프로그램이 실행됩니다. 그러면 return 0 의 반환값인 0은 어디로 가는걸까요? 이는 운영체제로 넘어가게 되는데, 사실 뭘주던 상관은 없습니다. 하지만 관례적으로, 그리고 예외를 방지하기 위해 적어주는 것이죠.void 타입함수에는 void라는 타입이 존재합니다. 이는 반환값(return값)이 존재하지 않는다는 뜻이고, return을 함수 종료 용도로 사용할 수는 있지만 뒤에 무언가 값을 적어줄 수는 없습니다. 주로, 내부에서 출력하는 등 값을 전달할 필요가 없는 경우에 사용됩니다.void print(char ch){ if (ch == &#39;\\n&#39;) return; printf(&quot;%c&quot;, ch);}변수의 범위변수에는 범위가 존재합니다. 엄청 간단하게 알려드리면, 중괄호에 따라 범위가 나뉘는데 예를들어 중괄호 안에서 선언한 변수는 그 중괄호가 끝나면 사라집니다.int main() { int a = 5; if (a == 5) { printf(&quot;밖에서 안쪽은 되네요: %d\\n&quot;, a); int b = 3; } printf(&quot;b라는 변수가 어디있죠? %d\\n&quot;, b); // 오류가 뜹니다}그래서 위의 코드는 b라는 변수를 찾지 못해 오류가 발생합니다. 또, 이런 코드를 헷갈리지 말으셔야합니다.int Add(int x, int y) { x += 10; y -= 5; return x + y;}int main(){ int x = 2, y = 5; int result = Add(x, y); printf(&quot;%d + %d = %d&quot;, x, y, result);}Add(int x, int y) 와 main함수 안에있는 int x, y는 이름만 같고 서로 다른 변수입니다. 중괄호의 범위가 다르기 때문이죠. (매개변수라도 해당 함수 안에있는겁니다)지역변수, 전역변수그렇게 중괄호 안에서 선언된 변수를 지역변수라고 하고, 아무 중괄호 안에도 들어있지 않은 변수를 전역변수라고 합니다. 지역변수는 스택(Stack)이라는 메모리에 상주하고, 전역변수는 힙(Heap)이라는 메모리에 상주합니다. 힙의 메모리 공간이 더 넉넉합니다. 전역변수의 경우 어디에서든지(어느 함수에서든지) 사용될 수 있습니다. 하지만 실제 프로그램 개발에선 거의 절대 사용하지 않습니다. 전역 변수와 겹치는 이름을 지으면 안되는 등의 문제가 생기거든요!int cnt; // 전역변수는 자동으로 초기화됩니다void Counter() { cnt++;}int main() { Counter(); Counter(); Counter(); printf(&quot;%d&quot;, cnt); // 3 출력 return 0;}정적변수만약 전역변수를 쓰기는 싫은데, 다음에 함수를 호출할 때에도 값을 기억하고 싶다면 정적 변수를 쓰는것도 방법 중에 하나입니다. 정적 변수는 해당 변수를 스택(Stack)이 아닌 힙(Heap)메모리에 상주하도록 변경합니다.변수를 선언할 때 자료형에 static을 붙여주면 되고, 앞에하나 뒤에하나 상관없습니다.void Counter() { static int cnt; // int static cnt; 도 됩니다 cnt++; printf(&quot;%d &quot;, cnt); }int main() { Counter(); Counter(); Counter(); return 0;}함수 원형(함수 시그니처)C언어는 절차지향 언어입니다. 이건 프로그램을 실행할 때 위에서부터 차례대로 읽는다는 뜻이죠. 갑자기 이걸 왜 설명해주냐면, 함수를 호출할 때 그 함수의 정의가 함수를 호출하려는 것 보다 밑에있다면, 함수를 찾지 못해서 오류가 나게 됩니다. 정확히는, 함수의 매개변수에 잘못된 타입을 주는 등의 실수를 해도, 컴파일러가 오류를 찾아주지 못하고 오류가 나게 됩니다. 그런데 만약 함수를 밑에다 구현하고싶다면 어떻게 해야할까요?int Add(int a, int b);int main() { int sum = Add(10, 15); return 0;}int Add(int a, int b) { return a + b;}바로 위처럼 함수의 원형, 즉 함수의 정의만을 위에 적어주면 아무런 문제없이 해당 함수를 읽어올 수 있게 됩니다. 대부분의 C프로그래머는 이렇게 위에 함수의 원형을 정의해두고 밑에 함수를 작성한다고 합니다!포인터(Pointer)강의 거의 처음에 변수에 대해서 설명을 할 때, 변수를 선언하면 메모리(RAM) 에서 비어있는 공간을 찾아서 변수의 자료형의 크기만큼 확보해 준다고 했었습니다. 그리고 변수에게는 그 메모리(RAM)의 주소를 가리키게 했는데요, 포인터는 바로 이 주소를 저장하고 다루는 변수입니다.int a = 5;int *p;p = &amp;amp;a;*p = 0;printf(&quot;%d&quot;, a);위의 예제를 적고 실행해 보면, a의 값이 0으로 바뀌었다는 것을 알 수 있습니다. scanf_s()에 대해 설명할 때 &amp;amp;는 변수의 주소를 계산한다고 한 게 기억나시나요? 위의 코드는 int 포인터형 변수 p를 선언하고, 거기에 a의 주소를 넣은 다음에 p가 가리키고 있는 주소의 값을 0으로 바꿔준 것입니다. p에는 a의 주소가 들어가있었으니, a가 가리키고 있던 값이 바뀌게 되는 것이죠. 대충 포인터가 무얼 하는지 감이 오셨다면, 더 제대로 알아봅시다!&amp;lt;자료형&amp;gt; *&amp;lt;변수명&amp;gt; 포인터는 위와 같이 변수를 선언할 때, 변수의 이름 앞에 *을 붙여서 해당 자료형의 포인터 변수를 선언합니다. 그러면 이제 이 변수는 주소값을 담을 수 있는 변수가 되는거죠! 주소값은 실제로 숫자의 형태로 지정되어 있습니다. 0x00000012 같은식으로 말이죠. 32비트 컴퓨터의 경우 16진수 8자리로 표현이 가능하고(각 자리가 2^4 이기 때문에 2^4^8 = 2^32) 64비트는 16진수 16자리로 표현이 가능합니다.그럼 위 코드의 3번째 줄 까지는 이해가 되셨을 겁니다(아마도요). 그럼 그 밑의 *p = 0;은 무엇일까요? 포인터 변수를 사용할 때, 앞에 *를 붙여주면 해당 포인터 변수가 가리키는 주소의 값을 의미합니다. 만약에 저 코드에서 *가 없었다면 p가 가리키는 주소를 0으로 바꾸라는 의미였겠죠. 그렇기 때문에 a의 주소의 값이 바뀌어서 0이 출력된 거에요!마지막으로, 포인터에 타입이 존재하는 이유는 타입마다 가지고 있는 데이터의 크기가 다르기 때문입니다. int * 형의 경우, int가 4바이트기 때문에 가리키고 있는 주소부터 4바이트만큼의 값을 자동으로 읽어오고, char * 형의 경우 1바이트만 읽어오는 식으로 작동합니다.배열과 포인터포인터는 주소를 다루는 자료형이라고 했었습니다. 그런데 배열도 포인터라는 점 알고계셨나요? 서로다른 변수를 5개 선언하는것과 크기 5의 배열을 선언하는것은, 번호로 접근한다는 차이 외에도 큰 특징이 하나 있습니다.int s1, s2, s3, s4, s5;위처럼 변수를 5번 선언하면 메모리(RAM)에서 서로 다른곳에 4바이트씩 할당이 됩니다.int s[5];하지만 위처럼 배열로 선언하면 int형 변수 5개만큼의 공간인 20바이트를 한꺼번에 할당합니다. 그러면 엄청 큰 장점이 생기는데, 배열의 원소들의 주소가 전부 일정한 간격으로 뛰어져 있어서 1번째 원소의 주소만 알면 그 주소부터 4바이트(1칸)을 건너뛰면 2번째 원소, 16바이트(4칸)을 건너뛰면 5번째 원소가 나오게 되겠죠? 그래서 배열을 선언하면 첫번째 원소의 주소가 배열의 이름에 저장됩니다.// 주소는 0x00, 0x04, 0x08... 과 같은식으로 일정한 간격이 됩니다int s[5] = {10, 20, 30, 40, 50};printf(&quot;%d %d&quot;, *s, *(s+4)); // 10, 50 출력첫번째는 변수를 쓸때 *를 붙여서 포인터인 s가 가진 주소의 값을 출력해서 10이 나오고, 두번째는 첫번째 주소부터 4칸 뒤의 주소의 값을 출력해서 50가 나오게 됩니다. 일단 괄호를 사용한 이유는, * 연산자의 우선순위가 +보다 높아서(거의 가장높습니다) 그냥 *s + 4라고 쓰면 10 + 4 가 되어서 14가 나오게 됩니다.다음으로, s + 4를 하면 4바이트만큼 건너뛰는 게 아닌가? 라고 생각하실 수 있는데, 포인터 자료형에 +를 사용하면 다르게 계산되어서 해당 포인터의 크기만큼 건너뛴 게 됩니다. int*의 경우 int가 4바이트기 때문에 s + 1을 하면 4바이트를 건너뛰어서 20이 나오는 식이죠.그런데 배열을 다룰때 맨날 이렇게 쓰면 귀찮고 힘들기때문에 위를 간편하게 만들어서 다음과 같은 식이 나오게 되었습니다.s[0] s[1] // *(s + 0), *(s + 1) 과 같습니다그리고 이게 바로 배열이 0부터 시작하는 이유이기도 하죠!함수와 포인터포인터를 배우실때 이해가 되셨든, 안되셨든 “대체 이게 왜필요한거지?” 라는 생각이 들으실 수 있습니다. 포인터는 바로 함수에서 진가를 발휘하는데요.void Swap(int a, int b) { int tmp = a; a = b; b = tmp;// 그냥 a = b; b = a; 하시면 a = b 하는순간 a에있던 값이 사라지고 b값이랑 똑같아지기 때문에 위와 같이 임시변수에 원본값을 저장해서 바꿔줍니다.}int main(){ int x = 5, y = 3; Swap(x, y); printf(&quot;%d %d&quot;, x, y); return 0;}두 변수의 값을 바꾸는 Swap(int, int) 함수를 만들었습니다. 출력 결과는 어떻게될까요? 5 3이 나옵니다. 왜냐면 Swap에 x와 y를 넣어준다 하더라도 이건 x와 y가 가지고 있는 값을 사용하는것이기 때문에, x와 y의 값 자체는 바뀌지 않습니다. 정확히는, Swap(x, y) 와 같이 사용하면 x값이 복사되어서 a에 들어가고, y값이 복사되어서 b에 들어갑니다. 이를 값에 의한 호출(Call by Value) 라고 합니다.그래서 만약 넘겨준 x, y값 자체가 바뀌는 함수를 만들고 싶다면 다음과 같이 포인터를 사용해야합니다.void Swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp;}int main(){ int x = 5, y = 3; Swap(&amp;amp;x, &amp;amp;y); printf(&quot;%d %d&quot;, x, y); return 0;}이렇게 원본값을 참조해서 사용하는것을 참조에 의한 호출(Call by Reference)라고 합니다.이제 scanf_s() 를 호출할 때 왜 변수에 &amp;amp;를 붙여주는지도 이해가 되시나요? 또, 위에서 배열은 포인터라고 설명드렸다시피 포인터를 사용하면 배열을 입력받을수도 있습니다!상수 변수, 상수 포인터상수변수는 말그대로 값을 못바꾸는 변수입니다. static과 마찬가지로 자료형에 const를 앞이나 뒤에 붙여주면 됩니다. 평소라면 진짜 쓸모없지만 함수에서는 혹시나 값을 실수로 바꾸고 싶지 않은 경우에, 주로 포인터와 같이 사용됩니다.const int PI = 3.141592const(상수) 변수는 선언 후에 값을 바꾸지 못하기 때문에, 무조건 선언과 동시에 초기화해주어야 합니다.상수 포인터의 경우, 포인터가 가리키고 있는 주소안의 값 을 바꾸지 못한다는 기능을 가지고 있습니다.int main() { int a = 0; const int* p = &amp;amp;a; // int const* p = &amp;amp;a 도 가능합니다 *p = 5; // 에러 return 0;}그래서 p가 가리킬 주소를 변경할 수는 있지만, 가리키고 있는 주소의 값을 바꾸지는 못합니다. 그런데 상수 포인터에서 만약 *보다 뒤에 const를 붙이면, 이는 다른 의미가 되는데요int main() { int a = 0, b = 5; int* const p = &amp;amp;a; *p = 5; p = &amp;amp;b; // 에러 return 0;}이는 가리키고 있는 주소를 바꾸지 못한다는 뜻입니다. 그래서 가리키고 있는 주소의 값을 바꿀수는 있지만, 다른 대상을 가리키게는 못하죠.const int* const a;두개는 혼용해서 쓸 수 있으며, 이런게 있다는 것만 알아두고 혹시 나중에 필요해지면 적재적소에 써먹도록 합시다. 몰라도 프로그래밍에는 지장이 없지만, 실수로 값을 바꾸는 행위 등을 막기 위해 주로 사용됩니다.밑의 2가지 개념들은 매우 어려울 수 있어서 부록으로 분리했으니, 참고만 하시길 바랍니다.부록: 재귀 함수재귀recursive 함수란, 함수 내부에서 자기 자신을 호출하는 것을 의미합니다. 어떻게 보면 무한 반복문이라고도 볼 수 있죠. 예를들어 N! (팩토리얼, 5! == 5*4*3*2*1) 은 재귀함수로 다음과 같이 나타낼 수 있습니다.int fact(int n) { if (n == 1) return 1; return n * fact(n - 1);}int main() { printf(&quot;%d&quot;, fact(5)); // 120}처음에 n에 5가 들어갔고, n은 1이 아니니까 5 * fact(4) 가 return됩니다. 그런데 return하기전에 함수를 먼저 실행해서 fact(4)가 호출되면 이 함수는 4 * fact(3) 을 반환합니다. 그 다음은 3 * fact(2), 2 * fact(1)… fact(1)은 1을 반환하고 더이상 fact()를 호출하지 않아서 이제 거꾸로 빠져나옵니다. 그러면 2 * fact(1)에서 fact(1)의 반환값이 1이었으니 2 * 1 이 되고, 이게 반환되어서 3 * fact(2) 에서 fact(2)의 반환값이 2 * 1 이었으니 3 * 2 * 1이 되고, 그다음은 4 * 3 * 2 * 1, 그다음은 5 * 4 * 3 * 2 * 1 이 되면 마지막으로 main함수에 5 * 4 * 3 * 2 * 1 의 값인 120 을 전달하고 끝이 납니다.이것이 재귀 함수의 원리이며, 지금 이해하시기에는 많이 힘들 수 있으니 이런 기법이 있다는 것 정도로만 알아두시면 좋습니다.부록: 함수 포인터함수에도 포인터가 있습니다. 어? 그러면 함수 코드가 메모리(RAM)에 있어야 하지 않나요? 네. 함수뿐만 아니라 코드 전체가 메모리에 존재합니다. 그럼 함수 포인터는 무슨 기능을 하냐면, 매개변수와 반환타입이 같은 함수라면 아무거나 넣어줄 수가 있습니다. 바로 예제부터 보여드리도록 하죠int add(int a, int b) { return a + b;}int sub(int a, int b) { return a - b;}int mul(int a, int b) { return a * b;}int div(int a, int b) { return a / b;}int main() { int (*op)(int, int); op = add; printf(&quot;%d\\n&quot;, op(10, 5)); op = sub; printf(&quot;%d\\n&quot;, op(10, 5)); op = mul; printf(&quot;%d\\n&quot;, op(10, 5)); op = div; printf(&quot;%d\\n&quot;, op(10, 5));}함수 포인터는 다음과 같이 정의합니다.&amp;lt;반환 타입&amp;gt; (*&amp;lt;포인터 이름&amp;gt;)(&amp;lt;매개변수들&amp;gt;);그러면 해당 함수 포인터와 똑같은 구조인 함수를 아무거나 넣어줄 수 있는데, 그래서 만들어진 게 위와 같은 코드입니다. int형을 반환하고 int타입 매개변수를 2개 받는 사칙연산 연산자들을 만들어서, 함수 포인터가 가리키게 만들어서 호출하는 것이죠. 이 함수 포인터는 이후 객체지향에서 대리자(delegate)라고도 불리는 문법으로 발전하게 되는데, 엄청난 활용도를 가진 기능입니다.일단 이쯤되서 프로그래밍은 공부하는것이 아니라면 혼자 개발할 일이 별로 없다는 점을 인지하셔야 합니다. 그래서 이 함수 포인터를 어떻게 써먹냐면, 예를들어 값을 순서대로 정렬하는 sort()라는 함수를 만들었다고 합시다. 정렬을 해주는 알고리즘은 여러가지가 있는데, 그중 가장 간단한 버블정렬을 사용하였습니다.버블 정렬이란, 5 2 4 3 1 과 같은 값이 배열에 들어있고 오름차순으로 정렬하려한다면, 이 배열을 반복문으로 순서대로 보면서 자기가 가진 숫자와 자기 다음숫자끼리 비교해서 만약 뒤의 숫자가 더 작다면 서로 위치를 교환해하는 것입니다.한번 반복하게 되면 5가 제일 크기때문에 5 뒤에있는 숫자와 계속 자리를 바꿔주어서 5가 자신의 자리로 가게 되겠죠.2 4 3 1 5그런데 맨 오른쪽에있던 1이 맨 왼쪽까지 오려면 최소한 4번(길이-1)만큼 반복해줘야 하기 때문에 위의 작업을 길이-1만큼 반복해주는게 버블 정렬입니다.#include &amp;lt;stdio.h&amp;gt;void sort(int* arr, int size, int (*op)(int, int)) { for (int i = 0; i &amp;lt; size - 1; i++) { for (int j = 0; j &amp;lt; size - 1; j++) { if (op(arr[j], arr[j + 1])) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } }}int bigger(int a, int b) { return a &amp;gt; b;}int lesser(int a, int b) { return a &amp;lt; b;}int main() { int arr[10] = { 10, 5, 2, 4, 7, 8, 1, 3, 9, 6 }; for (int i = 0; i &amp;lt; 10; i++) printf(&quot;%d &quot;, arr[i]); printf(&quot;\\n&quot;); sort(arr, 10, bigger); for (int i = 0; i &amp;lt; 10; i++) printf(&quot;%d &quot;, arr[i]); // 내림차순 정렬 printf(&quot;\\n&quot;); sort(arr, 10, lesser); for (int i = 0; i &amp;lt; 10; i++) printf(&quot;%d &quot;, arr[i]); // 오름차순 정렬 printf(&quot;\\n&quot;);}만약 이 코드가 이해가 되셨다면, 함수 포인터가 엄청난 녀석이란걸 아실겁니다. sort()는 배열과 배열의 길이, 그리고 함수 포인터를 매개변수로 받는데 이 함수 포인터는 정렬 내부에서 대소비교를 할 때 쓰이게 됩니다. 그래서 현재 숫자보다 뒤의 숫자가 더 작을때 참(True)를 반환하는 lesser, 그 반대인 bigger를 만들어서 넘겨주면 넘겨준 함수에 따라 정렬순서가 바뀌게 됩니다.이 코드가 너무 어려우시면 나중에 실력이 쌓인 다음에 보시는 걸 추천합니다. 참고로, 이거 쓸줄 몰라도 프로그래밍 하는데 지장이 아예 없습니다!문자열string문자열이란, 간단하게 문자의 나열이라는 뜻입니다. char 타입은 문자 하나를 저장하는 자료형인데, 만약 &quot;Hello, World&quot; 와 같은 문자열을 저장하려면 어떻게 해야할까요? 정답은 [배열을 사용한다] 입니다. char str[50] = &quot;Hello, World&quot;; 처럼 할 수 있죠.또, 다시 알려드리자면 C언어에서 작은따옴표(‘ ‘)는 문자를 의미하고, 큰따옴표(“ “)는 문자열을 의미합니다.아스키 코드우리가 char형에 문자를 저장할 때, 실제로 문자가 저장되는 것이 아니라, 해당 문자의 아스키코드에 해당하는 값이 저장됩니다. 이 아스키코드는 문자를 표현하기 위한 규약이라고 볼 수 있는데, 예를들어 ‘A’ 의 아스키 코드는 65고, ‘a’ 의 아스키 코드는 97입니다. 이런식으로 문자마다 대응되는 숫자가 존재하고, 문자를 저장할 때는 해당 숫자로 저장이 되고 문자를 출력할 때는 그 숫자에 해당하는 문자가 출력되죠. 참고로 문자로 ‘0’ 은 0이 아니라 48입니다. 아스키 코드를 외울 필요는 전혀 없으며, 아스키 코드로 저장된다는 점만 알아두시면 됩니다.널null 문자&quot;ABC&quot; 라는 문자열이 있는데, 이 문자열의 길이는 어떻게 알 수 있을까요? 3글자니까 3개가 아니냐고요? 맞는데, 프로그램이 배열의 길이를 알아낼 수 있는 방법은 없죠(방법이 하나 있기는 한데, 언제나 사용가능하진 않습니다). 그래서 C언어에서는 마지막 문자 뒤에 아스키 코드로 0에 해당하는 &#39;\\0&#39; 이라는, NULL이라고 불리는 문자를 추가하는 방법을 생각해 냈습니다. 길이를 알고 싶다면, 문자열의 0번째부터 계속 반복을 하다가 만약 문자열의 i번째가 &#39;\\0&#39; 이라면 그때 i의 값이 해당하는 문자열의 길이인 것이죠.char str[] = &quot;ABC&quot;; // 문자열을 넣어줄 때는 배열의 크기를 적지 않아도 되는데, 이 경우 넣어준 문자열의 길이만큼 자동으로 설정됩니다.int i;for(i = 0; str[i] != NULL; i++) // != &#39;\\0&#39;, != 0, 또는 왼쪽처럼 NULL이라고 적어도 됩니다. NULL은 기호상수중 하나며, 숫자 0과 똑같습니다. printf(&quot;%c&quot;, str[i]);printf(&quot;\\n문자열의 길이: %d&quot;, i);위 코드처럼 “ABC” 자체를 넣어주면, 큰따옴표는 끝에 NULL문자를 자동으로 삽입해주기 때문에 str배열은char str[4] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;\\0&#39;}; 을 해준 것과 똑같이 되는 것이죠. 만약 “ABC” 를 넣어주지 않고 하나씩 일일이 {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;} 을 넣어줬다면 뒤에 NULL문자가 삽입되지 않는다는 점을 주의해주세요. 또, 문자열 배열에는 NULL문자가 들어갈 공간이 있어야합니다. 위처럼 문자열의 길이를 알아내야 할 경우는 매우 많기 때문에, 문자열의 길이를 반환하는 strlen()이라는 함수가 존재하는데, 나중에 알려드리겠습니다.문자열 입력받기문자열을 입력받을 때는 “%s” 를 사용하면 됩니다. 복잡한 것은 없으니 바로 보여드리겠습니다.char str[50]; // 몇글자까지 들어올 지 모르기 때문에 50이라고 적어줬습니다. 그럼 NULL문자가 들어갈 공간을 제외한 49글자까지 받을 수 있는거죠. 공간이 남아도거나 부족할 수 있다는 비효율적인 문제는 나중에 &quot;동적 메모리&quot; 에서 배우게 됩니다.scanf_s(&quot;%s&quot;, str, 50);printf(&quot;%s&quot;, str);scanf_s()를 처음 설명드릴때, 문자를 입력받을 때는 몇글자까지 받을 수 있는지를 뒤에 적어준다고 했었습니다. 이는 그냥 선언해준 배열의 크기로 정해주면 됩니다. 또, %s로 입력받을때는 &amp;amp;를 사용하지 않는다는 것을 알 수 있는데, 이는 배열과 포인터에서 설명드렸다시피 배열의 이름은 포인터이기 때문에, 이미 주소를 담고 있기 때문입니다. 또, %s가 문자열을 입력받기 때문에 입력받은 문자열을 배열의 시작 위치부터 자동으로 넣어주기도 합니다. 위에 코드는 문자열을 입력받고, 문자열을 출력하는 간단한 프로그램인데, 실행하고 Hello, World 같은식으로 입력하면 Hello, 만 나오는 것을 볼 수 있습니다. 왜냐면 scanf_s는 **탭키&#39;\\t&#39;, 공백&#39; &#39;, 줄바꿈&#39;\\n&#39; 문자에서 입력을 멈춰버리기 때문인데요. 그래서 만약 띄어쓰기가 포함된 문장을 입력받고 싶다면 gets_s() 를 사용해야합니다.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int main() { char str[50]; gets_s(str, 50); printf(&quot;%s&quot;, str);}gets_s()도 마찬가지로 _s가 붙었기도 하고, 문자와 관련되어있기 때문에 몇글자까지 받는지 적어줍니다. 사용법은 저게 끝! 그리고 gets_s() 는 라는 라이브러리 안에 들어있습니다. 에는 문자열을 편하게 다루게 도와주는 내장함수들이 있습니다. 종류가 다양하고 문자열을 다룰 때만 사용되기 때문에 아래의 링크를 참고해주세요!https://modoocode.com/77왼쪽 카테고리에서 C -&amp;gt; C Reference -&amp;gt; string.h 아래있는 함수들을 참고하시면 됩니다.구조체struct구조체란, 나만의 자료형을 만드는 것입니다. 배열처럼 값 여러개를 기억하게 할 수도 있는데, 구조체는 서로 다른 타입 또한 포함할 수 있습니다. 만약 지금까지 배운대로 학교에서 학생들의 정보를 저장하게 한다고 해봅시다. 만약 학생이 30명정도 된다면 다음과 같이 적어줘야 했을겁니다.int student_number[30], age[30];char name[30][10];쓰는데는 지장이 없지만, 자료들이 서로 분리되어 있어서 접근성과 가독성이 떨어지게 됩니다. 하지만 만약 구조체를 쓰면 어떻게될까요?struct student { int student_number, age; char name[10];};int main() { struct student stu_list[30]; // ...이하생략}이렇게 간단하게 표현될 수 있습니다! 그럼 이제 구조체 변수를 사용하는 방법을 자세히 알아보도록 할까요?struct point { int x, y;};int main() { struct point p1, p2; struct point p3 = {2, 3}; p1.x = 5; p1.y = -10; scanf_s(&quot;%d %d&quot;, &amp;amp;p2.x, &amp;amp;p2.y); printf(&quot;p1: %d, %d\\n&quot;, p1.x, p1.y); printf(&quot;p2: %d, %d\\n&quot;, p2.x, p2.y); printf(&quot;p3: %d, %d\\n&quot;, p3.x, p3.y);}위에서 볼 수 있듯이 point 구조체 안에 int x, y; 로 int타입의 변수 2개를 선언해 주었는데, 이를 멤버 변수, 필드 변수라고도 부릅니다. 그럼 이제 point 구조체는 x, y를 멤버(필드) 로 가지는 새로운 자료형이 되는것이죠. 구조체 변수를 선언할 때는 struct까지 포함하여 타입(자료형) 이름이기 때문에, struct point &amp;lt;변수명&amp;gt; 처럼 선언해주었습니다. 또, 구조체 변수를 사용할 때 &amp;lt;구조체변수&amp;gt;.&amp;lt;구조체필드&amp;gt; 와 같이 사용해 주는데, 접근 방식만 다를뿐 변수를 사용한다는 점은 똑같습니다. 또, p3의 경우 배열과 같이 {2, 3} 처럼 선언과 동시에 초기화해줄 수 있습니다. 이 경우는 구조체에서 선언한 변수의 순서대로 값이 자동으로 들어가게 되죠.구조체는 보기에는 어려워 보이지만, 단순히 새로운 자료형을 선언해 주는 것이라고 볼 수 있습니다! 언어가 제공하는 int, float과 같은 기본 자료형들을 원초(primitive) 자료형이라고 하는데, 한 가지 종류의 값만 가지고 있는 이 원초 자료형들을 여러개 묶어서 새 자료형을 만드는 것이 구조체입니다.typedeftypedef란, 어떤 자료형을 부르는 이름을 추가해주는 키워드입니다.typedef int number;int main() { number a, b; // int a, b; 와 동일합니다}위처럼 그냥 int를 number로도 부를 수 있게 해주는 것이죠. 그래서 평소엔 이게 엄청 쓸데없는데, 구조체를 사용할 때는 typedef를 써서 더 이름을 부르기 편하게 만들 수 있습니다.struct point { int x, y, z;};typedef struct point point;int main() { point v; v.x = 5; v.y = 10; v.z = -5;}struct point 타입을 point 로 typedef 를 해주면, 앞으로 구조체 변수를 선언할 때마다 앞에 struct를 붙여줄 필요가 없겠죠? 그런데 이것을 더 쉽게 해줄 수 있는 방법이 있습니다.// typedef struct point로 해도 됩니다.typedef struct { int x, y, z;} point;int main() { point v; v.x = 5; v.y = 10; v.z = -5;}바로 구조체의 선언과 동시에 해당 구조체를 typedef 해주는 것인데요, 자료형의 선언과 동시에 point라는 이름으로 불리도록 해주는 것입니다. 대부분의 경우 구조체를 선언할 때 이와 같이 해주는데, C++로 넘어와서는 기본적으로 구조체 변수에 struct 를 붙이지 않아도 되도록 바뀌기도 하고, C언어로 개발을 하실 일은 별로 없으실테니 이런게 있다는 것만 알아두시면 되겠습니다!함수에 구조체 쓰기위에서 설명드렸다시피 구조체는 나만의 자료형을 새로 만드는 것과 똑같기 때문에, 그냥 자료형처럼 사용하면 되지만 헷갈리실 수 있으니 예시를 보여드릴게요!struct point { int x, y;} ;struct point subtract(struct point a, struct point b) { struct point result; result.x = a.x - b.x; result.y = a.y - b.y; return result;}int main() { struct point p1, p2; scanf_s(&quot;%d%d&quot;, &amp;amp;p1.x, &amp;amp;p1.y); scanf_s(&quot;%d%d&quot;, &amp;amp;p2.x, &amp;amp;p2.y); struct point result = subtract(p1, p2); printf(&quot;뺄셈 결과: (%d, %d)&quot;, result.x, result.y); return 0;}물론 위의 코드는 가독성이 꽤 떨어져서 typedef를 사용하여 다음과 같이 줄일 수 있습니다.typedef struct { int x, y;} point;point subtract(point a, point b) { point result; result.x = a.x - b.x; result.y = a.y - b.y; return result;}int main() { point p1, p2; scanf_s(&quot;%d%d&quot;, &amp;amp;p1.x, &amp;amp;p1.y); scanf_s(&quot;%d%d&quot;, &amp;amp;p2.x, &amp;amp;p2.y); point result = subtract(p1, p2); printf(&quot;뺄셈 결과: (%d, %d)&quot;, result.x, result.y); return 0;}구조체 포인터구조체 포인터는 구조체 타입의 포인터입니다. 일반 변수와 별다를 것이 없지만, 한가지 새로운 연산자가 등장하게 되는데요, 위의 struct point 로 예를 들어보면,struct point val;struct point *p = val;*p.x = 5; // 오류 발생p-&amp;gt;y = 10; // 자기멋대로 바뀜 선언은 아시는대로 변수 앞에 *를 붙이면 끝납니다. 그런데 이 다음에 a의 x, y값을 바꾸려고 하면 이상한 오류가 발생하거나, . 연산자가 자기멋대로 -&amp;gt; 로 바뀌게 됩니다. 이것의 이유는 * 연산자의 우선순위보다 . 연산자의 우선순위가 더 높아서인데요, 그래서 *p.x = 5; 와 같은 문장을 작성하면 일단 point 구조체의 포인터 타입인 p 변수가 x 멤버를 참조한다는 건데, 포인터에는 그런게 없으므로 오류가 발생하게 되는 것이죠.그래서 (*p).x 과 같이 괄호로 * 연산을 먼저 처리해줘야 합니다. 하지만 이게 보기도 불편하고, 포인터의 포인터의 포인터… 같이 복잡해지면 보기에도 엄청 불편하기 때문에 (*(*(*p1).node).node).node 과 같이 됩니다.그래서 C언어는 -&amp;gt; 이라는 새로운 연산자를 도입했습니다. p-&amp;gt;x 는 (*p).x 와 똑같은 의미가 되는거죠! 방금 위에 예시코드도 이 연산자를 쓰면 p1-&amp;gt;node-&amp;gt;node-&amp;gt;node 와 같이 보기좋게 바꿀 수 있게 됩니다.공용체구조체랑 똑같은 방법으로 쓰는데, 공용체 자료형 변수를 선언하면 공용체 내 변수중 가장 크기가 큰 자료형만큼만 메모리를 할당합니다.union test { int a; // 4바이트 char b; // 1바이트};int main() { union test t; t.a = 10000; printf(&quot;%d %c\\n&quot;, t.a, t.b); t.b = &#39;a&#39;; printf(&quot;%d %c\\n&quot;, t.a, t.b);}위의 test가 구조체였다면, int를 위한 공간과 char를 위한 공간을 할당을 해서 총 5바이트가 할당되겠지만, 공용체는 제일 큰 자료형인 int만큼, 그러니까 4바이트만큼의 공간만을 할당합니다. 그래서 a만 바꿨는데 b의 값도 바뀌고, b의 값만 바꿨는데 a의 값도 바뀌게 되는 것이죠.공용체는 주로 운영체제와 같이 극한의 최적화가 필요한 상황에만 주로 사용되기 때문에 이런게 있다라고만 알아두시면 됩니다.열거형숫자에 의미를 부여하기 위해 사용됩니다. 무슨 말이냐고요? 다음 코드를 보시죠.enum days { MON, TUE, WED, THU, FRI, SAT, SUN };int main() { char weeks[7][10] = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot; }; for (int i = MON; i &amp;lt;= SUN; i++) printf(&quot;오늘은 %s!\\n&quot;, weeks[i]); return 0;}우리가 0번째 일부터 6번째 일까지! 라고 하는것보다 월요일부터 일요일까지! 라고 하는 게 더 편하기 때문에, 열거형이라는 것이 추가되었습니다. 사실 열거형은 사용되는 특수한 상황이 존재하는데, 그 상황이 올 정도면 C언어를 이미 잘 다룰 수 있게 되셨을 때니까 이런 기능이 있다라고만 알아두시면 됩니다! 참고로, MON부터 시작해서 0, 1, 2, 3, 4, 5, 6 과 같이 말 그대로 숫자에 이름이 붙는 형식으로 작동됩니다.파일 입출력변수에 저장된 값들은 RAM에 저장되는데, 이 정보들은 프로그램이 종료되면 전부 사라져버리게 됩니다. 만약 프로그램이 끝나도 정보를 저장해놓고, 프로그램을 켰을 때 저장된 정보를 불러오게 하고 싶다면 하드디스크에 저장을 해야하는데, 그러기 위해서 사용되는 것이 파일이죠!int main() { FILE* fp; fopen_s(&amp;amp;fp, &quot;data.txt&quot;, &quot;w&quot;); if (fp == NULL) { perror(&quot;파일을 열지 못했습니다.&quot;); return 1; } int test; scanf_s(&quot;%d&quot;, &amp;amp;test); fprintf(fp, &quot;파일에 정상적으로\\n입력 완료되었습니다! %d&quot;, test);}위의 코드를 실행하고, 아무 숫자나 입력해 보고, 소스코드가 있는 폴더에 들어가보면 (어딨는지 모르시다면 [솔루션 탐색기] 에서 “솔루션 ~~~” 를 우클릭하고 [파일 탐색기에서 폴더 열기] 를 클릭해보세요) data라는 .txt 파일이 생성되고, 그 안에는 잘 적힌 걸 보실 수 있습니다!fopen_s(파일포인터, 파일이름+확장자, 모드)파일을 여는 역할을 합니다. 파일에서 입력받을 때는 파일의 주소를 알아야 하기 때문에 FILE * 타입을 사용해서 입력받습니다. 두번째 매개변수에는 확장자를 포함한 파일 이름을 적고, 세번째 매개변수는 파일을 열 때 선택할 모드인데, 주로 아래 3가지가 사용됩니다.r : read, 입력할 때 씁니다. 파일이 없으면 오류가 발생합니다.w : write, 출력할 때 씁니다. 파일이 없을 경우 새로 만들고, 있으면 덮어씌웁니다.a : append, 출력할 때 씁니다. 파일이 없을 경우 새로 만들고, 있으면 뒤에 이어적습니다.-b : rb, wb와 같이 사용되며 binary라는 이진 파일로 저장이 됩니다. 나중에 알아보세요!파일과 관련된 함수들은 평소에 쓰던것과 똑같은데(fprintf, fscanf_s, fgets_s) 실제로 사용법도 똑같습니다. 대신, 첫번째 매개변수로 사용할 파일 포인터를 넘겨줍니다.아래 예제를 진행하기 전에, 코드와 같은 경로에 input.txt 라는 파일을 하나 만들고, 안에 숫자를 원하는 만큼 적어주세요! (띄어쓰기나 줄바꿈 해서)int main() { FILE *fin, *fout; fopen_s(&amp;amp;fin, &quot;input.txt&quot;, &quot;r&quot;); fopen_s(&amp;amp;fout, &quot;output.txt&quot;, &quot;w&quot;); if (fin == NULL || fout == NULL) { printf(&quot;파일을 열지 못했습니다!&quot;); return 1; } int sum = 0, cnt = 0, max = -2000000000, min = 2000000000, tmp; while (fscanf_s(fin, &quot;%d&quot;, &amp;amp;tmp) != EOF) { sum += tmp; cnt++; if (tmp &amp;gt; max) max = tmp; if (tmp &amp;lt; min) min = tmp; } fprintf(fout, &quot;합계는 : %d\\n&quot;, sum); fprintf(fout, &quot;평균은 : %.2lf\\n&quot;, (double)sum / cnt); fprintf(fout, &quot;최대, 최소값은 : %d, %d&quot;, max, min);}그러면 출력이 잘 나오실 거고, 이제 파일 함수들 쓰는 방법도 아셨을거라 생각합니다. 여기서 중요한 점은 fscanf_s(fin, &quot;%d&quot;, &amp;amp;tmp) != EOF 부분인데, 파일로 입력을 받을 경우에는, 파일 끝에 도달했을때 EOF라는 값을 읽어오는데, 이는 End of File 의 약자입니다. 그래서 위의 문장은 파일에서 입력받은 값이 EOF가 아닌 동안 반복을 하는 것이죠. (EOF는 사실 -1라는 값입니다.)절대경로, 상대경로fopen_s(..., &quot;input.txt&quot;, ...) 를 사용할 때, 중간에는 사실 파일의 경로까지 포함해서 적어줘야 합니다. 하지만 아무 경로도 입력해주지 않아도 코드랑 같은 위치에 파일이 생성되는데, 이는 상대 경로가 사용되어서 그렇습니다. C:/ 처럼 최상위 경로인 드라이브부터 모든 경로를 적는 것은 절대 경로 라고 하며, 예외없이 무조건 똑같은 경로에 파일이 생성됩니다. 상대 경로는 특정 폴더를 기준으로 하는 경로이며, 주로 소스 파일과 같은 경로/프로젝트의 경로가 기준이 됩니다../input.txt : ./는 현재 폴더를 의미하는데, 적어주지 않아도 현재 폴더가 기준이 됩니다.../input.txt : ../는 상위 폴더를 의미합니다. 그러니까 상위 폴더에 있는 input.txt를 의미합니다../File/Resources/input.txt : ./는 적어주지 않아도 되는데, 현재 폴더에 있는 File 폴더 내의 Resources 폴더 내의 input.txt를 의미합니다.위의 3가지가 상대경로를 사용하는 방법이고, 이걸 이용해서 어느 폴더나 이동할 수 있습니다! 절대 경로를 쓰는 경우는 거의 없다고 봐도 무방해요.../../Debug/Resources/input.txt 처럼 혼합해서 사용할 수 있고, 우리가 폴더를 다루듯이 똑같이 사용하면 된다고 이해하시면 됩니다.동적 메모리동적 메모리란 말 그대로 프로그램 실행 중에 동적으로(원하는 값으로) 배열을 선언하는 겁니다. 왜냐면 C언어에서는 배열의 크기를 무조건 상수(숫자)로밖에 정해줄 수 없기 때문이죠.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int main() { int N; scanf_s(&quot;%d&quot;, &amp;amp;N); int* arr = (int*)malloc(sizeof(int) * N)); for (int i = 0; i &amp;lt; N; i++) { scanf_s(&quot;%d&quot;, arr[i]); } for (int i = 0; i &amp;lt; N; i++) { printf(&quot;%d &quot;, arr[i]); } free(arr);}malloc() 은 수동으로 메모리를 할당하는 함수입니다. 이게 무슨 뜻이냐면, 원래는 변수를 선언하면 알아서 해당 변수의 자료형의 크기(예: int면 4바이트) 만큼을 할당하고, 배열 또한 마찬가지인데 그 N바이트를 할당하는 것을 malloc()으로 해줄 수 있습니다. 예를들어 malloc(40)하면 40바이트의 공간이 할당되는 것이죠.그런데 이 할당된 공간은 int형 기준으로 봤을때는 10개가 들어가고, char형 기준으로 봤을때는 40개가 들어갈 수 있는 공간입니다. 그래서 이 함수는 아무 포인터 타입(자료형)으로나 바뀔 수 있도록 void * 타입을 반환하게 되는데, 이는 명시적 형변환 으로 우리가 써줄 타입으로 변환해주어야 합니다. 그래서 위 코드에서는 int형 배열을 만들고 싶기 때문에 int *형 변수를 선언하고, malloc의 반환값을 명시적 형변환 (int *) 을 이용해 타입을 바꿔준 것이죠.위쪽 챕터에서 “배열과 포인터” 를 찾아보시면 왜 이것만으로 원하는 길이의 배열을 만들 수 있는지 알 수 있는데, 배열을 선언한다는 것은 포인터를 선언하는 것과 같고, 해당 포인터가 배열의 크기만큼 선언된 메모리들의 첫번째 주소를 가지고 있기 때문입니다. 변수랑은 다르게, 배열을 선언하면 배열의 모든 원소들의 주소가 메모리상에 이어져 있기 때문이죠.sizeof(&amp;lt;자료형&amp;gt;) 은 안쪽에 아무 자료형이나 넣으면 해당 자료형의 크기를 알려줍니다. 왜냐면 int가 4바이트고, double은 8바이트다라는 메모리 크기를 다 외우고 다닐수도 없고, 특히나 구조체의 경우는 구조체 내부의 모든 멤버변수의 크기의 합을 구해야 하기 때문에 헷갈릴 수 있기 때문이죠. 그래서 위의 코드에서 sizeof(int) * N 부분은 int 타입의 크기가 N개만큼 있는 메모리 크기라고 해석할 수 있습니다.free() 는 할당된 메모리를 해제해주는 역할을 합니다. 수동으로 할당했기 때문에, 자동으로 해제되지 않아서 까먹지 말고 꼭 메모리를 해제해주어야 합니다. 아니면 코드가 실행될 때마다 메모리를 할당하고, 그 할당된 메모리가 쓰이지는 않지만 남아있어서 메모리 누수가 발생할 수 있거든요.2차원 배열을 동적 할당하고싶으면 다음과 같이 더블 포인터를 사용해주면 됩니다. 포인터의 포인터가 있어야 배열의 배열을 사용할 수 있기 때문이죠.int N, M;scanf_s(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);int** arr = (int**)malloc(sizeof(int*) * N);for (int i = 0; i &amp;lt; N; i++) { arr[i] = (int*)malloc(sizeof(int) * M);}// 출력 등등for (int i = 0; i &amp;lt; N; i++) { free(arr[i]);}free(arr);일단 배열들의 위치를 기억할 공간을 동적할당하고, 그 배열들을 각각 또 따로 동적할당 해줍니다. 그래서 메모리를 해제할 때도 배열 안의 배열들을 먼저 해제해주고, 마지막으로 배열들의 위치를 가지고 있는 포인터를 해제해 줘야 하죠.더 알아보기부록: 매크로 함수매크로 함수는 함수의 내용을 어느정도 이해하셨다면 아래의 글을 보고 쉽게 이해하실 수 있을거에요.링크부록: 모듈화 프로그래밍지금까지는 거의 소스파일 하나에서만 작업을 했지만, 실제 프로그램에서 이렇게 하면 보기도 불편하고, 다른사람과 협업할 수도 없겠죠? 그래서 아래 글은 소스코드를 분리하는 법을 알려줍니다.링크부록: 전처리기#include 와 같이 #이 붙는 키워드는 전처리기라고 합니다. 가끔 요긴하게 사용되죠.링크" }, { "title": "[BOJ] 2505 두 번 뒤집기", "url": "/posts/BOJ-2505/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2021-09-28 15:16:00 +0900", "snippet": "KOI 2008 E5/M3문제의 예제를 예시로 들자면, 이 문제에서 v[i]번째에 와야하는 숫자는 i라는 것을 알 수 있습니다. v[1] v[2] v[3] v[4] v[5] v[6] v[7] v[8] v[9] v[10] 6 7 8 2 1 5 4 3 9 10 이를 이용해 배열을 직접 뒤집어 보고, 결과가 맞으면 출력, 아니면 끝에서부터 뒤집어보기를 할 수 있습니다. 더 오른쪽에 있는 뒤집기를 해야 답이 나오는 경우가 있기 때문이죠.더 자세하게는, v[i]번째가 i가 아니라면, 위의 예제에서는 v[1]번째가 1이 아니라면 1의 위치를 배열에서 찾고, i부터 1이 있는 위치까지를 뒤집어 주면 됩니다. 소스 자체는 그렇게 어렵지 않기 때문에 전체 소스를 첨부합니다. 전체 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;void reverse(vector&amp;lt;int&amp;gt;&amp;amp; v, int start, int end) { int tmp; for (int i = start; i &amp;lt;= (start + end) / 2; i++) { tmp = v[i]; v[i] = v[end + start - i]; v[end + start - i] = tmp; }}int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;int&amp;gt; v1(N + 1); for (int i = 1; i &amp;lt;= N; i++) cin &amp;gt;&amp;gt; v1[i]; vector&amp;lt;int&amp;gt; v2(v1); pair&amp;lt;int, int&amp;gt; res[2] = { {1, 1}, {1, 1} }; int len = 0; for (int i = 1, j; i &amp;lt;= N; i++) { if (v1[i] != i) { for (j = i + 1; j &amp;lt;= N; j++) if (v1[j] == i) break; reverse(v1, i, j); res[len].first = i; res[len].second = j; if (++len == 2) break; } } bool isvalid = true; for (int i = 1; i &amp;lt;= N; i++) { if (v1[i] != i) { isvalid = false; break; } } if (isvalid) { cout &amp;lt;&amp;lt; res[0].first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[0].second &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; res[1].first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[1].second; return 0; } len = 0; res[1] = {1, 1}; for (int i = N, j; i &amp;gt;= 1; i--) { if (v2[i] != i) { for (j = i - 1; j &amp;gt;= 1; j--) if (v2[j] == i) break; reverse(v2, j, i); res[len].first = j; res[len].second = i; if (++len == 2) break; } } cout &amp;lt;&amp;lt; res[0].first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[0].second &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; res[1].first &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[1].second; return 0;}" }, { "title": "[BOJ] 2610 회의준비", "url": "/posts/BOJ-2601/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2021-09-28 14:00:00 +0900", "snippet": "KOI 2004 M3/H3이 문제는 우선 위원회를 분류하기 위해 DFS/BFS 알고리즘을 이용하고, 위원회에서 모든 정점으로 가는 거리(의사전달시간)가 가장 짧은 사람을 대표로 선택하는 문제입니다. 거리는 여러가지 방법이 있지만, N의 범위가 100 이하로 매우 작기 때문에 제 코드에서는 플로이드-와샬 알고리즘을 사용하였습니다.추신: 문제의 출력은 정렬되어야합니다. 전체 소스#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;const int INF = 101;int N, M;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; node;vector&amp;lt;bool&amp;gt; visited;void DFS(int idx, vector&amp;lt;int&amp;gt;&amp;amp; out) { visited[idx] = true; out.push_back(idx); for (size_t i = 1; i &amp;lt;= N; i++) if (!visited[i] &amp;amp;&amp;amp; node[idx][i] == 1) DFS(i, out);}int main() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; visited.resize(N + 1); // 플로이드-와샬 초기화 node.resize(N + 1, vector&amp;lt;int&amp;gt;(N + 1, INF)); for (size_t i = 1; i &amp;lt;= N; i++) node[i][i] = 0; int a, b; for (size_t i = 0; i &amp;lt; M; i++) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; node[a][b] = node[b][a] = 1; } // 위원회와 위원회원들 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph; for (size_t i = 1; i &amp;lt;= N; i++) { if (visited[i]) continue; graph.push_back({}); DFS(i, graph.back()); } // 플로이드-와샬 구현 for (size_t k = 1; k &amp;lt;= N; k++) for (size_t i = 1; i &amp;lt;= N; i++) for (size_t j = 1; j &amp;lt;= N; j++) if (node[i][j] &amp;gt; node[i][k] + node[k][j]) node[i][j] = node[i][k] + node[k][j]; // 결과 계산 vector&amp;lt;int&amp;gt; result(graph.size()); for (size_t i = 0; i &amp;lt; graph.size(); i++) { int val = N, target = 0; for (size_t j = 0; j &amp;lt; graph[i].size(); j++) { // i번째 위원회의 j번째 위원회원이 갈 수 있는 경로중 최댓값 int tmp = 0; for (size_t k = 1; k &amp;lt;= N; k++) if(node[graph[i][j]][k] != INF) tmp = max(node[graph[i][j]][k], tmp); // 최댓값이 가장 작은 사람이 그 위원회의 대표 if (tmp &amp;lt; val) { val = tmp; target = graph[i][j]; } } result[i] = target; } // 결과 출력 cout &amp;lt;&amp;lt; graph.size() &amp;lt;&amp;lt; endl; sort(result.begin(), result.end()); for (size_t i = 0; i &amp;lt; graph.size(); i++) cout &amp;lt;&amp;lt; result[i] &amp;lt;&amp;lt; endl;}" }, { "title": "[BOJ] 2591 숫자카드", "url": "/posts/BOJ-2591/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2021-09-19 12:58:00 +0900", "snippet": "KOI 2005 E5/M3이 문제는 완전탐색으로 구현한다면 숫자카드를 하나만 고르는 경우와 2개를 고르는 경우(면서 34가 넘어가지 않도록) 을 이용하면 다음과 같이 재귀함수로 간단하게 끝낼 수 있습니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;string in;int result;void search(string s, int idx) { if (idx == in.size()) { ++result; return; } if (idx + 1 &amp;lt; in.size() &amp;amp;&amp;amp; stoi(in.substr(idx, 2)) &amp;lt;= 34) search(s + in[idx] + in[idx + 1], idx + 2); search(s + in[idx], idx + 1);}int main() { cin &amp;gt;&amp;gt; in; search(&quot;&quot;, 0); cout &amp;lt;&amp;lt; result; return 0;}하지만 이렇게 풀면 무조건 시간초과가 나기 때문에 동적 계획법을 이용해야 하는데, 재귀함수를 응용해서 풀 수도 있지만 처음부터 점화식을 이용하여 더욱 간단하게 풀 수 있습니다.마지막으로 고른 숫자 카드가 십의 자리라면, 이후에 무엇을 고르더라도 경우의 수는 똑같습니다. 새로운 숫자카드가 추가될 수 밖에 없기 때문이죠. 그래서 계속해서 dp배열에 이전의 경우의 수를 복사하고, 만약 이전의 숫자카드와 합쳐질 수 있다면 경우의 수가 2배가 되므로, 2번째 전의 dp배열의 값을 더해주면 끝이 납니다.단, 반례가 있는데 숫자로 0이 들어올 수도 있습니다. 전체 소스#include &amp;lt;iostream&amp;gt;using namespace std;int main() { int dp[41] = {}; string s; cin &amp;gt;&amp;gt; s; dp[0] = 1; dp[1] = 1; s = &quot; &quot; + s; s[1] -= &#39;0&#39;; for (int i = 2; i &amp;lt; s.size(); i++) { s[i] -= &#39;0&#39;; if (s[i] != 0) dp[i] = dp[i - 1]; if (s[i - 1] * 10 + s[i] &amp;lt;= 34 &amp;amp;&amp;amp; s[i - 1] != 0) dp[i] += dp[i - 2]; } cout &amp;lt;&amp;lt; dp[s.size() - 1]; return 0;}" }, { "title": "[BOJ] 2504 괄호의 값", "url": "/posts/BOJ-2504/", "categories": "Lecture, Problemset", "tags": "BOJ", "date": "2021-01-19 21:04:00 +0900", "snippet": " 이번 문제는 꽤 까다로운 문제입니다. ‘스택’ 에 문자를 하나 하나 푸시(push)하면서 만약 닫는 괄호일 경우 스택의 내부를 맨 위에부터 돌아보며 맞는 여는 괄호일 경우 해당 자리를 2나 3으로 설정합니다. 만약 괄호가 아닐경우(숫자일 경우) 해당 숫자들을 여는 괄호를 만날 때까지 전부 더한 후, 여는 괄호의 자리에 그 값 * 2 또는 * 3을 합니다.  ( ( ) [ [ ] ] ) ( [ ] )위의 예시로 예를 들어보면, 스택 내부는 다음과 같이 됩니다. ( ( ( ( 2 ( 2 [ ( 2 [ [ ( 2 [ 3 ( 2 9 22 22 ( 22 ( [ 22 ( 3 22 6 모든 과정이 끝나면, 스택 내부에 있는 모든 숫자를 더하여 출력하면 끝이 납니다. 이 때, 만약 괄호가 존재한다면 그 괄호는 잘못된 것이기 때문에 0을 출력하고 종료하면 됩니다.참고로, 문자 자체를 사용한다면 ‘(‘ 의 아스키코드값과 일치하여 괄호로 판단되어 오답이 나올 수 있습니다. 더 나은 코드로 개선될 예정입니다.또는, 상향식으로 진행하여 여는 소괄호는 2를 곱해주고, 닫는 소괄호는 2로 나누어 주며 값을 계산할 수도 있습니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { string S; cin &amp;gt;&amp;gt; S; vector&amp;lt;int&amp;gt; st; for (int i = 0; i &amp;lt; S.size(); i++) { if (S[i] == &#39;(&#39;) st.push_back(-1); else if (S[i] == &#39;[&#39;) st.push_back(-2); else { int num = 0; for (int j = st.size() - 1; j &amp;gt;= 0; j--) { if (S[i] == &#39;)&#39;) { if (st[j] == -1) { if (num &amp;gt; 0) st[j] = 2 * num; else st[j] = 2; break; } else if (st[j] == -2) { cout &amp;lt;&amp;lt; 0; return 0; } else { num += st[j]; st.pop_back(); } } else if (S[i] == &#39;]&#39;) { if (st[j] == -2) { if (num &amp;gt; 0) st[j] = 3 * num; else st[j] = 3; break; } else if (st[j] == -1) { cout &amp;lt;&amp;lt; 0; return 0; } else { num += st[j]; st.pop_back(); } } } } } int result = 0; for (int i = 0; i &amp;lt; st.size(); i++) { if (st[i] &amp;lt; 0) { cout &amp;lt;&amp;lt; 0; return 0; } result += st[i]; } cout &amp;lt;&amp;lt; result; return 0;}" }, { "title": "[C++ STL 심화] 함수 객체, 함수자", "url": "/posts/CPP-STL-Functor/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2021-01-12 16:39:00 +0900", "snippet": "함수 객체 또는 함수자(functor)로 불리는 이것들은 C++의 operator() 연산자를 오버로딩한 클래스 객체입니다. 종류는 크게 2가지로 나눌 수 있으며, 각 세부 분류를 포함하면 다음과 같습니다. 일반 함수 객체   산술 연산 함수 객체 +, -, *, /, %, -(부호) 와 같은 산술 연산 비교 연산 조건자 ==, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;= 와 같은 비교 연산 논리 연산 조건자 &amp;amp;&amp;amp;, ||, ! 와 같은 논리 연산 함수 어댑터   바인더 이항 함수 객체를 단항 함수 객체로 변환 부정자 함수 객체 조건자를 반대로 변환 함수 포인터 어댑터 함수 포인터를 STL이 요구하는 함수 객체로 변환 멤버 함수 포인터 어댑터 멤버 함수 포인터를 STL이 요구하는 함수 객체로 변환  이 때, 조건자는 bool 타입을 반환하는 함수류(함수 객체, 함수, 함수 포인터) 입니다. 다음의 예제는 함수류 내 3가지의 구현 방법을 설명합니다. functor_ex.cpp#include &amp;lt;iostream&amp;gt;using namespace std;struct Object_Functor { const bool operator() (int a, int b) { return a &amp;lt; b; }};bool Function_Functor(int a, int b) { return a &amp;lt; b;}int main() { bool (*Pointer_Functor)(int, int) = Function_Functor; Object_Functor objFunctor; cout &amp;lt;&amp;lt; objFunctor(20, 60) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; Function_Functor(20, 60) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; Pointer_Functor(20, 60) &amp;lt;&amp;lt; endl; return 0;} 이 함수류에서 STL이 조건하는 조건자는 전부 함수 객체를 사용합니다. 또한, operator()를 오버로딩 할 때 const 키워드가 무조건 붙어있어야 합니다. 단순히 참/거짓을 판별하는 함수에서 실수로 값이 바뀌어버리면 문제가 발생할 수 있기 때문입니다. 더 정확하게는, 조건자가 변경되지 않을 것이라 예상하고 조건자를 내부적으로 복사하여 사용하는데, 이 때 값이 변경되어버리면 오류가 발생하기 때문입니다. 단항 함수 객체의 경우 argument_type(함수 인자 형식)와 result_type(함수 리턴 형식)가 정의되어 있어야 하고, 이항 함수 객체는 first_argument_type(첫번째 인자 형식), second_argument_type(두번째 인자 형식), result_type(리턴 형식)이  typedef를 이용하여 정의되어 있어야 합니다. 어댑터(Adaptor)는 함수 객체를 변환할 때 위의 형식을 이용해 변환합니다. 하지만 위의 형식을 정의해 줄 필요는 없는 것이, STL에서 unary_function과 binary_function 이라는 클래스를 제공하기 때문에 함수 객체를 만들 때에는 이 클래스에서 상속하여 제작하면 됩니다.  function_object_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;template&amp;lt;typename T&amp;gt;struct Add { typedef T first_argument_Type; typedef T second_argument_Type; typedef T result_type; T operator()(const T&amp;amp; a, const T&amp;amp; b) { return a + b; }};template&amp;lt;typename T&amp;gt;struct Add_Inherited : public binary_function&amp;lt;T, T, T&amp;gt; { T operator()(const T&amp;amp; a, const T&amp;amp; b) { return a + b; }};그럼 이제부터 STL에서 제공하는 함수자들을 자세하게 살펴보도록 합시다. 산술 연산 함수 객체   plus 이항 + 연산 minus 이항 - 연산 multiplies 이항 * 연산 divides 이항 / 연산 modulus 이항 % 연산 negate 단항 - 연산 (부호) 함수 객체라는 개념은 어렵고 복잡해보여도, 실제 사용할 때에는 매우 간단합니다. plus_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;int main() { plus&amp;lt;int&amp;gt; func; cout &amp;lt;&amp;lt; func(1, 2) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; func.operator()(10,20) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; plus&amp;lt;int&amp;gt;()(1, 2) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; plus&amp;lt;int&amp;gt;().operator()(10, 20) &amp;lt;&amp;lt; endl; return 0;}다른 연산자들도 전부 사용 방법이 똑같기 때문에 생략하도록 하겠습니다. 비교 연산 조건자   equal_to 이항 == 연산 not_equal_to 이항 !=  연산 less 이항 &amp;lt;   연산 less_equal 이항 &amp;lt;= 연산 greater 이항 &amp;gt;   연산 greater_equal 이항 &amp;gt;= 연산 조건자(Predicate)는 조건을 판단하는 거의 모든 알고리즘에 사용되며, 기본으로는 less가 사용됩니다. less_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;int main() { less&amp;lt;int&amp;gt; func; cout &amp;lt;&amp;lt; func(1, 2) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; func.operator()(10, 20) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(1, 2) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;().operator()(10, 20) &amp;lt;&amp;lt; endl; return 0;}보이는 바와 같이 비교 연산 조건자 또한 산술 연산 함수 객체와 동일하게 사용됩니다. 논리 연산 조건자   logical_and 이항 &amp;amp;&amp;amp; 연산 logical_or 이항 ||    연산 logical_not 이상 !    연산 논리 연산 조건자도 크게 다를 바 없이 위의 방법들처럼 사용하면 됩니다. 이제 함수 어댑터들에 대해 살펴보도록 합시다. 바인더(binder)는 이항 삼수자를 단항 함수자로 변환하며, bind1st와 bind2nd가 존재합니다. 각각 ‘첫번째 인자’/’두번째 인자’ 를 고정하여 단항 함수자로 변환합니다. binder_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;int main() { binder1st&amp;lt;less&amp;lt;int&amp;gt;&amp;gt; binder = bind1st(less&amp;lt;int&amp;gt;(), 10); cout &amp;lt;&amp;lt; binder(10) &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(10, 10) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; binder(5) &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(10, 5) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; binder(15) &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(10, 15) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; bind1st(less&amp;lt;int&amp;gt;(), 10)(10) &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(10, 10) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; bind1st(less&amp;lt;int&amp;gt;(), 10)(5) &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(10, 5) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; bind1st(less&amp;lt;int&amp;gt;(), 10)(15) &amp;lt;&amp;lt; &quot; = &quot; &amp;lt;&amp;lt; less&amp;lt;int&amp;gt;()(10, 15) &amp;lt;&amp;lt; endl;}예제는 less 조건자의 첫번째 인자를 10으로 고정한 binder를 사용하였습니다. 여기서 bind1st를 bind2nd로 바꾸면 두번째 인자를 10으로 고정하는 binder가 됩니다. 부정자(negator)는 조건을 반전(반대의 조건으로 변경)합니다. 단항 조건자의 not1, 이항 조건자의 not2가 존재합니다. not2(less())(5, 10) 과 같은 방법으로 사용됩니다. 간단하기 때문에 예제는 첨부하지 않겠습니다. 함수 포인터 어댑터는 일반 함수를 어댑터를 적용할 수 있는 함수 객체로 변환하는 ptr_fun() 입니다. 직접 작성한 함수를 ptr_fun() 에 매개변수로 넣으면 그 함수가 함수 객체처럼 동작할 수 있게 해줍니다. 간단한 함수 한두개로 굳이 함수 객체를 작성할 수고를 덜어 주는 함수죠. 멤버 함수 포인터 어댑터는 멤버 함수를 함수 객체로 변환하여 알고리즘이 호출할 수 있도록 해줍니다. 객체로 멤버 함수를 호출하는 mem_fun_ref() 와 객체의 주소로 멤버 함수를 호출하는 mem_fun() 가 존재합니다.  mem_fun_ref_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;class Monster { int hp; int mp;public: Monster(int _hp, int _mp) { this-&amp;gt;hp = _hp; this-&amp;gt;mp = _mp; } const void Info() { cout &amp;lt;&amp;lt; &quot;HP : &quot; &amp;lt;&amp;lt; hp &amp;lt;&amp;lt; &quot;, MP : &quot; &amp;lt;&amp;lt; mp &amp;lt;&amp;lt; endl; }};int main() { vector&amp;lt;Monster&amp;gt; pools; pools.push_back(Monster(10, 20)); pools.push_back(Monster(15, 30)); pools.push_back(Monster(45, 20)); for_each(pools.begin(), pools.end(), mem_fun_ref(&amp;amp;Monster::Info)); return 0;}  mem_fun_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;class Monster { int hp; int mp;public: Monster(int _hp, int _mp) { this-&amp;gt;hp = _hp; this-&amp;gt;mp = _mp; } const void Info() { cout &amp;lt;&amp;lt; &quot;HP : &quot; &amp;lt;&amp;lt; hp &amp;lt;&amp;lt; &quot;, MP : &quot; &amp;lt;&amp;lt; mp &amp;lt;&amp;lt; endl; }};int main() { vector&amp;lt;Monster*&amp;gt; pools; pools.push_back(new Monster(10, 20)); pools.push_back(new Monster(15, 30)); pools.push_back(new Monster(45, 20)); for_each(pools.begin(), pools.end(), mem_fun(&amp;amp;Monster::Info)); return 0;} 이것으로 C++ STL의 함수 객체에 대한 강좌는 끝나게 되었습니다. 그래서 함수자(Functor)는 왜 사용하나요? 알고리즘의 매개변수로 전달하여 같은 알고리즘 함수도 다르게 동작하게 하기 위해 주로 사용됩니다. 그냥 덧셈 뺄셈 하겠다고 함수자를 사용하는것은 절대 아니라는 거죠." }, { "title": "[C++ STL 심화] 반복자(iterator)", "url": "/posts/CPP-STL-Iterator/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2021-01-11 23:20:00 +0900", "snippet": "반복자는 포인터를 추상화 한 클래스입니다. 추상화, 클래스에 대해서는 객체지향에 관해 공부하면서 배울 수 있습니다. 그런건 지금은 제쳐 두고, 반복자가 무엇이고, 어떻게 사용하는지에 대해 알아봅시다. 반복자의 종류와 연산자 입력 반복자-input iterator *(읽기), -&amp;gt;, ++, ==, !=, 복사 생성자 출력 반복자-output iterator *(쓰기), ++, 복사 생성자 순방향 반복자-foward iterator *(읽기,쓰기), ++, 복사 생성자 양방향 반복자-bidirectional iterator *(읽기,쓰기), ++, –, 복사 생성자 임의 접근 반복자-random access iterator [], +=, -=, +, -, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;= 여기서 *는 포인터에서 주소의 값을 참조하는 것과 같은 쓰임새로, iter라는 반복자 객체에 *iter를 사용하여 값을 읽어오거나, 대입해서 쓸 수 있습니다. 읽기가 가능하다는 것은 *iter로 값을 가져올 수 있다는 것이고, 쓰기가 가능하다는 것은 *iter = x 으로 값을 대입할 수 있다는 뜻입니다.  반복자에는 순차열(sequence) 과 구간(range)이라는 중요한 개념도 존재합니다. 순차열은 반복자의 시작과 끝으로 이루어진 구간인데, [b, e) 라는 표현은, 시작하는 위치를 가리키는 b라는 반복자와 끝나는 위치를 가리키는 e라는 반복자의 구간으로 이루어진 순차열이라는 뜻입니다. 대괄호는 해당 위치도 포함한다는 뜻이고, 소괄호는 포함하지 않는다는 뜻이기 때문에 시작 위치는 포함되지만 끝나는 위치는 포함되지 않는다고 볼 수 있습니다. 모든 컨테이너 C는 정방향 반복자인 C::iterator와 C::const_iterator와 역방향 반복자인 C::reverse_iterator와 C::const\\_reverse\\_iterator가 존재합니다. const_ 가 붙은 반복자들은 상수형으로써 읽기만 가능하다는 뜻이고, 일반 iterator은 읽기와 쓰기가 모두 가능합니다. 이 때, 노드 기반 컨테이너는 양방향 반복자를 사용하고 시퀀스 기반 컨테이너는 임의 접근 반복자를 사용합니다. 컨테이너의 begin()은 컨테이너 순차열의 첫 원소의 반복자를 반환하고 end() 함수는 순차열의 끝 표시 반복자를 반환합니다. const 타입으로 iterator를 선언하는것과 const_iterator 타입을 쓰는것은 서로 다른데, const 타입으로 선언하면 반복자의 값 자체가 바뀔 수 없고 const_iterator는 반복자가 가리키는 값을 바꿀 수 없습니다. C::reverse_iterator와 C::const_reverse_iterator는 말그대로 끝에서부터 처음으로 읽는 반복자입니다. rbegin()과 rend()로 컨테이너 순차열의 끝, 처음 부분을 가리키는 반복자를 반환받을 수 있습니다. 주의할 점은, 역방향 반복자는 반복자와 반복자가 가리키는 원소가 다릅니다. 반복자의 위치에서 한칸 더 간 위치의 값을 가리키는데, 예를 들어 10 20 30 40 50 순차열에서 반복자의 위치가 30이라면, *iter을 할 시 20의 값이 나오게 됩니다. 반복자 중에는 삽입 반복자도 존재합니다. 원소를 대입(덮어쓰기)이 아니라, 삽입(기존 자리의 원소는 뒤로 밀려남)하고 싶을때 사용합니다. inserter() insert_iterator 객체를 생성하고, 이 객체는 insert() 멤버 함수를 호출합니다 back_inserter() back_insert_iterator 객체를 생성하고, 이 객체는 push_back() 멤버 함수를 호출합니다 front_inserter() front_insert_iterator 객체를 생성하고, 이 객체는 push_front() 멤버 함수를 호출합니다  이 때, inserter()는 모든 컨테이너가 사용할 수 있지만 back_inserter()는 시퀀스 컨테이너만, front_inserter()는 시퀀스 컨테이너중 deque와 list만 사용할 수 있습니다. insert_iterator_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iterator&amp;gt;using namespace std;int main() { list&amp;lt;int&amp;gt; lt1 = { 1,2,3,4,5 }; list&amp;lt;int&amp;gt; lt2 = { 10,20,30,40,50 }; copy(lt2.begin(), lt2.end(), front_inserter&amp;lt;list&amp;lt;int&amp;gt;&amp;gt;(lt1)); for (int i : lt1) cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39;; return 0;} 50 40 30 20 10 1 2 3 4 5 마지막으로, I/O 스트림 반복자가 있습니다. 알고리즘이 파일에서 읽고 쓰게 하고 싶을 때 주로 사용합니다.istream_iterator&amp;lt;T&amp;gt; 는 T 자료형의 값을 스트림에서 읽고, ostream_iterator&amp;lt;T&amp;gt; 는 T 자료형의 값을 스트림에 쓸 수 있습니다. iostream_iterator_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iterator&amp;gt;using namespace std;int main() { vector&amp;lt;int&amp;gt; v = { 1,2,3,4,5 }; copy(v.begin(), v.end(), ostream_iterator&amp;lt;int&amp;gt;(cout, &quot; &quot;)); return 0;} 1 2 3 4 5 내용을 더 추가하자면, +=과 -=같은, 임의 접근 반복자만이 가능한 연산을 다른 반복자에서도 사용할 수 있도록 해주는 함수가 존재합니다. advance(p, n)을 이용하면 p 반복자를 p + n의 위치로 이동시킵니다. distance(p1, p2) 함수는 두 반복자의 거리, p2-p1를 반환합니다. 이로써 반복자의 강의가 끝났습니다. 미흡하거나 쓰지 않은 부분이 있지만, 더 많고 완벽한 정보를 원하신다면 C++ STL 문서를 참고해주세요. (영문) https://www.cplusplus.com/reference/stl/" }, { "title": "[C++ STL] 연관 컨테이너 set &amp; map", "url": "/posts/cpp-stl-set-map/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2021-01-08 20:58:00 +0900", "snippet": " 모든 연관 컨테이너는 노드 기반 컨테이너이고, 균형 이진 트리로 구현되었고 균형 이진 트리의 모든 특징을 가집니다.연관 컨테이너는 총 4가지가 있지만, 전부 서로 비슷하고 크게 다르지 않아 하나를 잘 이해한다면 나머지도 쉽게 이해할 수 있습니다. 실제로, 모든 연관 컨테이너들은 같은 인터페이스(생성자, 멤버 함수, 연산자)를 사용합니다. 연관 컨테이너는 정렬 기준인 조건자에 따라 원소를 자동으로 정렬하는 컨테이너입니다. 이 정렬 기준은 컨테이너를 처음 생성할 때 템플릿 매개변수로 지정할 수 있습니다. 이 템플릿 형식은 아래에 각 컨테이너별로 정리되어질 것입니다. 이렇게 자기 멋대로 정렬을 하기 때문에 시퀀스 컨테이너처럼 맨 뒤에 넣거나, 특정 위치에 원소를 넣거나 하는 작업은 할 수 없습니다. 그렇다면 왜 연관 컨테이너를 사용할까요? 연관 컨테이너는 균형 이진 트리의 구조이기 때문에 탐색과 삽입에서 로그의 시간 복잡도를 가지고 있어 매우 빠르게 처리할 수 있습니다. 연관 컨테이너를 완벽하게 다루고 싶다면, 균형 이진 트리를 이해하고 있어야 합니다. 연관 컨테이너의 생성자 set s; s는 빈 컨테이너 set s(pred); s는 빈 컨테이너고 정렬 기준은 pred 조건자 set s(s2) s는 s2 컨테이너의 복사본 set s(b, e) s는 반복자 구간 [b, e)로 초기화된 원소 set s(b, e, pred) s는 반복자 구간 [b, e)로 초기화된 원소이고 정렬 기준은 pred 조건자 예시로는 set을 사용하였고, 연관 컨테이너 공통입니다. 연관 컨테이너의 멤버 함수 s.begin(), s.end() s의 첫/끝 원소를 가리키는 반복자 s.clear(), s.empty() s의 모든 원소를 제거한다, s가 비었는지 여부 s.size(), s.max_size() s의 원소의 개수, s가 담을 수 있는 최대 원소의 개수(메모리 크기) s.count(k) k와 일치하는 값의 개수 s.erase(p) 반복자 p가 가리키는 원소를 제거하고 다음 원소의 반복자를 반환한다 s.erase(b,e) 반복자 구간 [b, e)의 모든 원소를 제거하고 다음 원소의 반복자를 반환한다 s.erase(k) k와 일치하는 값을 모두 제거하고 제거한 개수를 반환한다 s.insert(k) k를 삽입하고, 그 원소 위치의 반복자와 성공여부의 bool값의 pair를 반환한다 s.insert(p, k) p가 가르키는 위치에 k를 삽입하고, 그 원소 위치의 반복자를 반환한다 s.insert(b, e) 반복자 구간 [b, e)의 원소를 삽입한다 s.swap(s2) s와 s2를 서로 교환한다 s.lower_bound(k) k 값의 시작 구간을 가리키는 반복자 s.upper_bound(k) k 값의 끝 구간을 가리키는 반복자 여기서 insert 함수에서 위치 지정은 “삽입 탐색을 시작할 위치”입니다. 무슨 말이냐면, 원소가 정렬된 위치를 찾기 위한 연산이 시작되는 부분입니다. 만약 삽입 후에도 정렬 순서가 맞다면 삽입이 바로 끝나지만 아니라면 로그의 시간이 걸립니다.다른 함수들은 간단하기 때문에 직접 사용해보면서 알 수 있지만 lower_bound()와 upper_bound()는 이해하기 까다로울 수 있기 때문에 설명하도록 하겠습니다. 두 함수는 찾은 원소(key)를 반복자(순차열 구간)로 반환합니다. lower_bound()는 찾은 원소의 시작 반복자를, upper_bound()는 찾은 원소의 다음 원소를 가리키는 반복자입니다. 그래서 lower_bound()와 upper_bound()가 같다면 찾는 원소는 없습니다. bound_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;set&amp;gt;using namespace std;int main() { set&amp;lt;int&amp;gt; s; for (int i = 10; i &amp;lt;= 90; i += 10) s.insert(i); set&amp;lt;int&amp;gt;::iterator lower; set&amp;lt;int&amp;gt;::iterator upper; lower = s.lower_bound(50); upper = s.upper_bound(50); cout &amp;lt;&amp;lt; *lower &amp;lt;&amp;lt; &quot; &amp;amp; &quot; &amp;lt;&amp;lt; *upper; lower = s.lower_bound(150); upper = s.upper_bound(150); if (lower == upper) cout &amp;lt;&amp;lt; &quot;150은 set에 포함되어있지 않습니다&quot; &amp;lt;&amp;lt; endl; return 0;}출력 결과50 &amp;amp; 60 150은 set에 포함되어있지 않습니다 set의 템플릿 형식template&amp;lt; typename Key, typename Pred=less&amp;lt;Key&amp;gt;, typename Allocator=allocator&amp;lt;Key&amp;gt;&amp;gt; class set set 컨테이너는 key라고 불리는 값의 집합으로 이루어진 컨테이너입니다. 멤버 함수인 insert()만으로 값을 삽입할 수 있으며, 삽입된 값은 정렬 기준에 따라 자동 정렬됩니다. 삽입된 원소들을 key라고 부르고, 이 key를 이용해서 정렬합니다. 또한, set의 특징은 모든 key가 유일하다는 점입니다. 다시 말해서 똑같은 값을 2번 이상 중복해서 컨테이너에 삽입할 수 없다는 뜻입니다.  multiset 컨테이너는 원소(key)를 중복해서 삽입할 수 있다는 것 외에는 set과 다른 점이 없고, 에 포함되어있습니다. map의 템플릿 형식template&amp;lt; typename Key, typename Value, typename Pred=less&amp;lt;Key&amp;gt;, typename Allocator=allocator&amp;lt;pair&amp;lt;const Key, Value&amp;gt;&amp;gt; &amp;gt; class map map 컨테이너는 가장 자주 사용하는 컨테이너로 원소가 key와 value라는 값의 쌍으로 이루어져 있습니다. map 또한 set처럼 중복되는 key를 가질 수 없습니다. 그리고 여기서 map과 set의 중요한 차이점이 나옵니다. map 컨테이너는 원하는 key에 해당하는 원소의 value값에 접근할 수 있는 [] 연산자를 지원합니다. m[k] = v 같은 방식으로 사용하며, m 컨테이너의 k에 해당하는 key값의 value를 v로 수정하거나, 없을 경우 새로 추가합니다. map은 중요하고, 다른 대부분의 객체지향언어들이 지원하는 자료구조이기 때문에 예제를 보며 학습해봅시다. multimap 컨테이너는 원소(key)를 중복해서 삽입할 수 있다는 것 외에는 map과 다른 점이 없고, &amp;lt;map&amp;gt;에 포함되어있습니다. map_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main() { map&amp;lt;string, int&amp;gt; m; m.insert(pair&amp;lt;string, int&amp;gt;(&quot;C언어&quot;, 1500)); m.insert(pair&amp;lt;string, int&amp;gt;(&quot;Java&quot;, 2000)); m.insert(pair&amp;lt;string, int&amp;gt;(&quot;파이썬&quot;, 1800)); m[&quot;C#&quot;] = 2500; m[&quot;PHP&quot;] = 1500; map&amp;lt;string, int&amp;gt;::iterator it; for (it = m.begin(); it != m.end(); it++) { cout &amp;lt;&amp;lt; &quot;도서명 : &quot; &amp;lt;&amp;lt; (*it).first &amp;lt;&amp;lt; &quot;, 가격 : &quot; &amp;lt;&amp;lt; (*it).second &amp;lt;&amp;lt; endl; } return 0;}" }, { "title": "[C++ STL] 리스트(List)", "url": "/posts/CPP-STL-List/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2021-01-01 14:12:00 +0900", "snippet": "리스트(List)는 시퀀스 컨테이너 중, “이중 연결 리스트” 라는 자료구조를 사용하는 노드 기반 컨테이너로 벡터(Vector)나 덱(Deque)와는 다른 성질을 가집니다. 리스트를 완전히 이해하기 위해서는, 이중 연결 리스트와 반복자를 먼저 공부해야 합니다. list_ex01.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;using namespace std;int main() { list&amp;lt;int&amp;gt; lt(5); list&amp;lt;int&amp;gt;::iterator iter; for (iter = lt.begin(); iter != lt.end(); ++iter) { cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; endl; iter = lt.begin(); iter++; iter = lt.insert(iter, 5); cout &amp;lt;&amp;lt; &quot;Inserted Object : &quot; &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; endl; for (iter = lt.begin(); iter != lt.end(); ++iter) { cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; &#39; &#39;; } return 0;}예제를 보면, [] 연산자나 at() 함수가 없는 것을 볼 수 있습니다. 왜냐하면, 리스트 컨테이너는 연결 리스트 자료구조이기 때문에 인덱스(숫자)로 접근하는 것이 불가능하기 때문입니다. 대신 리스트는 반복자(iterator)를 이용하여 원소를 접근, 할당합니다. 생성자 list lt lt는 비어있는 리스트   list lt(n) lt는 기본값으로 초기화된 n 크기의 리스트   list lt(n, x) lt는 x로 초기화된 n 크기의 리스트   list lt(lt2) lt는 lt2 리스트를 복사한 리스트   list lt(b, e) lt는 반복자 구간 [b, e)로 초기화된 리스트   사용법은 다른 시퀀스 컨테이너와 동일합니다. 멤버 함수 lt.assign(n, x) lt에 x값으로 n개의 원소를 할당한다   lt.begin(), lt.end() lt의 반복자 처음, 끝을 나타낸다   lt.size() lt의 원소의 개수를 나타낸다   lt.resize(n) lt의 크기를 n으로 바꾸고 추가된 공간을 기본값으로 초기화한다   lt.empty() lt가 비었는지 나타낸다   lt.clear() lt의 모든 원소를 제거한다   lt.front(), lt.back() lt의 첫 번째 원소, 마지막 원소를 참조한다   q = lt.insert(p,x) p의 위치에 x값을 삽입하고, 그 원소를 가르키는 반복자를 반환한다   q = lt.erase(p) p의 위치의 값을 제거하고, 그 다음 원소를 가르키는 반복자를 반환한다   lt.insert(p, n, x) p의 위치에 n개의 x값를 삽입한다   lt.pop_back(), lt.pop_front() lt의 첫번째/마지막 원소를 제거한다   lt.push_back(x), lt.push_front(x) lt의 첫번째/마지막에 원소 x를 추가한다   lt.remove(x) x값에 해당하는 원소를 모두 제거한다   lt.merge(lt2) lt2를 lt로 합병하고 정렬한다   lt.sort() lt를 오름차순으로 정렬한다   lt.reverse() lt의 순서를 뒤집는다   lt.unique() lt의 인접한 원소의 값이 같은 노드들을 하나의 노드로 만든다   lt.swap(lt2) lt와 lt2를 교환한다    리스트 컨테이너는 기본적으로 시퀀스 컨테이너의 모든 특징을 가집니다. 즉, 벡터나 덱에서 사용하던 기능을 이곳에서도 거의 전부 사용할 수 있습니다. 하지만, 위의 표에서 보다시피 리스트는 지원하는 기능이 훨씬 많습니다. 그 중에서도 리스트만의 특징을 알아보도록 합니다. 리스트 컨테이너는 이중 연결 리스트이기 때문에, insert()와 erase() 함수가 O(1)의 성능을 보여줍니다. 배열 기반의 컨테이너의 경우는 원소를 삽입하면 뒤의 원소를 전부 밀어내야하는데, 리스트의 경우 자신의 앞뒤의 포인터만 수정해주면 되기 때문입니다. 또한, insert()와 erase()함수를 사용한 후에도 반복자를 계속하여 사용할 수 있습니다. 벡터나 덱의 경우는 원소를 삽입하면 메모리가 재할당될 수 있기 때문에 반복자를 무효화시키기 때문입니다.remove(x)라는 함수는, 컨테이너를 탐색하며 x값에 해당하는 원소들을 모두 제거하는데, 이 함수는 리스트만이 가지고 있으며 컨테이너의 길이만큼만 반복하기 때문에 속도도 매우 빠릅니다. remove_if(pred)라는 단항 조건자(predicate)를 매개변수로 하여 조건에 맞는 원소를 모두 지우는 작업도 가능합니다. 사용법은 다음과 같습니다. list_removeif_ex.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;using namespace std;bool Compare(int x) { return x % 2 == 0 &amp;amp;&amp;amp; x &amp;gt; 0;}int main() { list&amp;lt;int&amp;gt; lt(10); list&amp;lt;int&amp;gt;::iterator iter; int tmp = -4; for (iter = lt.begin(); iter != lt.end(); ++iter, ++tmp) *iter = tmp; for (iter = lt.begin(); iter != lt.end(); ++iter) cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; &#39; &#39;; cout &amp;lt;&amp;lt; endl; lt.remove_if(Compare); for (iter = lt.begin(); iter != lt.end(); ++iter) cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; &#39; &#39;; return 0;}Compare 함수에 리스트 컨테이너의 모든 원소가 하나씩 전달되어서 조건에 맞으면 해당 노드를 삭제하는 방식으로 동작합니다. 현 예제에서는 10개의 원소를 -4~5으로 초기화한 후, “양수 중에서 짝수인 수”만 remove_if() 함수로 제거하였습니다. remove_if()에 전달하는 자료형은 조건자로써 함수, 함수 객체, 함수 포인터를 전달하게 됩니다. 이 조건자에 대해서는 다른 게시글에서 다루도록 하겠습니다.리스트 컨테이너에는 sort() 라는 멤버함수가 존재합니다. STL의 라이브러리에는 거의 대부분의 컨테이너들에 통용되는 알고리즘(정렬, 탐색 등)이 들어있는데, 리스트는 자료구조의 특성으로 이 라이브러리의 sort()를 사용할 수 없기 때문에 자체적으로 제작된 sort() 함수가 존재합니다. 이 멤버함수는 기본적으로 오름차순으로 정렬하지만, 조건자를 매개변수로 전달해주면 원하는 조건을 이용할 수 있습니다. greater()와 less()는 STL에 내장된 조건 함수로 각각 오름차순/내림차순 을 지원합니다. 위의 remove\\_if() 예제와 동일한 방법이기 때문에 따로 예제는 첨부하지 않겠습니다.merge() 함수는 두개의 리스트를 합치고 정렬하는 함수입니다. lt.merge(lt2) 을 실행하면 lt2 리스트의 원소는 사라지고 lt에 합병 후 오름차순으로 정렬됩니다. 만약 다른 정렬방식을 사용하고 싶다면, 두번째 매개변수로 조건자를 넘겨줄 수 있습니다. lt.merge(lt2, pred)와 같이 이용하면 됩니다. 이 때 주의할 점은 두 리스트가 같은 정렬방식으로 정렬되어있어야 한다는 것입니다.리스트의 큰 특징중 하나로 splice()라는 함수가 존재합니다. 이 함수는 다른 리스트 컨테이너의 한 부분을 잘라붙일 수 있습니다. list_splice_ex01.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;using namespace std;int main() { list&amp;lt;int&amp;gt; lt1; list&amp;lt;int&amp;gt; lt2; list&amp;lt;int&amp;gt;::iterator iter; int num = 10; for (int i = 0; i &amp;lt; 5; i++, num += 10) { lt1.push_back(num); lt2.push_back(num / 10); } lt1.splice(lt1.begin(), lt2); for (iter = lt1.begin(); iter != lt1.end(); ++iter) cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; &#39; &#39;; return 0;} lt1.splice(iter, lt2)와 같은 방식으로 사용하며, lt1의 iter가 가르키는 위치에 lt2의 모든 원소를 넣습니다. 다른 방법으로는, lt1.splice(iter1, lt2, iter2) 가 있는데 lt1에 lt2를 붙여넣는다는 것은 동일하지만 lt2의 iter2가 가르키는 위치의 원소만을 넣습니다.마지막으로, 두 반복자로 부분구간을 넣는 방식이 있습니다. list_splice_ex02.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;using namespace std;int main() { list&amp;lt;int&amp;gt; lt1; list&amp;lt;int&amp;gt; lt2; list&amp;lt;int&amp;gt;::iterator iter1; int num = 10; for (int i = 0; i &amp;lt; 5; i++, num += 10) { lt1.push_back(num); lt2.push_back(num / 10); } list&amp;lt;int&amp;gt;::iterator lt2_it1, lt2_it2; lt2_it1 = lt2.begin(); lt2_it1++; lt2_it2 = lt2.end(); lt2_it2--; lt1.splice(lt1.begin(), lt2, lt2_it1, lt2_it2); for (iter1 = lt1.begin(); iter1 != lt1.end(); ++iter1) cout &amp;lt;&amp;lt; *iter1 &amp;lt;&amp;lt; &#39; &#39;; return 0;} lt1.splice(iter, lt2, b, e)와 같은 방식으로 사용하며, [b, e) 만큼의 반복자 영역을 잘라 붙입니다. 마지막으로, splice()는 단지 두 리스트를 연결하는 것이기 때문에 O(1)의 시간이 걸립니다! 그래서, 리스트 컨테이너는 언제 사용하는게 좋을까요? 리스트는 중간에 삽입, 제거가 빈번하게 발생하거나 상대적인 순서가 중요하다면 주로 사용하게 됩니다. 또한, 리스트는 다른 리스트와 결합하고 싶을 때 큰 장점을 발휘하는 컨테이너입니다. 그렇기 때문에 주로 벡터나 덱을 자주 사용하지만, 특수한 경우에 큰 힘을 발휘하는 컨테이너라고 생각하면 됩니다." }, { "title": "[C++ STL] 덱(Deque)", "url": "/posts/CPP-STL-Deque/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2020-12-23 22:37:00 +0900", "snippet": "[!] 덱은 벡터와 거의 유사하기 때문에, 글을 읽기 전에 이곳을 눌러 벡터의 게시글을 먼저 읽고 오시는 것을 추천합니다. 덱(Deque)은 벡터와 같은 시퀀스 컨테이너이고, 배열 기반 컨테이너입니다. 또, 대부분의 기능이 벡터와 동일하지만, 벡터의 단점들을 보완한 컨테이너입니다. 벡터(Vector) 글의 마지막을 보면, 벡터는 벡터의 크기보다 많은 원소를 할당하려고 하면, 메모리를 다시 할당하고, 할당된 메모리에 원소들을 복사하고, 원래의 메모리는 해제한다고 하였습니다. 덱은 이 문제를 보완하여, 여러 개의 메모리 블록을 할당하고, 원소를 추가할 때 메모리가 부족해질 때마다 일정한 크기의 새 메모리 블록을 할당하여 원소의 복사나 메모리의 재할당이 전혀 일어나지 않습니다. deque_Ex01.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;deque&amp;gt;using namespace std;int main() { deque&amp;lt;int&amp;gt; d(5, 1); cout &amp;lt;&amp;lt; &quot;Init : &quot;; for (size_t i = 0; i &amp;lt; d.size(); i++) { cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; endl; d.pop_back(); d.push_back(5); d.pop_front(); d.push_front(3); cout &amp;lt;&amp;lt; &quot;Modi : &quot;; for (size_t i = 0; i &amp;lt; d.size(); i++) { cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &#39; &#39;; } return 0;} 생성자 deque dq dq는 비어있는 덱   deque dq(n) dq는 기본값으로 초기화된 n 크기의 덱   deque dq(n, x) dq는 x로 초기화된 n 크기의 덱   deque dq(dq2) dq는 dq2 덱을 복사한 덱   deque dq(b, e) dq는 반복자 구간 [b, e)로 초기화된 덱   사용법은 모두 벡터와 같습니다. 멤버 함수 dq.assign(n, x) dq에 x값으로 n개의 원소를 할당한다   dq.begin(), dq.end() dq의 반복자 처음, 끝을 나타낸다   dq.size() dq의 크기를 나타낸다   dq.empty() dq가 비었는지 나타낸다   dq.clear() dq의 모든 원소를 제거한다   dq.front(), dq.back() dq의 첫번째/마지막 원소를 참조한다   dq.insert(p, n, x) p가 가리키는 위치에 n개의 x값을 삽입한다   dq.resize(n) dq의 크기를 n으로 변경한다   dq.resize(n, x) x를 넣을시 변경 후 확장된 값을 x로 초기화한다   dq.pop_front(), dq.pop_back() dq의 첫번째/마지막 원소를 제거한다   dq.push_front(x), dq.push_back(x) dq의 첫번째/마지막에 원소 x를 추가한다   dq.swap(dq2) dq와 dq2를 교환한다   벡터와 다르게 pop_front와 push_front가 있는 것을 확인할 수 있습니다.이 외의 사용법은 모두 벡터와 동일하기 때문에 따로 예제를 추가하지는 않겠습니다." }, { "title": "[C++ STL] 벡터(Vector)", "url": "/posts/CPP-STL-Vector/", "categories": "Lecture, Basic", "tags": "CPP", "date": "2020-11-28 01:02:00 +0900", "snippet": "벡터(Vector)는 STL에서 컨테이너에 속합니다. 컨테이너는 같은 타입을 저장, 관리하기 위해 만들어진 클래스입니다. 그 중 벡터는 표준 시퀀스 컨테이너(Standard Sequence Container) 에 속하는데, 자신만의 삽입 순서를 가지는 컨테이너라는 뜻입니다. 무슨 말이냐면, 배열처럼 삽입되는 순서에 따라 원소의 위치가 결정되고 바뀌지 않습니다.또한, 벡터는 배열 기반 컨테이너입니다. 배열처럼 메모리(RAM) 공간에 모든 원소가 이어져 있다는 뜻이죠. 이와 다르게는 노드 기반 컨테이너가 있는데, 컨테이너 내부의 원소들이 메모리의 무작위 위치에 저장되어 있습니다. 대신, 원소가 자신의 값과 다음 원소의 주소를 가지고 있습니다. vector_Ex01.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;int&amp;gt; V(N); for (int i = 0; i &amp;lt; V.size(); i++) { V[i] = i + 1; } for (int i = 0; i &amp;lt; V.size(); i++) { cout &amp;lt;&amp;lt; V[i] &amp;lt;&amp;lt; &#39; &#39;; } return 0;}위의 코드는 1부터 N까지의 숫자를 벡터에 저장하고 출력하는 예제입니다. 벡터는 vector&amp;lt;자료형&amp;gt; 이름; 과 같은 방법으로 선언합니다. 선언이 끝나면, 우리가 평소에 사용하던 배열과 똑같이 사용할 수 있습니다. 대신, 몇몇 함수들이 추가되어 훨씬 사용하기 편하고, 기능이 많습니다.vector&amp;lt;자료형&amp;gt; 이름(크기); 로 크기를 지정해 주면, 배열과 같이 미리 크기를 선언해줄 수 있습니다. 이 방법을 이용하면, 선언을 제외하고는 C언어의 배열과 완전히 똑같이 사용할 수 있습니다. 차이점은, 크기에 변수를 넣어 동적 배열로 사용할 수 있다는 점입니다. 또한 V.size() 를 사용하면 매우 편리하게 벡터의 크기를 알 수 있습니다. 생성자 vector v v는 비어있는 벡터   vector v(n) v는 기본값으로 초기화된 n 크기의 벡터   vector v(n, x) v는 x로 초기화된 n 크기의 벡터   vector v(v2) v는 v2 벡터를 복사한 벡터   vector v(b, e) v는 반복자 구간 [b, e)로 초기화된 벡터   생성자는 변수를 선언할 때 자동으로 이루어지는 작업입니다. 다음의 예제를 따라해서 결과를 확인해봅시다. vector_Ex02.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { int N; cin &amp;gt;&amp;gt; N; vector&amp;lt;int&amp;gt; V(N, 3); vector&amp;lt;int&amp;gt; V2(V); for (int i = 0; i &amp;lt; V.size(); i++) { cout &amp;lt;&amp;lt; V2[i] &amp;lt;&amp;lt; &#39; &#39;; } return 0;} 멤버 함수 v.assign(n, x) v에 x값으로 n개의 원소를 할당한다   v.begin(), v.end() v의 반복자 처음, 끝을 나타낸다   v.size() v의 크기를 나타낸다   v.empty() v가 비었는지 나타낸다   v.clear() v의 모든 원소를 제거한다   v.front(), v.back() v의 첫번째/마지막 원소를 참조한다   v.insert(p, n, x) p가 가리키는 위치에 n개의 x값을 삽입한다   v.resize(n) v의 크기를 n으로 변경한다   v.resize(n, x) x를 넣을시 변경 후 확장된 값을 x로 초기화한다   v.capacity() v가 할당된 공간의 크기를 나타낸다   v.reserve(n) v에 n개의 원소를 저장할 공간을 예약한다   v.pop_back() v의 마지막 원소를 제거한다   v.push_back(x) v의 마지막에 원소 x를 추가한다   v.swap(v2) v와 v2를 교환한다   멤버 함수는 만들어진 벡터에 멤버 연산자인 .* 을 이용해서 호출할 수 있습니다. 클래스의 개념을 알고 있다면 무엇인지 바로 알 수 있을겁니다. 함수를 직접 사용해보며, 결과를 확인합시다. vector_Ex03.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { vector&amp;lt;int&amp;gt; V(3); V.resize(6); for (int i = 0; i &amp;lt; V.size(); i++) cout &amp;lt;&amp;lt; V[i]; cout &amp;lt;&amp;lt; endl; V.pop_back(); V.pop_back(); V.push_back(3); V.push_back(6); for (int i = 0; i &amp;lt; V.size(); i++) cout &amp;lt;&amp;lt; V[i]; cout &amp;lt;&amp;lt; endl; return 0;}벡터끼리 ==, !=, &amp;lt;, &amp;gt;와 같은 비교 연산자를 사용할 수 있습니다. ==같은 경우는 모든 원소가 같은지 확인하고, &amp;lt;, &amp;gt;와 같은 대소 비교는 문자열 비교와 같이 사전 순서대로 비교합니다. vector_Ex04.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { vector&amp;lt;int&amp;gt; V1(5); vector&amp;lt;int&amp;gt; V2(5); for (int i = 0; i &amp;lt; 5; i++) { V1[i] = i; V2[i] = i + 1; } cout &amp;lt;&amp;lt; &quot;V1 : &quot;; for (int i = 0; i &amp;lt; V1.size(); i++) cout &amp;lt;&amp;lt; V1[i] &amp;lt;&amp;lt; &#39; &#39;; cout &amp;lt;&amp;lt; &quot;\\nV2 : &quot;; for (int i = 0; i &amp;lt; V2.size(); i++) cout &amp;lt;&amp;lt; V2[i] &amp;lt;&amp;lt; &#39; &#39;; cout &amp;lt;&amp;lt; &quot;\\nV1 == V2 : &quot; &amp;lt;&amp;lt; (V1 == V2) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;V1 &amp;gt; V2 : &quot; &amp;lt;&amp;lt; (V1 &amp;gt; V2) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;V1 &amp;lt;= V2 : &quot; &amp;lt;&amp;lt; (V1 &amp;lt;= V2) &amp;lt;&amp;lt; endl; return 0;} N차원 벡터2차원 배열이 정확히 무엇인지 기억하시나요? 배열 안의 각 원소에 배열이 있다면 이것은 2차원 배열입니다. 벡터도 똑같습니다. 벡터 안에 벡터가 들어있는 방식으로 2차원 벡터를 만들 수 있습니다. vector_Ex05.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; V(5, vector&amp;lt;int&amp;gt;(10, 2)); for (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;::size_type i = 0; i &amp;lt; V.size(); i++) { for (vector&amp;lt;int&amp;gt;::size_type j = 0; j &amp;lt; V[i].size(); j++) { cout &amp;lt;&amp;lt; V[i][j] &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; endl; } return 0;}벡터를 초기화 할때, 벡터&amp;lt;벡터&amp;gt; 타입인 바깥쪽 벡터를 5개 생성하고, 안쪽 값은 벡터 타입인 안쪽 벡터를 10개 생성해줬습니다. 벡터 안에 벡터가 있는 것이니, 값 초기화를 벡터로 한다는 것이 이해가 되시나요? 그리고 이제, 안쪽 벡터의 원소는 전부 2로 초기화해주었습니다.그런데 출력문을 보니 size_type 이라는 이상한 타입이 있네요. 하지만 그냥 int로 해주어도 잘 작동합니다. 그렇다면 왜 size_type가 있는 걸까요? 이것은 C++의 가장 큰 특징중 하나인 라이브러리의 강력한 재사용성입니다. 모든 컨테이너에는 size_type가 있기 때문에 이것을 이용하면 함수 하나에서 모든 타입의 컨테이너들의 처리가 가능하게 해 줍니다. 정확한 사용 방법은 후에 template 라는 C++의 기능을 학습하며 공부하게 될 것입니다.아래 코드는 위 코드와 동일한 기능을 합니다. 대신 C++의 auto 이용해서 코드를 훨씬 간단하게 작성할 수 있죠. 여기서 auto 는 자료형을 확실히 유추할 수 있을때만 사용할 수 있으며 컴파일 시간에 해당하는 타입으로 치환됩니다. vector_Ex05_1.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; V(5, vector&amp;lt;int&amp;gt;(10, 2)); for (auto i = 0; i &amp;lt; V.size(); i++) { for (auto j = 0; j &amp;lt; V[i].size(); j++) { cout &amp;lt;&amp;lt; V[i][j] &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; endl; } return 0;}자, 이제 벡터가 끝난 것 같지만 아직 하나 남았습니다. 벡터는 가변 배열이라는 것을 알고 계시죠? 그렇기 때문에 N차원 벡터의 원소들은 전부 각기 다른 길이의 벡터들을 담을 수 있습니다. 한번 예제를 보고 학습해봅시다. vector_Ex06.cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int main() { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; V; vector&amp;lt;int&amp;gt; v1(5, 1); vector&amp;lt;int&amp;gt; v2(3, 2); vector&amp;lt;int&amp;gt; v3(7, 3); vector&amp;lt;int&amp;gt; v4(1, 4); vector&amp;lt;int&amp;gt; v5(9, 5); V.push_back(v1); V.push_back(v2); V.push_back(v3); V.push_back(v4); V.push_back(v5); for (size_t i = 0; i &amp;lt; V.size(); i++) { for (size_t j = 0; j &amp;lt; V[i].size(); j++) { cout &amp;lt;&amp;lt; V[i][j] &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; endl; } return 0;}2차원 벡터에 벡터를 push_back 해줌으로써 이제 원소마다 다른 길이인 벡터가 생겼습니다! 이런 배열을 Jagged Array라고 합니다.어, 그런데 이번엔 size_t가 있네요. 대체 헷갈리게 왜이러시는거죠?그 이유는 v.size() 함수가 int가 아닌, size_t 타입을 반환하기 때문에 해준 것입니다. 그리고 size_t 타입은 unsigned int가 typedef로 이름만 바뀌어있는 것입니다. unsigned int는, “부호 없는” int타입이라는 뜻으로 원래 int의 범위가 약 -20억~+20억 이었다면 이 타입은 0 ~ 40억 까지가 범위가 됩니다. 마이너스 크기는 없기 때문이죠. 같은 int지만 약간 다르기때문에 int 대신 size_t 타입을 사용하는것을 습관화하는것이 좋습니다.마지막으로, 벡터의 중요한 특성을 알려드리겠습니다. 벡터는 길이가 자유자재로 변하는 가변 배열이라고 하였습니다. 하지만, 듣기에는 좋아 보이는 이 특성이 사실 벡터의 허점이기도 합니다. 벡터의 현재 크기보다 더 많은 원소를 할당하려고 하면, 메모리를 재할당해야 합니다. 그리고, 벡터가 원래 가지고 있던 모든 원소들을 다 복사해서 새로 할당된 메모리에 저장하고, 원래의 메모리는 해제합니다. 이 공간의 크기는 capacity() 함수로 확인할 수 있고, reserve() 함수로 할당할 수 있습니다.여기까지 전부 이해했다면 벡터는 이제 끝났습니다! 다음 STL도 공부해봅시다." } ]
