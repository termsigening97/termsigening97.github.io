<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="유니티 그래픽스 최적화" /><meta property="og:locale" content="ko" /><meta name="description" content="2종류의 드로우콜 드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다. Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다. SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다. 이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 드로우콜이 늘어난다. Batching(배칭) 여러 오브젝트들에게 동일한 Material을 사용하게 하여서 SetPass call을 줄이는 것. 텍스처 아틀라스(Atlas) 기법으로 서로 다른 오브젝트임에도 하나의 텍스쳐로 합쳐서 머티리얼을 공유시키면 Batch는 메쉬당 여러번이라도 SetPass는 공유된 머티리얼만큼만 호출된다. 여기서 머티리얼이란 머티리얼 인스턴스를 말하며, 같은 머티리얼이라도 다른 에셋(복사본 등)이라면 Batching되지 않는다. 또한, 스크립트로 접근할 때에도 주의해야하는데, 아래와 같이 Renderer 컴포넌트의 material 속성을 수정하면 머티리얼의 복사본이 생성된다. GetComponent&lt;Renderer&gt;().material.color = Color.red; 대신 sharedMaterial을 사용하면 공유하고 있는 머티리얼을 수정할 수 있지만, 해당 머티리얼을 사용하는 모든 오브젝트에 적용된다. Edit [&gt;] Project Setting [&gt;] Player 에서 Static Batching, Dynamic Batching을 사용할 수 있고, 조건이 맞으면 자동 배칭이 된다. Static Batching 정적인 오브젝트들을 위한 배칭 기법이며, 주로 배경 오브젝트에 해당된다. GameObject 속성에서 Static을 체크해줘야만 적용되며, 이 Static에 대해 모른다면 이동/회전/스케일이 조절되지 않는, 게임 시작부터 끝까지 절대로 변화하지 않는 오브젝트이다. 그렇기에 로딩 시간에 자동 배칭하여서 성능이 매우 뛰어나다. Mesh의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 Mesh를 그릴 때의 드로우콜을 줄여준다. Batch콜 자체를 줄여주는데, 내부적으로 모든 Mesh를 합친다. 그래서 원래 3개의 오브젝트가 1개의 Mesh만 사용한다면 메모리에는 1개의 Mesh만 있으면 되는데, Static Batching에서는 3개의 Mesh를 합친 만큼의 메모리가 필요하게 된다. 런타임 중에 생성된 Static 오브젝트들은 자동 배칭처리되지 않으며, 배칭처리를 하고싶다면 생성 후에 StaticBatchingUtility.Combine() 메서드를 사용해야 한다. 하지만 이 방법을 사용하면 Mesh를 재생성해야하기 때문에 많은 시간이 필요해서 일반적으로 사용되지 않는다. 보통 배경을 모듈화 방식으로 제작하여(바닥, 벽, 기둥 따로) Static Batching을 이용한다. 3D툴에서 하나의 커다란 Mesh로 미리 만들어온다면 카메라에 가려져 보이지 않는 Culling 처리가 이루어질때 일부만 보여도 전체의 폴리곤이 처리가 되기 때문이다. Dynamic Batching 비 Static인 오브젝트들의 Vertex들을 모아서 합쳐서 오버헤드가 발생하지만 드로우콜을 줄여 전체적인 성능 향상을 가져오는 것. 단, Skinned Mesh와 Vertex가 너무 많은 Mesh는 제외된다. 가끔 오버헤드가 더 많아 시간이 더 소요되는 경우도 있고, 제약사항이 많이 있기 때문에 성능이 크게 향상되지는 않을 수 있다. Frustum Culling 카메라 범위 밖은 렌더링 하지 않는것. 자동으로 처리되어서 따로 설정해줄 필요는 없고, 특히 고전게임 분야에서 시야 전체를 렌더링하지 않고 근~중거리만 렌더링하여 잘린 부분을 안개로 채운다. 또는, 애초에 탑뷰 시점 등으로 게임을 만들어서 사야를 넓게 보이지 않게한다. Occlusion Culling 다른 오브젝트에 가려진 오브젝트는 렌더링 하지 않는것. Window [&gt;] Rendering [&gt;] Occlusion Culling에서 Bake을 눌러 생성할 수 있다. Occluder는 가려지게 하는 오브젝트, Occludee는 가려지는 오브젝트를 의미하는데 Occluder는 사전 데이터가 필요하기 때문에 Static 오브젝트만 가능하고, Occludee는 Dynamic 오브젝트도 가능하다. Mesh Renderer 컴포넌트에 Dynamic Occluded 옵션이 체크되어있으면 활성화된다. 미리 데이터를 만들어 두는 것이기 때문에 정밀도를 설정해야 하는데, 정밀도가 높을수록 데이터 크기가 증가하고 연산 오버헤드가 발생한다. 적절히 테스트해서 맞추어야 한다. LOD(Level of Detail) 카메라와의 거리에 따라 오브젝트의 퀄리티를 조절해서 보여주는 기능이다. 자동으로 만들어 주는 것도 있지만, 대부분 단계별 LOD Mesh를 만들어서 사용한다." /><meta property="og:description" content="2종류의 드로우콜 드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다. Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다. SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다. 이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 드로우콜이 늘어난다. Batching(배칭) 여러 오브젝트들에게 동일한 Material을 사용하게 하여서 SetPass call을 줄이는 것. 텍스처 아틀라스(Atlas) 기법으로 서로 다른 오브젝트임에도 하나의 텍스쳐로 합쳐서 머티리얼을 공유시키면 Batch는 메쉬당 여러번이라도 SetPass는 공유된 머티리얼만큼만 호출된다. 여기서 머티리얼이란 머티리얼 인스턴스를 말하며, 같은 머티리얼이라도 다른 에셋(복사본 등)이라면 Batching되지 않는다. 또한, 스크립트로 접근할 때에도 주의해야하는데, 아래와 같이 Renderer 컴포넌트의 material 속성을 수정하면 머티리얼의 복사본이 생성된다. GetComponent&lt;Renderer&gt;().material.color = Color.red; 대신 sharedMaterial을 사용하면 공유하고 있는 머티리얼을 수정할 수 있지만, 해당 머티리얼을 사용하는 모든 오브젝트에 적용된다. Edit [&gt;] Project Setting [&gt;] Player 에서 Static Batching, Dynamic Batching을 사용할 수 있고, 조건이 맞으면 자동 배칭이 된다. Static Batching 정적인 오브젝트들을 위한 배칭 기법이며, 주로 배경 오브젝트에 해당된다. GameObject 속성에서 Static을 체크해줘야만 적용되며, 이 Static에 대해 모른다면 이동/회전/스케일이 조절되지 않는, 게임 시작부터 끝까지 절대로 변화하지 않는 오브젝트이다. 그렇기에 로딩 시간에 자동 배칭하여서 성능이 매우 뛰어나다. Mesh의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 Mesh를 그릴 때의 드로우콜을 줄여준다. Batch콜 자체를 줄여주는데, 내부적으로 모든 Mesh를 합친다. 그래서 원래 3개의 오브젝트가 1개의 Mesh만 사용한다면 메모리에는 1개의 Mesh만 있으면 되는데, Static Batching에서는 3개의 Mesh를 합친 만큼의 메모리가 필요하게 된다. 런타임 중에 생성된 Static 오브젝트들은 자동 배칭처리되지 않으며, 배칭처리를 하고싶다면 생성 후에 StaticBatchingUtility.Combine() 메서드를 사용해야 한다. 하지만 이 방법을 사용하면 Mesh를 재생성해야하기 때문에 많은 시간이 필요해서 일반적으로 사용되지 않는다. 보통 배경을 모듈화 방식으로 제작하여(바닥, 벽, 기둥 따로) Static Batching을 이용한다. 3D툴에서 하나의 커다란 Mesh로 미리 만들어온다면 카메라에 가려져 보이지 않는 Culling 처리가 이루어질때 일부만 보여도 전체의 폴리곤이 처리가 되기 때문이다. Dynamic Batching 비 Static인 오브젝트들의 Vertex들을 모아서 합쳐서 오버헤드가 발생하지만 드로우콜을 줄여 전체적인 성능 향상을 가져오는 것. 단, Skinned Mesh와 Vertex가 너무 많은 Mesh는 제외된다. 가끔 오버헤드가 더 많아 시간이 더 소요되는 경우도 있고, 제약사항이 많이 있기 때문에 성능이 크게 향상되지는 않을 수 있다. Frustum Culling 카메라 범위 밖은 렌더링 하지 않는것. 자동으로 처리되어서 따로 설정해줄 필요는 없고, 특히 고전게임 분야에서 시야 전체를 렌더링하지 않고 근~중거리만 렌더링하여 잘린 부분을 안개로 채운다. 또는, 애초에 탑뷰 시점 등으로 게임을 만들어서 사야를 넓게 보이지 않게한다. Occlusion Culling 다른 오브젝트에 가려진 오브젝트는 렌더링 하지 않는것. Window [&gt;] Rendering [&gt;] Occlusion Culling에서 Bake을 눌러 생성할 수 있다. Occluder는 가려지게 하는 오브젝트, Occludee는 가려지는 오브젝트를 의미하는데 Occluder는 사전 데이터가 필요하기 때문에 Static 오브젝트만 가능하고, Occludee는 Dynamic 오브젝트도 가능하다. Mesh Renderer 컴포넌트에 Dynamic Occluded 옵션이 체크되어있으면 활성화된다. 미리 데이터를 만들어 두는 것이기 때문에 정밀도를 설정해야 하는데, 정밀도가 높을수록 데이터 크기가 증가하고 연산 오버헤드가 발생한다. 적절히 테스트해서 맞추어야 한다. LOD(Level of Detail) 카메라와의 거리에 따라 오브젝트의 퀄리티를 조절해서 보여주는 기능이다. 자동으로 만들어 주는 것도 있지만, 대부분 단계별 LOD Mesh를 만들어서 사용한다." /><link rel="canonical" href="https://termsigening97.github.io/posts/unity-optimization/" /><meta property="og:url" content="https://termsigening97.github.io/posts/unity-optimization/" /><meta property="og:site_name" content="Sigening" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-12T14:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="유니티 그래픽스 최적화" /><meta name="twitter:site" content="@termsigening97" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-12T14:21:07+09:00","datePublished":"2022-05-12T14:00:00+09:00","description":"2종류의 드로우콜 드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다. Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다. SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다. 이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 드로우콜이 늘어난다. Batching(배칭) 여러 오브젝트들에게 동일한 Material을 사용하게 하여서 SetPass call을 줄이는 것. 텍스처 아틀라스(Atlas) 기법으로 서로 다른 오브젝트임에도 하나의 텍스쳐로 합쳐서 머티리얼을 공유시키면 Batch는 메쉬당 여러번이라도 SetPass는 공유된 머티리얼만큼만 호출된다. 여기서 머티리얼이란 머티리얼 인스턴스를 말하며, 같은 머티리얼이라도 다른 에셋(복사본 등)이라면 Batching되지 않는다. 또한, 스크립트로 접근할 때에도 주의해야하는데, 아래와 같이 Renderer 컴포넌트의 material 속성을 수정하면 머티리얼의 복사본이 생성된다. GetComponent&lt;Renderer&gt;().material.color = Color.red; 대신 sharedMaterial을 사용하면 공유하고 있는 머티리얼을 수정할 수 있지만, 해당 머티리얼을 사용하는 모든 오브젝트에 적용된다. Edit [&gt;] Project Setting [&gt;] Player 에서 Static Batching, Dynamic Batching을 사용할 수 있고, 조건이 맞으면 자동 배칭이 된다. Static Batching 정적인 오브젝트들을 위한 배칭 기법이며, 주로 배경 오브젝트에 해당된다. GameObject 속성에서 Static을 체크해줘야만 적용되며, 이 Static에 대해 모른다면 이동/회전/스케일이 조절되지 않는, 게임 시작부터 끝까지 절대로 변화하지 않는 오브젝트이다. 그렇기에 로딩 시간에 자동 배칭하여서 성능이 매우 뛰어나다. Mesh의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 Mesh를 그릴 때의 드로우콜을 줄여준다. Batch콜 자체를 줄여주는데, 내부적으로 모든 Mesh를 합친다. 그래서 원래 3개의 오브젝트가 1개의 Mesh만 사용한다면 메모리에는 1개의 Mesh만 있으면 되는데, Static Batching에서는 3개의 Mesh를 합친 만큼의 메모리가 필요하게 된다. 런타임 중에 생성된 Static 오브젝트들은 자동 배칭처리되지 않으며, 배칭처리를 하고싶다면 생성 후에 StaticBatchingUtility.Combine() 메서드를 사용해야 한다. 하지만 이 방법을 사용하면 Mesh를 재생성해야하기 때문에 많은 시간이 필요해서 일반적으로 사용되지 않는다. 보통 배경을 모듈화 방식으로 제작하여(바닥, 벽, 기둥 따로) Static Batching을 이용한다. 3D툴에서 하나의 커다란 Mesh로 미리 만들어온다면 카메라에 가려져 보이지 않는 Culling 처리가 이루어질때 일부만 보여도 전체의 폴리곤이 처리가 되기 때문이다. Dynamic Batching 비 Static인 오브젝트들의 Vertex들을 모아서 합쳐서 오버헤드가 발생하지만 드로우콜을 줄여 전체적인 성능 향상을 가져오는 것. 단, Skinned Mesh와 Vertex가 너무 많은 Mesh는 제외된다. 가끔 오버헤드가 더 많아 시간이 더 소요되는 경우도 있고, 제약사항이 많이 있기 때문에 성능이 크게 향상되지는 않을 수 있다. Frustum Culling 카메라 범위 밖은 렌더링 하지 않는것. 자동으로 처리되어서 따로 설정해줄 필요는 없고, 특히 고전게임 분야에서 시야 전체를 렌더링하지 않고 근~중거리만 렌더링하여 잘린 부분을 안개로 채운다. 또는, 애초에 탑뷰 시점 등으로 게임을 만들어서 사야를 넓게 보이지 않게한다. Occlusion Culling 다른 오브젝트에 가려진 오브젝트는 렌더링 하지 않는것. Window [&gt;] Rendering [&gt;] Occlusion Culling에서 Bake을 눌러 생성할 수 있다. Occluder는 가려지게 하는 오브젝트, Occludee는 가려지는 오브젝트를 의미하는데 Occluder는 사전 데이터가 필요하기 때문에 Static 오브젝트만 가능하고, Occludee는 Dynamic 오브젝트도 가능하다. Mesh Renderer 컴포넌트에 Dynamic Occluded 옵션이 체크되어있으면 활성화된다. 미리 데이터를 만들어 두는 것이기 때문에 정밀도를 설정해야 하는데, 정밀도가 높을수록 데이터 크기가 증가하고 연산 오버헤드가 발생한다. 적절히 테스트해서 맞추어야 한다. LOD(Level of Detail) 카메라와의 거리에 따라 오브젝트의 퀄리티를 조절해서 보여주는 기능이다. 자동으로 만들어 주는 것도 있지만, 대부분 단계별 LOD Mesh를 만들어서 사용한다.","headline":"유니티 그래픽스 최적화","mainEntityOfPage":{"@type":"WebPage","@id":"https://termsigening97.github.io/posts/unity-optimization/"},"url":"https://termsigening97.github.io/posts/unity-optimization/"}</script><title>유니티 그래픽스 최적화 | Sigening</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sigening"><meta name="application-name" content="Sigening"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/Profile.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sigening</a></div><div class="site-subtitle font-italic">Game Dev</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/termsigening97" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/termsigening97" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['termsigening97','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>유니티 그래픽스 최적화</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>유니티 그래픽스 최적화</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/termsigening97">Jun Hwi Gu</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1652331600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-12 </em> </span> <span> Updated <em class="timeago" data-ts="1652332867" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-12 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1558 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><h2 id="2종류의-드로우콜"><span class="mr-2">2종류의 드로우콜</span><a href="#2종류의-드로우콜" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다.</p><p>Batch란? DP Call, 상태 변경 등을 합친 넓은 의미의 드로우콜. 게임오브젝트(혹은 Mesh)당 하나씩은 존재한다고 생각하면 된다.</p><p>SetPass란? 많은 상태 변경들을 포함하는 것으로, 상태 변경이 많을수록 그만큼 비용이 소모된다. 머티리얼당 하나씩은 존재한다고 생각하면 된다.</p><p>이 외에도 Shader에서 Mesh의 정보 등을 가져가 사용하는 경우 드로우콜이 늘어난다.</p><h2 id="batching배칭"><span class="mr-2">Batching(배칭)</span><a href="#batching배칭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>여러 오브젝트들에게 동일한 Material을 사용하게 하여서 SetPass call을 줄이는 것. 텍스처 아틀라스(Atlas) 기법으로 서로 다른 오브젝트임에도 하나의 텍스쳐로 합쳐서 머티리얼을 공유시키면 Batch는 메쉬당 여러번이라도 SetPass는 공유된 머티리얼만큼만 호출된다.</p><p>여기서 머티리얼이란 머티리얼 인스턴스를 말하며, 같은 머티리얼이라도 다른 에셋(복사본 등)이라면 Batching되지 않는다.</p><p>또한, 스크립트로 접근할 때에도 주의해야하는데, 아래와 같이 Renderer 컴포넌트의 material 속성을 수정하면 머티리얼의 복사본이 생성된다.</p><p><code class="language-plaintext highlighter-rouge">GetComponent&lt;Renderer&gt;().material.color = Color.red;</code></p><p>대신 sharedMaterial을 사용하면 공유하고 있는 머티리얼을 수정할 수 있지만, 해당 머티리얼을 사용하는 모든 오브젝트에 적용된다.</p><p>Edit [&gt;] Project Setting [&gt;] Player 에서 Static Batching, Dynamic Batching을 사용할 수 있고, 조건이 맞으면 자동 배칭이 된다.</p><h2 id="static-batching"><span class="mr-2">Static Batching</span><a href="#static-batching" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>정적인 오브젝트들을 위한 배칭 기법이며, 주로 배경 오브젝트에 해당된다. GameObject 속성에서 Static을 체크해줘야만 적용되며, 이 Static에 대해 모른다면 이동/회전/스케일이 조절되지 않는, 게임 시작부터 끝까지 절대로 변화하지 않는 오브젝트이다. 그렇기에 로딩 시간에 자동 배칭하여서 성능이 매우 뛰어나다.</p><p>Mesh의 폴리곤 수에 구애받지 않고 같은 머티리얼을 사용하는 Mesh를 그릴 때의 드로우콜을 줄여준다. Batch콜 자체를 줄여주는데, 내부적으로 모든 Mesh를 합친다. 그래서 원래 3개의 오브젝트가 1개의 Mesh만 사용한다면 메모리에는 1개의 Mesh만 있으면 되는데, Static Batching에서는 3개의 Mesh를 합친 만큼의 메모리가 필요하게 된다.</p><p>런타임 중에 생성된 Static 오브젝트들은 자동 배칭처리되지 않으며, 배칭처리를 하고싶다면 생성 후에 <code class="language-plaintext highlighter-rouge">StaticBatchingUtility.Combine()</code> 메서드를 사용해야 한다. 하지만 이 방법을 사용하면 Mesh를 재생성해야하기 때문에 많은 시간이 필요해서 일반적으로 사용되지 않는다.</p><p>보통 배경을 모듈화 방식으로 제작하여(바닥, 벽, 기둥 따로) Static Batching을 이용한다. 3D툴에서 하나의 커다란 Mesh로 미리 만들어온다면 카메라에 가려져 보이지 않는 Culling 처리가 이루어질때 일부만 보여도 전체의 폴리곤이 처리가 되기 때문이다.</p><h2 id="dynamic-batching"><span class="mr-2">Dynamic Batching</span><a href="#dynamic-batching" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>비 Static인 오브젝트들의 Vertex들을 모아서 합쳐서 오버헤드가 발생하지만 드로우콜을 줄여 전체적인 성능 향상을 가져오는 것.</p><p>단, Skinned Mesh와 Vertex가 너무 많은 Mesh는 제외된다.</p><p>가끔 오버헤드가 더 많아 시간이 더 소요되는 경우도 있고, 제약사항이 많이 있기 때문에 성능이 크게 향상되지는 않을 수 있다.</p><h2 id="frustum-culling"><span class="mr-2">Frustum Culling</span><a href="#frustum-culling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>카메라 범위 밖은 렌더링 하지 않는것. 자동으로 처리되어서 따로 설정해줄 필요는 없고, 특히 고전게임 분야에서 시야 전체를 렌더링하지 않고 근~중거리만 렌더링하여 잘린 부분을 안개로 채운다. 또는, 애초에 탑뷰 시점 등으로 게임을 만들어서 사야를 넓게 보이지 않게한다.</p><h2 id="occlusion-culling"><span class="mr-2">Occlusion Culling</span><a href="#occlusion-culling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>다른 오브젝트에 가려진 오브젝트는 렌더링 하지 않는것. Window [&gt;] Rendering [&gt;] Occlusion Culling에서 Bake을 눌러 생성할 수 있다. Occluder는 가려지게 하는 오브젝트, Occludee는 가려지는 오브젝트를 의미하는데 Occluder는 사전 데이터가 필요하기 때문에 Static 오브젝트만 가능하고, Occludee는 Dynamic 오브젝트도 가능하다. Mesh Renderer 컴포넌트에 Dynamic Occluded 옵션이 체크되어있으면 활성화된다.</p><p>미리 데이터를 만들어 두는 것이기 때문에 정밀도를 설정해야 하는데, 정밀도가 높을수록 데이터 크기가 증가하고 연산 오버헤드가 발생한다. 적절히 테스트해서 맞추어야 한다.</p><h2 id="lodlevel-of-detail"><span class="mr-2">LOD(Level of Detail)</span><a href="#lodlevel-of-detail" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>카메라와의 거리에 따라 오브젝트의 퀄리티를 조절해서 보여주는 기능이다. 자동으로 만들어 주는 것도 있지만, 대부분 단계별 LOD Mesh를 만들어서 사용한다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lecture/'>Lecture</a>, <a href='/categories/game-dev/'>Game Dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/optimize/" class="post-tag no-text-decoration" >Optimize</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=유니티 그래픽스 최적화 - Sigening&amp;url=https://termsigening97.github.io/posts/unity-optimization/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=유니티 그래픽스 최적화 - Sigening&amp;u=https://termsigening97.github.io/posts/unity-optimization/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://termsigening97.github.io/posts/unity-optimization/&amp;text=유니티 그래픽스 최적화 - Sigening" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/unity-optimization/">유니티 그래픽스 최적화</a><li><a href="/posts/Scraps/">지식 스크랩</a><li><a href="/posts/data-structure-and-algorithms/">자료구조와 알고리즘</a><li><a href="/posts/C-lecture/">C언어 총정리</a><li><a href="/posts/game-design/">게임 디자인</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cpp/">CPP</a> <a class="post-tag" href="/tags/essence/">Essence</a> <a class="post-tag" href="/tags/game-design/">Game Design</a> <a class="post-tag" href="/tags/architect/">Architect</a> <a class="post-tag" href="/tags/optimize/">Optimize</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/ux-and-game-design/"><div class="card-body"> <em class="timeago small" data-ts="1636426800" > 2021-11-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>게임 기획과 UX</h3><div class="text-muted small"><p> 글을 읽기 미리 앞서 UX/UI 가 아님을 유의하라. 필자는 UI와 UX를 분리하여 보아야 한다고 생각하며, UX는 게임의 모든 요소에 적용되어야 한다고 생각한다. 게임 기획과 인지심리학 : 지각, 기억, 주의, 동기, 정서 정보 ‘처리’ 와 학습은 자극에 대한 지각으로 시작해 궁극적으로는 시냅스 변경, 즉 기억에서의 변경으로 끝이 난다. ...</p></div></div></a></div><div class="card"> <a href="/posts/game-design/"><div class="card-body"> <em class="timeago small" data-ts="1638154800" > 2021-11-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>게임 디자인</h3><div class="text-muted small"><p> 게임의 구조 게임의 요소에는 플레이어, 목표, 진행 방법, 규칙, 리소스(자원), 갈등, 경계(현실과 가상), 결과가 있으며 이것들은 ‘형식적 요소’ 라고 한다. 게임에 플레이어를 참여시키기 위해서는 도전, 플레이, 전제, 캐릭터, 스토리가 있어야 하고 이것들은 ‘극적 요소’ 라고 한다. 크리스 크로포드의 상호작용 정도에 따른 놀이 활동 분류 ...</p></div></div></a></div><div class="card"> <a href="/posts/puzzle-design/"><div class="card-body"> <em class="timeago small" data-ts="1641092400" > 2022-01-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>퍼즐 디자인</h3><div class="text-muted small"><p> 퍼즐 디자인을 하는법 목적이 없는 무작위 규칙으로 시작한다 좋은 퍼즐에서, 행위에는 예상 가능한 결과를 가지고 있다 좋은 퍼즐에서, 규칙은 주로 별로 복잡하지 않다 특정 목적들로 실험을 한다. 반복적으로 규칙을 강화한다 게임 시스템에서 떼기 힘든 요소가 있다면, 그게 바로 목적...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Scraps/" class="btn btn-outline-primary" prompt="Older"><p>지식 스크랩</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "termsigening97/termsigening97.github.io", "data-repo-id": "R_kgDOG6QKqw", "data-category": "Announcements", "data-category-id": "DIC_kwDOG6QKq84CBWWc", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/termsigening97">Jun Hwi Gu</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cpp/">CPP</a> <a class="post-tag" href="/tags/essence/">Essence</a> <a class="post-tag" href="/tags/game-design/">Game Design</a> <a class="post-tag" href="/tags/architect/">Architect</a> <a class="post-tag" href="/tags/optimize/">Optimize</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
