<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="지식 스크랩" /><meta property="og:locale" content="ko" /><meta name="description" content="Informative URLS Refactoring &amp; Design Pattern Website Unreal Engine Multiplayer - Replication Youtube Tiny Facts 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는, 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 상황이 보인다. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 구상한 아이디어로 프로토타입을 작성하여 플레이테스트를 해 보아라. 이 때, 프로토타입은 필수적인 기능만 빠르게 작성하도록 한다. 또한, 반복작업을 통해 개선하라. 프로토타입이 좋다고 해도 이를 바로 최종 결과물로 가능한 작성하지 마라. 프로토타입에서 아이디어가 나오지는 않는다. 이는 단지 어떤 것이 좋은 아이디어인지, 나쁜 아이디어인지 판단을 가능하게 해 준다. 만약 내 게임을 설명할 때 “어떤 게임과 비슷하지만 어떤 스토리와 배경을 가지고 있다” 와 같이 기존 게임의 복제판에 불과한 게임을 만들고 싶지 않다면 자신의 원래 개념으로 돌아가 “이 아이디어에서 특별한 것은 무엇인가?” 라고 묻는 것이다. Personal Studies 인생의 12가지 법칙 - 질서너머 中 기존 제도나 창의적 변화를 함부로 깎아내리지 마라 내가 누구일 수 있는지 상상하고, 그것을 목표로 삼아라 원치 않는 것을 안개 속에 묻어두지 마라 남들이 책임을 방치한 곳에 기회가 숨어 있음을 인식하라 하고 싶지 않은 것을 하지 마라 이데올로기를 버려라 최소한 한 가지 일에 최대한 파고들고, 그 결과를 지켜보라 방 하나를 할 수 있는 한 아름답게 꾸며보라 여전히 나를 괴롭히는 기억이 있다면 아주 자세하게 글로 써보라 관계의 낭만을 유지하기 위해 성실히 계획하고 관리하라 분개하거나 거짓되거나 교만하지 마라 고통스러울지라도 감사하라 여기서 가장 큰 교훈은, 무언가를 평가하기 위해서는 그것에 대해 완전히 이해해야 한다는 점이다. 젊은 혈기에 근거없이 현재의 제도를 비판하지 말고 그 제도의 이유를 먼저 알고, 설득하라. 더 높은 도덕을 위해 법칙을 깨려는 사람은 처음에는 그 법칙을 철저히 익히고 훈련해서 그 필요성을 이해해야 한다. 그리고 법칙의 자구字句 가 아니라 그 정신에 맞게 법칙을 깨야 한다. 반복 설계iterative design 어떤 설계안은 본질적으로 오류가 발생하기 쉬우므로 고치지 말고 버려야 한다, 설계 과정에서 이런 막다른 골목을 예상해야 한다, 막다른 골목에 이르기까디 쏟아 부은 노력은 깔끔하고 산뜻한 새 출발을 위해 치르는 작은 대가에 불과하다. 하지만 많은 관리자들이 그랬다가는 상사와 굉장히 곤란한 정치적 갈등에 빠지리라 생각한다. 이는 장기적으로 돈이 더 들더라도 불량 버전을 수선하는 게 낫다고 생각하는 것과 같다. 무지의 5단계 0단계 무지 - 무지의 부재 (Lack of Ignorance) 무엇을 해야할지, 어떻게 표현할 지 알고 있는 단계 1단계 무지 - 지식의 부재(Lack of Knowledge) 어떻게 해야 할지 모르지만, 하기 위해서 무엇을 배워야 할 지 아는 단계. 2단계 무지 - 지각의 부재(Lack of Awareness) 어떤 것을 모른 다는 것을 모르는 단계. 3단계 무지 - 프로세스의 부재(Lack of Process) 어떤 모르는 것에 대해서 모른 다는 것(2단계 무지)을 알아내기 위한 적당하고 효율적인 방법 모르는 단계 4단계 무지 - 메타 무지 (Meta-Ignorance) 무지의 5단계에 대해서 모르는 단계. 산만의 지속 세대 차이를 뚜렷이 부각하는 요소는 집중이다. 나이 든 사람은 한 번에 한두 가지 일에 집중하는 반면 젊은이들은 온갖 일에 주의를 분산한다. 아이팟으로 음악을 틀어놓고, 끊임없이 문자를 하며, SNS 사이트는 24시간 열어두고, 학교 숙제 도중에 간간히 비디오 게임도 해가며 공부하는 세대를 린다 스톤은 “산만의 지속” 이라고 묘사한다. 젊은 신입은 이런 환경에서 가장 효율적으로 일한다고 말한다. 문제는 산만의 지속이 몰입과는 정확히 반대 상태라는 사실이다. 일을 하는데 몰입이 필수라는 것에 동의한다면, 어느 선에서 주의의 분산을 제지해야 한다. 업무 시간 2%를 한번에 연달아 페이스북에 쏟는 경우와 종일 주의의 2%를 페이스북에 쏟는 경우가 다르다는 사실을 젊은 신입이 이해하게 해야된다. 몰입하지 못해 일에 장애가 생기기 때문이다. 인적 자본 투자 회사가 사람에게 투자하는 돈에 관리자가 바라보는 관점은 중요하다. 인적 자본에는 실체가 있다. 이것을 버리는 돈(경비)로 잘못 생각하면 조직이 투자한 가치를 보존하지 못하는 행동을 관리자가 무심코 저지르게 만들지도 모른다. 물론 ‘조직이 투자한 가치를 보존하지 못하는 행동’은 문제 있는 관리의 전형적인 표본이다. 중간 관리층과 경영진이 장기적인 성장을 희생해 단기적인 성과를 내는(당장의 분기 수익을 높이는)더 나은 방법을 내놓겠다고 서로 경쟁하며 싸운다. 보통은 이것을 “손익 계산만을 문제 삼은 의식”이라 부르지만, 우리는 또 다른 이름인 “종자용 옥수수 먹기” 라 부른다. 잘못된 면접 방식 똑똑한 척하는 면접관을 세운다: 이 면접관은 사사로운 즐거움을 위해 지원자를 힘든 상황으로 몰아붙일것이다. 수수께끼식 질문을 던진다: 비행기에 골프 공이 몇 개나 들어갈까? 구글이 했었던 면접이지만 이제 그 당사자들도 잘못된 것을 깨닫고 이런 질문을 그만둔지 오래이다. 개발능력과 아무 상관이 없다. 답을 모르는 질문을 한다: 면접관으로서 어떤 질문에 어떤 답변이 나와야 하는지 잘 모르겠다면 채용 중인 직무와 관련해서는 그다지 중요한 질문이 아닐 가능성이 높다. 지원자를 바보로 만든다: “내가 질문에 대답을 다 하고, 구현했던 아키텍처에 대해 설명을 요청해 주었을 때 즉시 일어나서 화이트보드에 설명을 했다. 그때 내 직속 상관이 될 면접관이 “너무 단순하네요. 그건 제대로 된 실제 아키텍처가 아닙니다.” 라고 하였다. 그래서 “감사합니다. 이 단순한 아키텍처가 3개 대륙에 걸쳐 2천만 명이 넘는 가입자를 서비스하고 있습니다. 간단한 시스템으로 해냈다는 것을 기쁘게 생각합니다.” 라고 말했고, 면접 기회를 준 것에 감사를 표하고 자리를 떠났다. 인터넷 접속을 막는다: 코딩 면접을 할 때 진짜 코딩 실력을 알겠다는 이유로 이러는 것은 말도 안된다. 솔루션 탐색 능력 또한 지원자에게 필요한 능력이며, 인터넷 검색때문에 코딩 면접이 변별력을 잃을 수 있다면 면접 과제 자체에 문제가 있는 것이다. 종이에 코드를 작성하게 한다: 우리는 학교처럼 의사 코드로 평가하는 것이 아니다. 실제도구를 이용해서 생산된 실제 코드를 평가해야 한다. 알고리즘 문제를 낸다: 시스템 개발에 필요한 상당수의 업무들이 알고리즘에 대한 깊은 이해를 필요로 하지 않는다. “지원자의 문제 해결 능력을 보아야 한다.” 라는 이유인데, 맞는 말이지만 회사의 실제 프로젝트와 가까운 다른 연습문제를 통해서도 이를 평가할 수 있다. 여러 시스템의 문제는 테스트가 부족하거나, 잘못된 설계, 떨어지는 응집성, 깊은 종속성, 새 기능 추가 시 부족한 리팩토링, 지속적인 요구사항 변경, 도메인 모델이 정교하지 못했다는 것들 등이 흔한 문제이다. 알고리즘은 절차적이고 함수적이며, 구현할 때 비즈니스 도메인 모델이나 클래스를 만들지는 않는다. 문제의 요지는, 회사에 필요한 개발능력을 평가해야한다. 알고리즘이 필요한거라면 알고리즘을, TDD(테스트주도개발)능력이 필요한거라면 그에 걸맞는 코딩 문제를 재시해야한다. 전화 면접을 한다: 시간이 부족할때만 해라. 딱딱하게 진행될 가능성이 높다. 잘못된 채용 공고 로 애들러Lou Adler “ 기술과 경험을 나열하는 전통적인 직무 요건은 재능에도 반하고, 다양성에도 반하며, 성공적인 채용과의 상관관계도 최악이다 “ 절대적인 숫자 숫자는 임의적이고 오해하기 쉬우며 변덕스럽다. 5년 간의 자바 경력… 얼마 이상의 대학 학점… 과 같은것은 후보자를 제대로 선별하는 데 별 도움이 안된다. 채용된 후에 새로운 기술 학습 없이 같은 기술만으로 오래 일하는 개발자들이 많고, 이는 매년 새로운 기술을 익힌 개발자에 비해 1/5의 가치를 지니고 있다고 할 수도 있다. 키워드 매칭 채용 담당자들은 특정 기술이나 플랫폼에 대한 약어들을 선호하지 않는다. 채용 담당자는 해당 업무의 본질적인 부분을 잘 모르기 때문에 선무당에게 굿을 맡기는 결과가 된다. 기술 목록의 나열 불필요하게 너무 많은 기술 목록을 나열하면 재능있고 정직한 개발자가 스스로 지원을 포기하게 만들 수 있다. 보통 더 나은 개발잘르 선별하려는 욕심에 필요한 기술에 희망 기술까지 더해지기 일쑤다. 이는 후보군만 줄이는 행동이며 실제 그 업무를 잘하기 위한 것과 전혀 관계가 없다. 잘못된 기업 문화 설명 기업의 가치와 기대되는 태도, 책임을 채용 공고에 잘못 설명하는 경우가 많다. 팀워크, 긍정적 태도, 열정, 지혜로움과 같은 단어들을 나열하지 않도록 한다. 이러한 것들 중 어느 하나라도 자신이 해당하지 않는다고 스스로를 배제하는 지원자는 없다. 잘못된 요구 항목 더 훌륭한 개발자를 유인하기 위해서는 기술, 경력 년수, 일한 산업군, 출신 학교, 학점보다 그 직무에서 무엇을 책임져야 하는지 설명하는 것이 훨씬 낫다. 위에 나열된 항목들은 실제 역량과 전혀 일치하지 않는다. 잘못된 선별 조건 직무 요건들은 최고의 인재를 얻기 위함이 아닌 아닌 최악의 인재들을 걸러내기 위한 목적으로 설계되어 있다. 최고의 개발자들은 특정 기술의 사용 유무보다 회사의 문화, 업무에서의 책임, 프로젝트의 종류를 훨씬 더 중요하게 여긴다. 승진 요건과의 불일치 승진심사 때, 특정 프레임워크의 API를 알고있거나 자바 경력이 몇년 이상이라서 승진하지 않고, 그가 이룬 성과와 리더십, 팀워크와 같은 다른 중요한 이유로 승진을 한다. 채용 공고의 직무 요건이 이러한 승진 요건과 합치되는 부분이 없다면 그 직무 요건으로 필터링된 사람들이 회사 안에서 좋은 성과를 낼 거라는 기대 자체가 모순이다. 단순한 설계를 위한 네 가지 원칙 모든 테스트의 통과 중복의 최소화 : 동작/설정에 중복이 있으면 안된다. 명료성의 최대화 : 명료하고, 충분히 표현되고, 일관되어야 한다. 구성요소의 최소화 : 메서드, 클래스, 모듈의 수는 가능한 적어야 한다. 오디션 개최 (in “Peopleware”) 우리가 몸담은 업계는 기술적이보다는 사회적이다. 직원-기계의 소통 능력보다 서로와 소통하는 능력이 더 주요하다. 그러므로 직원 채용 절차는 최소한 사회적이고 인간적인 의사소통 역량에 초점을 맞춰야 하며, 이 책의 저자가 발견한 최선의 방법은 후보자에 대한 오디션이다. 개념은 간단하다. 과거에 자신이 수행한 업무와 관련해 10분에서 15분정도 프레젠테이션을 시킨다. 생전 처음 써봤던 새 기술/경험일 수도 있고, 힙겹게 깨우친 관리 경험일 수도 있고, 아주 재미있었던 프로젝트일 수도 있다. 주제는 지원자가 선택하고, 발표일을 정해 지원자와 함께 일할 사람들로 소규모 청중을 구성한다. 물론 지원자는 긴장하고, 안 하려고 들지도 모른다. 누구나 긴장하기 마련이라고 말해주라. 오디션을 여는 이유도 설명하라. 다양한 지원자들의 의사소통 능력을 보고, 미래 동료 직원들을 채용 과정에 참여시키려는 의도라 설명한다. 오디션을 마치고 지원자가 떠난 다음 참석자들과 간단히 후기를 나눈다. 각 참석자가 돌아가며 지원자가 업무에 적합한지, 그리고 팀과 잘 어울릴지 의견을 말한다. 물론 최종적인 결정은 관리자에게 달렸지만 미래 동료 직원들이 내놓는 의견은 굉장히 소중한다. 게다가 이렇게 고용한 신입 직원은 팀도 무리 없이 받아들인다. 팀원들이 뽑자 햇기 때문이다. ” 오디션을 열면 신입 직원과 기존 직원들이 더 빨리 친해진다. 성공적인 오디션은 동료들로부터 받는 일종의 인증이었고, 반대의 경우도 역시 일종의 인증이었다. 실패한 오디션 후에는 직원들의 사기가 확 올라갔다. 자신을 채용한 이유가 하필 그 때 관리자의 책상에 이력서가 놓여 있었던 뜻밖의 행운 때문이 아니라는 사실을 지속적으로 보여주는 증거이기 때문이다. “ 오디션을 열 대는 한 가지 주의할 사항이 있다. 지원자는 회사가 하는 일과 직접 관련 있는 주제를 다뤄야 한다. “랭커 찍은 게임” 이나 “정원 가꾸기” 등 극단적인 주제라면 지원자는 굉장한 열정으로 발표하겠지만, 직장에서는 그런 열정을 못 볼지도 모른다. 베테랑 프로그래머와 대규모 프로젝트 뛰어난 프로그래머들과 좀 처지는 이들 간에는 상당한 생산성 차이가 있고, 이를 대부분의 관리자는 알고 있지만 정확히 수치적으로 나타낸다면 가장 뛰어난 사람과 가장 못한 사람의 생산성 비율이 평균 10:1이나 되고, 실행 속도와 사용 공간 면에서는 다섯 배의 차이가 난다. 간단히 말해, 연복 2만 달러를 받는 프로그래머가 1만 달러를 받는 이에 비해 열 배의 생산성을 발휘할 수 있다는 뜻이며, 물론 그 반대 또한 가능하다. 이 연구의 데이터에서는 경력 연차와 성과 사이에 어떠한 상관 관계도 없었는데, 이는 경험을 하며 실제로 공부하고, 배워서 자신을 발전시키는지 아닌지에 대한 차이인 것 같다. 서로 소통해야 하는 사람 수가 전체 비용에 영향을 미친다. 사람이 많을수록 커뮤니케이션 부담은 N(N-1)/2 배가 되며 어느 순간 인력(맨-먼스, Man-Month) 을 투입해서 얻는 이익보다 손실이 더 많아질 지경에 이르게 될 수 있다. 이것은 비용의 대부분이 커뮤니케이션, 그리고 잘못된 커뮤니케이션의 부작용을 바로잡는 데 소요되기 때문이다. 이는 가능하면 적은 수의 사람들에 의해 시스템이 만들어는 편이 낫다는 것을 시사한다. 개념적 일관성이 부족한 결과물을 만들어 내기 때문이기도 하다. 보통 프로그래머 수백 명이 투입된 프로젝트보다 일급 멤버들로 구성된 작고 예리한 팀이 낫다고 하는데, 그 말 아래에는 앞의 수백 명은 평범하다는 뜻이 깔려 있다. 하지만 이는 “어떻게 해야 ‘큰’ 시스템을 의미 있는 일정 내에 만들어 낼 수 있는가?” 라는 어려운 질문을 회피하는 것을 뜻한다. 예를 들어보자. 200명이 투입된 프로젝트 내에 관리자이면서 가장 유능하고 경험 많은 프로그래머가 25명이 있다면, 나머지 175명은 해고하고 그 관리자들을 다시 프로그래밍에 투입하는 것이다. 하지만 이는 작은 팀은 아닌데, 보통 작은 팀이라면 10명 이하를 뜻하기 때문이다. 25명이면 최소 두 단계로 관리가 이루어지거나 5명의 관리자를 두어야 하는 규모이다. 이 팀에는 재무, 인사, 사무 공간, 비서 업무, 장비 운영에 추가 지원도 필요할 것이다. 하지만 다른 한편으로, 200명인 원래 팀은 정말로 큰 시스템을 주먹구구식으로 만들기에 충분한 규모가 아니다. OS/360의 개발에는 프로젝트에 1000명 넘게 투입되었고, 1963~1966년까지 이 시스템의 설계-구축-문서화에 들어간 공수는 대략 5000맨이어(Man-Year) 정도였다. 밀스Mills의 제안 커다란 전체 업무를 여러 팀에 나눠서 맡기되, 각 팀을 외과 수술 팀처럼 조직할 것의 제안이다. 즉, 모든 팀원이 다 같이 문제에 달려드는 것이 아니라, 한 명이 문제를 해결해 가는 동안 다른 이들은 그 사람이 효율과 생산성을 높일 수 있도록 여러 방면에서 지원해 주는 것이다. 이는 사실 현재로썬 당연한데(이 책은 1975년에 1판, 1995년에 2판이 나왔다), 설계와 구축에는 적은 수의 사람이 개입하면서, 작업에는 여러 사람이 개입한다. 외과의: 수석 프로그래머. 이 사람은 기능과 성능 명세를 직접 정의하며, 프로그램을 설계/코딩/테스트/문서화 한다. 그리고 전체 시스템에 실질적인 접속 권한을 가지고 있으며, 뛰어난 재능과 10년 이상의 경력, 시스템 및 응용 분야에 관한 상당 수준의 지식이 요구된다. 그 분야는 응용 수학이나 비즈니스 데이터 처리 등 무엇이나 될 수 있다. 부조종사: 외과의의 분신. 업무의 어떤 부분이든 수행 가능하지만 경험은 많지 않으며, 주된 역할은 설계 과정에 참여하여 같이 고민-토론-평가 하는 것이다. 외과의가 부조종사와 여러 아이디어를 시도할 수는 있지만, 부조종사의 의견에 구애받지는 않는다. 모든 코드를 상세하게 알고 있고, 대안적인 설계에 대한 전략을 연구하며 종종 팀을 대표한다. 행정 담당: 외과의는 인사, 임금 등의 최종 결정권이 있지만 이 부분에 시간을 할애해서는 안된다. 그러므로 돈, 사람, 공간, 장비를 관장하고 다른 부서의 행정 파트와 소통을 맡아줄 전문적인 행정 담당이 필요하다. 어떤 프로젝트에 법률적 계약적 중대 사안이 있거나, 보고를 강화해야하거나, 재무적 이슈가 있지 않다면 보통 한 명의 행정 담당이 두 팀을 맡을 수 있다. 편집자: 문서 생산은 최대한의 명확성을 위해 외과의가 직접 작성해야 한다. 외부/내부 문서에 동일하게 적용되지만, 외과의가 작성한 초안/구술 원고를 읽은 후에 그것을 비평/재작업/레퍼런스 보충/버전 관리/문서 생산 관리는 편집자가 담당해야 한다. 두 명의 비서: 행정 담당과 편집자는 비서가 한 명씩 필요하며, 행정 비서는 프로젝트 관련 우편물/일반적인 업무 서류를 관리한다. 프로그램 사무원: 이 사람은 팀에서 생산되는 모든 기술적인 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 컴퓨터에서 작업이 실행되는 전 과정을 팀의 멤버 누구나 볼 수 있게 하고, 프로그래밍이라는 작업을 “개인적인 예술에서 공개적인 실행으로” 바꾼다. 이 작업은 현대에서는 소스 컨트롤과 CI/CD라는 작업이 도맡아서 한다. 도구 담당: 여러 편집기, 서비스 중 확실히 신뢰할 수 있고 팀에 적합한 도구를 찾고, 이들을 구축-유지-업그레이드 하는 책임을 받는다. 종종 특화된 유틸리티/목록으로 정리된 프로시저/매크로 라이브러리 등을 구축하기도 한다. 테스터: 테스트 케이서를 만들고, 테스트 순서를 계획하고, 구성 요소 테스트를 위한 Scaffolding을 짠다. 이는 현대에 들어서 TDD(테스트 주도 개발) 과 같은 형태로 바뀌어 모든 프로그래머가 테스트를 작성하게 하기도 한다. 언어 전문가 책에서는 특정 언어를 마스터한 사람을 일컫지만, 알고리즘 전문가 또한 이곳에 포함될 수 있다고 생각한다. 즉, 특정 언어나 기술의 수학적이고 복잡한 부분을 잘 다루는 사람을 뜻한다. 대개 2명~3명의 외과의를 도울 수 있다. 한가지 경고할 점은, 이는 1975년도에 쓰여진 책이고 지금은 이런 내용들이 당연시 여겨지고 있으며 몇몇은 시대를 많이 지났다는 것이다. 하지만 그렇기에 교과서적인 기초와 개발체제의 탄생 배경을 알 수 있기에 참고해볼 만한 가치가 있다. 명세서 잘 짜여진 명세서는 [완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성] 이 있어야 한다. 완전성completeness 사용자의 모든 요구 사항이 누락되지 않고 완전하게 반영되었는가? 일관성consistency 요구 사항이 서로 모순/충돌되는 점은 없고, 산출물이나 요구사항의 내용이 일관성을 유지하는가? 명확성unambiguity 서술된 명세서의 내용이 애매하지 않고 모든 참여자가 명확히 이해 가능한가? 기능성functionality 서술된 명세서의 내용이 ‘어떻게’보다 ‘무엇을’에 관점을 두고 서술되었는가? 검증 가능성verifiability 서술된 명세서의 내용이 사용자의 요구를 만족하는지 검증할 수 있는가? 추적 가능성traceability 사용자 요구 분석 명세서와 설계 사양서를 추적할 수 있는가? 변경 용이성easily changeable 요구 분석 명세서의 내용을 변경하고자 할 때 쉽게 찾아 변경할 수 있는가? AWS EC2 서버 구축하기 운영 서버란? 개발이나 테스트 목적이 아닌, 실제 사용자들을 대상으로 서비스하는 서버를 말합니다. 테스트 할 때와는 다르게 트래픽 대응과 빠른 응답속도, 그리고 높은 가용성을 고려해야 합니다. 운영 서버 관리법은 크게 ‘환경 구성’, ‘코드 배포’, ‘모니터링’의 세 단계로 나뉩니다. ‘환경 구성’은 서비스할 코드를 구동시킬 수 있는 서버 인프라를 구축하는 것이고, ‘코드 배포’는 구성한 환경에 최신 버전의 코드를 빠르고 안전하게 배포하는 것이고, 마지막으로 ‘모니터링’은 안정적인 서비스 운영을 위해 서버와 코드에 어떤 이상이 없는지 바로 파악하고 대응할 수 있게 도와주는 것입니다. AWS(Amazon Web Services) 란? 미국의 대형 인터넷 쇼핑몰인 아마존(Amazon)에서 자사를 위해 개발하였던 인프라 시스템인데, 이 기술을 2006년에 공개하며 서비스하기 시작해서 만들어졌습니다. 컴퓨팅 서버를 클라우드로 제공하여서 원래는 물리적인 기계를 구매하여 배치하고, 구축하고, 작동해야 했기 때문에 전문 인력들이 필요했고, 서버의 상태가 어떻게 될 지 확실하지 않기 때문에 필요 이상의 규모를 구축해야 하지만, AWS와 같은 클라우드 서비스를 이용하면 몇번의 클릭만으로 가용량을 조정할 수 있습니다. 그래서 비용, 시간, 인력적인 면에서 많은 비용 절감이 가능하게 되죠. AWS EC2 인스턴스 생성하기 EC2(Elastic Compute Cloud)는 사양을 고르고 원하는 시간만큼 사용 가능한 가상 서버입니다. 필요할 때마다 키거나 끌 수 있고, 사용한 시간에 대해서만 비용을 지급합니다. 시작하기 전에, 알아야 할 세 가지 개념을 알려드리겠습니다. AMI(Amazon Machine Image) EC2 인스턴스의 기반이 되는 이미지입니다. 운영체제를 설치하기 위해 CD나 ISO 파일을 만드는 것과 같은 원리입니다. 이것을 이용하여 원하는 운영체제, 환경이 구성된 서버를 설치할 수 있습니다. 즉, 자신이나 타인이 구성한 서버 환경을 이미지 파일로 만들어서 재사용할 수 있습니다. 보안 그룹(Security Group) 보안을 위해 IP와 포트 번호를 이용해 정의하는 서버 접속 규칙입니다. 키 페어(Key pair) 서버에 접속하기 위한 보안키입니다. 서버에는 공개 키(public key)를 두고 사용자는 개인 키(private key)를 들고 접속하게 됩니다. AWS에 로그인하고, AWS 콘솔에 접속하고 서버의 위치를 서울로 설정합니다. 왼쪽 위의 서비스를 눌러 펼치고, EC2를 선택합니다. 왼쪽 [인스턴스] 카테고리의 [인스턴스] 를 선택하고 [인스턴스 시작] 버튼을 클릭합니다. Amazon Linux 2를 선택합니다. CentOS 기반으로 AWS에 적합하게 튜닝한 Linux OS입니다. 프리티어가 사용 가능한 t2.micro를 선택하고, 오른쪽 아래의 [다음: 인스턴스 세부 정보 구성] 을 클릭합니다. 설정은 건드리지 않고 [다음: 스토리지 추가] 를 클릭합니다. 마찬가지로 [다음: 태그 추가] 를 클릭합니다. [다른 태그 추가]를 클릭하고 원하는 키와 값을 입력하고, 다음으로 넘어갑니다. [새 보안 그룹 생성] 을 누른 후 이름과 설명을 지정합니다. 그리고 소스 부분에 드롭다운 메뉴에서 [내 IP] 를 선택합니다. 보통은 회사의 IP를 이용합니다. [검토 및 시작] 을 누르고 [시작] 을 누릅니다. 그 후 [새 키 페어 생성] 을 선택하고 이름을 적고, 키 페어를 다운로드합니다. 이 파일을 이용해야 서버에 접속할 수 있기 때문에 분실되거나 유출되어서는 안됩니다. 전부 다 끝났다면 [인스턴스 시작] 을 누르면 완료입니다. [인스턴스 보기] 를 누르면 인스턴스 상태가 보이고, “실행 중” 이 될 때까지 기다립니다. EC2는 서버가 켜져있는 만큼 비용이 지불되므로, 사용하지 않을때는 꼭 [중지] 합니다. 이는 잠깐 꺼두는 명령이고, [종료] 는 인스턴스를 삭제하는 명령입니다. 단, 서버의 디스크를 점유하고 있기 때문에 해당 사항에 대한 사용료는 지불됩니다. 이제 생성된 인스턴스에 접속하기 위해서는 SSH를 사용해야 하는데, 윈도우에서는 주로 PuTTY를 이용해서 접속하고 macOS나 Linux는 ssh 명령어로 접속합니다. 인스턴스 ID를 클릭하면 세부 정보를 확인할 수 있는데, 여기서 퍼블릭 도메인과 IP는 별도의 설정을 하지 않으면 인스턴스가 꺼질 때 사라지고 켜질 때마다 새로 할당받습니다. 윈도우에서 PuTTY로 SSH 접속하기 이 링크 에서 사용중인 운영체제에 해당하는 파일을 다운로드합니다. PuTTY로 키 파일인 .pem 파일을 바로 사용할 수 없기 때문에 “PuTTY Key Generator”를 이용해서 변환해주어야합니다. “puttygen.exe” 이라는 이름이고, 실행 후 [Load] 를 눌러 .pem 파일을 찾아(안보인다면 확장자 선택을 [All Files (.)] 으로)서 선택합니다. Parameters에서 RSA를 선택하고 Actions에서 Save private key를 선택합니다. 참고로, 여기서 Key passphrase: 와 그 밑의 Confirm passphrase: 는 선택 사항이지만 키가 유출된 경우 비밀번호로 한번 더 보호하는 기능을 합니다. 이제 “putty.exe” 를 실행하고, 카테고리에서 Session을 선택한 후에 “Host Name”에 [ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt;] 를 입력하고, Connection type는 SSH, 포트는 22(SSH의 포트)를 입력합니다. 그리고 왼쪽의 카테고리에서 Connection -&gt; SSH -&gt; Auth 메뉴에서 “Private key file for authentication” 에 아까 변환한 .ppk 파일을 지정하고, 아래의 [Open] 버튼을 누릅니다. 서버의 fingerprint를 레지스트에 키로 등록하겠냐는 경고창이 나오면 [예]를 클릭합니다. 참고) Session 카테고리에서 현재 세션의 정보를 Save해서 더블클릭으로 빠르게 접속할 수 있습니다. macOS/Linux에서 SSH 접속하기 터미널을 실행하고, 다운로드한 키 페어 파일의 권한을 변경합니다. chmod 400 /path/to/&lt;이름&gt;.pem SSH의 접속하기 위해 명령어를 입력합니다. ssh -i /path/to/&lt;이름&gt;.pem ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt; 서버의 fingerprint 값과 함께 접속을 계속하겠냐는 메시지가 나오면 ‘yes’ 를 입력합니다. 위의 모든 과정을 따라하셨다면 EC2 인스턴스의 생성과 접속까지 끝났습니다! AWS를 사용해서 웹 서버, 게임 서버 등 원하는 서버를 쉽고 간편하게 구축해 보세요. 투자 시장의 흐름이나 추세에 따라 거래하는 사람들은 단기간에 수익을 내기 위해 주가의 단기 변동을 예상하려고 노력한다. 하지만 이런 방법으로 수익을 낼 수 있는 사람은 거의 없고, 어느 누구도 아직까지 완벽한 방법을 개발하지 못했다. 시장의 추세를 찾으려고 노력하면 주가가 바닥을 치고 올라가는 시점에서 주식을 팔고 주가가 상승했다가 하락하는 시점에서 주식을 시작하는, 거꾸로 된 투자를 하게 된다 사람들은 자신이 운이 없기 때문에 이런 일이 생긴다고 생각하지만, 사실은 불가능한 일을 하려고 하기 때문이다. 사람들은 또한 폭락이나 조정을 받을 때 주식에 투자하는 것은 위험하다고 생각하는데, 이 시기에 주식을 파는 것이 위험한 행동이다. 이들은 주가가 가파르게 상승하는 얼마 안 되는 짧은 시간에 주식에 투자할 수 있는 기회를 놓치는 위험을 안고 있는 것이다. 주식을 살 때는 해당 기업이 많은 고객을 보유하고 앞으로도 늘어나는지를 보아야 한다. 그러니까, 해당 기업이 좋은 제품을 만드는지를 보아야 한다. 하지만 그 외에도, 자금을 현명하게 사용하는지, 부채의 규모는 어떤지, 매출이 어떤 속도로 증가/감소하고 있는지, 과거와 미래의 수익은 얼마인지, 주식이 어떤 가격에 팔리는지, 배당금은 어느정도인지도 보아야 한다. 수익, 매출, 부채, 배당금은 주식 종목을 선택하는 데 가장 중요한 숫자이다. TDD(테스트주도개발)의 3가지 법칙 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 조합 탐색combinatorial search 동적 계획법과 그리디 기법은 한계가 있기 때문에 결국 완전 탐색으로 풀어야 할 때가 오는데, 이 때 완전 탐색을 최적화하기 위해 완전 탐색을 포함하여 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 “조합 탐색” 이라고 부른다. 이 조합 탐색들은 기본적으로 최적해가 될 가능성이 없는 답의 수를 줄이는 것을 목표로 하고, 이것을 위한 최적화 기법들이 여러가지 있다. 가지치기pruning 탐색 과정에서 최적해로 연결될 가능성이 없는 부분을 잘라낸다. 예를 들어, 탐색들의 최적해를 기억해두고 있을 때 현재 상태의 최적해가 지금까지 구해놓은 최적해보다 좋지 않다면 이 탐색은 더이상 진행하지 않아도 좋다. 휴리스틱heuristic 기준점과 조정 휴리스틱 자신이 알고 있는 수치로 임의의 기준선을 설정한 후, 적절하다고 생각하는 것에 맞게 결정하는것. 가용성 휴리스틱 사건의 가능성을 기억의 가용성에 근거해 추정하는 것. 즉, 기억에서 잘 떠오르는 대상에 대해 상대적으로 높은 평가를 내리는 것 대표성 휴리스틱 어떤 집합에 속하는 임의의 한 특징이 그 집합의 특성을 대표한다고 간주해 빈도와 확률을 판단하는 방법 감정 휴리스틱 어떤 사건이나 상황에 대해 판단을 할 경우 경험으로 형성된 감정에 따라 평가를 다르게 하는 것 메타 휴리스틱 발견법은 해결하려는 문제마다 각기의 특성에 맞추어 개발해야 하는데, 특정 문제가 갖는 정보에 크게 구속되지 않고 다양한 문제들에 적용가능한 상위수준의 발견적 기법이다. 유전 알고리즘, 담금질 기법, 타부 서치가 있다. 드로잉 “캐릭터”를 그린다는 것은 무언가 인물을 그리는 것이 아니라 실제로 의미 그대로 “어떤 성격”을 시각적으로 표현함을 의미한다. 사람의 성격은 너무 복잡하기 때문에 우리 인간은 대상을 관념화해서 “쟤는 소심한 애야, 과격한 애야, 나쁜 애야”라고 단순하게 생각하는데, 이를 그림으로 나타낸 것이 바로 캐릭터이다. 이 캐릭터의 성장기부터 하는 행동을 다 설명할 순 없으니 직관적으로 알아볼 수 있도록 만들어야 하는 것이다. 그림을 그릴땐 모사(모작)부터 시작해야 하는데, 그 이유는 자신의 눈 앞에 있는것도 그릴 수 없는데 자신의 머리속에 있는 것은 그릴 수 없기 때문이다. 모사를 할 때의 방법은 수직/수평선 어딘가에 수직/수평선을 그리면 그곳을 기준으로 어디가 더 들어갔는지, 나와있는지, 비율과 대략적인 위치를 더 정확히 가늠할 수 있기 때문에 유용하게 사용될 수 있다. 가끔 창작물에 나오는 화가가 연필을 세로나 가로로 세워서 보는 것이 이것을 하는 작업이다. 격자 어떤 하나의 큰 그림을 그린다고 할때 이 그림은 한번에 그리는 것이 거의 불가능하니 격자로 부분을 나눠서 부분들을 그리다 보면 전체가 완성되는 것이다. 그래서 모사할 대상과 그릴 그림을 실제로 선으로 된 격자로 나눠 부분을 그리면 더 정확하게 그릴 수 있다. 실루엣 안쪽이 아닌 바깥쪽을 보는 것, 무엇의 윤곽을 보는 것이다. 그러니 그리려는 대상의 전경을 그리는 것이 전체적인 틀을 잡기 더 쉬워진다. 변상증 인간은 의미없는 것에 의미를 부여하기를 좋아한다. 왜냐면 알수 없는 개체가 나타났을 때 우리는 위협에 대비해야 하기 때문이다. 이를 응용하여 그림을 그릴때 부분들이 “무언가를 닮았다” 라고 생각하여 그리다 보면 이 부분들이 모여 하나의 완성된 그림이 된다. 그림을 그릴 때, 특히 사람과 같은 복잡한 것을 그릴때는 그것에 대해 이미 가지고 있는 지식때문에 그림을 그리기가 힘든데, 그래서 대상을 대상으로 바라보지 않는, 그저 빛과 어둠(검고 흰것)으로 이루어진 도형이라고 인식하는 연습이 필요하다. 위의 4가지 방법은 익숙해지면 실제로 수직/수평선을 그리거나 하지 않아도 자연스럽게 머리속에서 그려지게 된다. 참고로 요약자의 경우 1년정도 취미로 모작을 했었는데, 단순 취미의 영역이라면 많이 하면 이 부분은 자연스럽게 가능해질 것이라 생각한다." /><meta property="og:description" content="Informative URLS Refactoring &amp; Design Pattern Website Unreal Engine Multiplayer - Replication Youtube Tiny Facts 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는, 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 상황이 보인다. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 구상한 아이디어로 프로토타입을 작성하여 플레이테스트를 해 보아라. 이 때, 프로토타입은 필수적인 기능만 빠르게 작성하도록 한다. 또한, 반복작업을 통해 개선하라. 프로토타입이 좋다고 해도 이를 바로 최종 결과물로 가능한 작성하지 마라. 프로토타입에서 아이디어가 나오지는 않는다. 이는 단지 어떤 것이 좋은 아이디어인지, 나쁜 아이디어인지 판단을 가능하게 해 준다. 만약 내 게임을 설명할 때 “어떤 게임과 비슷하지만 어떤 스토리와 배경을 가지고 있다” 와 같이 기존 게임의 복제판에 불과한 게임을 만들고 싶지 않다면 자신의 원래 개념으로 돌아가 “이 아이디어에서 특별한 것은 무엇인가?” 라고 묻는 것이다. Personal Studies 인생의 12가지 법칙 - 질서너머 中 기존 제도나 창의적 변화를 함부로 깎아내리지 마라 내가 누구일 수 있는지 상상하고, 그것을 목표로 삼아라 원치 않는 것을 안개 속에 묻어두지 마라 남들이 책임을 방치한 곳에 기회가 숨어 있음을 인식하라 하고 싶지 않은 것을 하지 마라 이데올로기를 버려라 최소한 한 가지 일에 최대한 파고들고, 그 결과를 지켜보라 방 하나를 할 수 있는 한 아름답게 꾸며보라 여전히 나를 괴롭히는 기억이 있다면 아주 자세하게 글로 써보라 관계의 낭만을 유지하기 위해 성실히 계획하고 관리하라 분개하거나 거짓되거나 교만하지 마라 고통스러울지라도 감사하라 여기서 가장 큰 교훈은, 무언가를 평가하기 위해서는 그것에 대해 완전히 이해해야 한다는 점이다. 젊은 혈기에 근거없이 현재의 제도를 비판하지 말고 그 제도의 이유를 먼저 알고, 설득하라. 더 높은 도덕을 위해 법칙을 깨려는 사람은 처음에는 그 법칙을 철저히 익히고 훈련해서 그 필요성을 이해해야 한다. 그리고 법칙의 자구字句 가 아니라 그 정신에 맞게 법칙을 깨야 한다. 반복 설계iterative design 어떤 설계안은 본질적으로 오류가 발생하기 쉬우므로 고치지 말고 버려야 한다, 설계 과정에서 이런 막다른 골목을 예상해야 한다, 막다른 골목에 이르기까디 쏟아 부은 노력은 깔끔하고 산뜻한 새 출발을 위해 치르는 작은 대가에 불과하다. 하지만 많은 관리자들이 그랬다가는 상사와 굉장히 곤란한 정치적 갈등에 빠지리라 생각한다. 이는 장기적으로 돈이 더 들더라도 불량 버전을 수선하는 게 낫다고 생각하는 것과 같다. 무지의 5단계 0단계 무지 - 무지의 부재 (Lack of Ignorance) 무엇을 해야할지, 어떻게 표현할 지 알고 있는 단계 1단계 무지 - 지식의 부재(Lack of Knowledge) 어떻게 해야 할지 모르지만, 하기 위해서 무엇을 배워야 할 지 아는 단계. 2단계 무지 - 지각의 부재(Lack of Awareness) 어떤 것을 모른 다는 것을 모르는 단계. 3단계 무지 - 프로세스의 부재(Lack of Process) 어떤 모르는 것에 대해서 모른 다는 것(2단계 무지)을 알아내기 위한 적당하고 효율적인 방법 모르는 단계 4단계 무지 - 메타 무지 (Meta-Ignorance) 무지의 5단계에 대해서 모르는 단계. 산만의 지속 세대 차이를 뚜렷이 부각하는 요소는 집중이다. 나이 든 사람은 한 번에 한두 가지 일에 집중하는 반면 젊은이들은 온갖 일에 주의를 분산한다. 아이팟으로 음악을 틀어놓고, 끊임없이 문자를 하며, SNS 사이트는 24시간 열어두고, 학교 숙제 도중에 간간히 비디오 게임도 해가며 공부하는 세대를 린다 스톤은 “산만의 지속” 이라고 묘사한다. 젊은 신입은 이런 환경에서 가장 효율적으로 일한다고 말한다. 문제는 산만의 지속이 몰입과는 정확히 반대 상태라는 사실이다. 일을 하는데 몰입이 필수라는 것에 동의한다면, 어느 선에서 주의의 분산을 제지해야 한다. 업무 시간 2%를 한번에 연달아 페이스북에 쏟는 경우와 종일 주의의 2%를 페이스북에 쏟는 경우가 다르다는 사실을 젊은 신입이 이해하게 해야된다. 몰입하지 못해 일에 장애가 생기기 때문이다. 인적 자본 투자 회사가 사람에게 투자하는 돈에 관리자가 바라보는 관점은 중요하다. 인적 자본에는 실체가 있다. 이것을 버리는 돈(경비)로 잘못 생각하면 조직이 투자한 가치를 보존하지 못하는 행동을 관리자가 무심코 저지르게 만들지도 모른다. 물론 ‘조직이 투자한 가치를 보존하지 못하는 행동’은 문제 있는 관리의 전형적인 표본이다. 중간 관리층과 경영진이 장기적인 성장을 희생해 단기적인 성과를 내는(당장의 분기 수익을 높이는)더 나은 방법을 내놓겠다고 서로 경쟁하며 싸운다. 보통은 이것을 “손익 계산만을 문제 삼은 의식”이라 부르지만, 우리는 또 다른 이름인 “종자용 옥수수 먹기” 라 부른다. 잘못된 면접 방식 똑똑한 척하는 면접관을 세운다: 이 면접관은 사사로운 즐거움을 위해 지원자를 힘든 상황으로 몰아붙일것이다. 수수께끼식 질문을 던진다: 비행기에 골프 공이 몇 개나 들어갈까? 구글이 했었던 면접이지만 이제 그 당사자들도 잘못된 것을 깨닫고 이런 질문을 그만둔지 오래이다. 개발능력과 아무 상관이 없다. 답을 모르는 질문을 한다: 면접관으로서 어떤 질문에 어떤 답변이 나와야 하는지 잘 모르겠다면 채용 중인 직무와 관련해서는 그다지 중요한 질문이 아닐 가능성이 높다. 지원자를 바보로 만든다: “내가 질문에 대답을 다 하고, 구현했던 아키텍처에 대해 설명을 요청해 주었을 때 즉시 일어나서 화이트보드에 설명을 했다. 그때 내 직속 상관이 될 면접관이 “너무 단순하네요. 그건 제대로 된 실제 아키텍처가 아닙니다.” 라고 하였다. 그래서 “감사합니다. 이 단순한 아키텍처가 3개 대륙에 걸쳐 2천만 명이 넘는 가입자를 서비스하고 있습니다. 간단한 시스템으로 해냈다는 것을 기쁘게 생각합니다.” 라고 말했고, 면접 기회를 준 것에 감사를 표하고 자리를 떠났다. 인터넷 접속을 막는다: 코딩 면접을 할 때 진짜 코딩 실력을 알겠다는 이유로 이러는 것은 말도 안된다. 솔루션 탐색 능력 또한 지원자에게 필요한 능력이며, 인터넷 검색때문에 코딩 면접이 변별력을 잃을 수 있다면 면접 과제 자체에 문제가 있는 것이다. 종이에 코드를 작성하게 한다: 우리는 학교처럼 의사 코드로 평가하는 것이 아니다. 실제도구를 이용해서 생산된 실제 코드를 평가해야 한다. 알고리즘 문제를 낸다: 시스템 개발에 필요한 상당수의 업무들이 알고리즘에 대한 깊은 이해를 필요로 하지 않는다. “지원자의 문제 해결 능력을 보아야 한다.” 라는 이유인데, 맞는 말이지만 회사의 실제 프로젝트와 가까운 다른 연습문제를 통해서도 이를 평가할 수 있다. 여러 시스템의 문제는 테스트가 부족하거나, 잘못된 설계, 떨어지는 응집성, 깊은 종속성, 새 기능 추가 시 부족한 리팩토링, 지속적인 요구사항 변경, 도메인 모델이 정교하지 못했다는 것들 등이 흔한 문제이다. 알고리즘은 절차적이고 함수적이며, 구현할 때 비즈니스 도메인 모델이나 클래스를 만들지는 않는다. 문제의 요지는, 회사에 필요한 개발능력을 평가해야한다. 알고리즘이 필요한거라면 알고리즘을, TDD(테스트주도개발)능력이 필요한거라면 그에 걸맞는 코딩 문제를 재시해야한다. 전화 면접을 한다: 시간이 부족할때만 해라. 딱딱하게 진행될 가능성이 높다. 잘못된 채용 공고 로 애들러Lou Adler “ 기술과 경험을 나열하는 전통적인 직무 요건은 재능에도 반하고, 다양성에도 반하며, 성공적인 채용과의 상관관계도 최악이다 “ 절대적인 숫자 숫자는 임의적이고 오해하기 쉬우며 변덕스럽다. 5년 간의 자바 경력… 얼마 이상의 대학 학점… 과 같은것은 후보자를 제대로 선별하는 데 별 도움이 안된다. 채용된 후에 새로운 기술 학습 없이 같은 기술만으로 오래 일하는 개발자들이 많고, 이는 매년 새로운 기술을 익힌 개발자에 비해 1/5의 가치를 지니고 있다고 할 수도 있다. 키워드 매칭 채용 담당자들은 특정 기술이나 플랫폼에 대한 약어들을 선호하지 않는다. 채용 담당자는 해당 업무의 본질적인 부분을 잘 모르기 때문에 선무당에게 굿을 맡기는 결과가 된다. 기술 목록의 나열 불필요하게 너무 많은 기술 목록을 나열하면 재능있고 정직한 개발자가 스스로 지원을 포기하게 만들 수 있다. 보통 더 나은 개발잘르 선별하려는 욕심에 필요한 기술에 희망 기술까지 더해지기 일쑤다. 이는 후보군만 줄이는 행동이며 실제 그 업무를 잘하기 위한 것과 전혀 관계가 없다. 잘못된 기업 문화 설명 기업의 가치와 기대되는 태도, 책임을 채용 공고에 잘못 설명하는 경우가 많다. 팀워크, 긍정적 태도, 열정, 지혜로움과 같은 단어들을 나열하지 않도록 한다. 이러한 것들 중 어느 하나라도 자신이 해당하지 않는다고 스스로를 배제하는 지원자는 없다. 잘못된 요구 항목 더 훌륭한 개발자를 유인하기 위해서는 기술, 경력 년수, 일한 산업군, 출신 학교, 학점보다 그 직무에서 무엇을 책임져야 하는지 설명하는 것이 훨씬 낫다. 위에 나열된 항목들은 실제 역량과 전혀 일치하지 않는다. 잘못된 선별 조건 직무 요건들은 최고의 인재를 얻기 위함이 아닌 아닌 최악의 인재들을 걸러내기 위한 목적으로 설계되어 있다. 최고의 개발자들은 특정 기술의 사용 유무보다 회사의 문화, 업무에서의 책임, 프로젝트의 종류를 훨씬 더 중요하게 여긴다. 승진 요건과의 불일치 승진심사 때, 특정 프레임워크의 API를 알고있거나 자바 경력이 몇년 이상이라서 승진하지 않고, 그가 이룬 성과와 리더십, 팀워크와 같은 다른 중요한 이유로 승진을 한다. 채용 공고의 직무 요건이 이러한 승진 요건과 합치되는 부분이 없다면 그 직무 요건으로 필터링된 사람들이 회사 안에서 좋은 성과를 낼 거라는 기대 자체가 모순이다. 단순한 설계를 위한 네 가지 원칙 모든 테스트의 통과 중복의 최소화 : 동작/설정에 중복이 있으면 안된다. 명료성의 최대화 : 명료하고, 충분히 표현되고, 일관되어야 한다. 구성요소의 최소화 : 메서드, 클래스, 모듈의 수는 가능한 적어야 한다. 오디션 개최 (in “Peopleware”) 우리가 몸담은 업계는 기술적이보다는 사회적이다. 직원-기계의 소통 능력보다 서로와 소통하는 능력이 더 주요하다. 그러므로 직원 채용 절차는 최소한 사회적이고 인간적인 의사소통 역량에 초점을 맞춰야 하며, 이 책의 저자가 발견한 최선의 방법은 후보자에 대한 오디션이다. 개념은 간단하다. 과거에 자신이 수행한 업무와 관련해 10분에서 15분정도 프레젠테이션을 시킨다. 생전 처음 써봤던 새 기술/경험일 수도 있고, 힙겹게 깨우친 관리 경험일 수도 있고, 아주 재미있었던 프로젝트일 수도 있다. 주제는 지원자가 선택하고, 발표일을 정해 지원자와 함께 일할 사람들로 소규모 청중을 구성한다. 물론 지원자는 긴장하고, 안 하려고 들지도 모른다. 누구나 긴장하기 마련이라고 말해주라. 오디션을 여는 이유도 설명하라. 다양한 지원자들의 의사소통 능력을 보고, 미래 동료 직원들을 채용 과정에 참여시키려는 의도라 설명한다. 오디션을 마치고 지원자가 떠난 다음 참석자들과 간단히 후기를 나눈다. 각 참석자가 돌아가며 지원자가 업무에 적합한지, 그리고 팀과 잘 어울릴지 의견을 말한다. 물론 최종적인 결정은 관리자에게 달렸지만 미래 동료 직원들이 내놓는 의견은 굉장히 소중한다. 게다가 이렇게 고용한 신입 직원은 팀도 무리 없이 받아들인다. 팀원들이 뽑자 햇기 때문이다. ” 오디션을 열면 신입 직원과 기존 직원들이 더 빨리 친해진다. 성공적인 오디션은 동료들로부터 받는 일종의 인증이었고, 반대의 경우도 역시 일종의 인증이었다. 실패한 오디션 후에는 직원들의 사기가 확 올라갔다. 자신을 채용한 이유가 하필 그 때 관리자의 책상에 이력서가 놓여 있었던 뜻밖의 행운 때문이 아니라는 사실을 지속적으로 보여주는 증거이기 때문이다. “ 오디션을 열 대는 한 가지 주의할 사항이 있다. 지원자는 회사가 하는 일과 직접 관련 있는 주제를 다뤄야 한다. “랭커 찍은 게임” 이나 “정원 가꾸기” 등 극단적인 주제라면 지원자는 굉장한 열정으로 발표하겠지만, 직장에서는 그런 열정을 못 볼지도 모른다. 베테랑 프로그래머와 대규모 프로젝트 뛰어난 프로그래머들과 좀 처지는 이들 간에는 상당한 생산성 차이가 있고, 이를 대부분의 관리자는 알고 있지만 정확히 수치적으로 나타낸다면 가장 뛰어난 사람과 가장 못한 사람의 생산성 비율이 평균 10:1이나 되고, 실행 속도와 사용 공간 면에서는 다섯 배의 차이가 난다. 간단히 말해, 연복 2만 달러를 받는 프로그래머가 1만 달러를 받는 이에 비해 열 배의 생산성을 발휘할 수 있다는 뜻이며, 물론 그 반대 또한 가능하다. 이 연구의 데이터에서는 경력 연차와 성과 사이에 어떠한 상관 관계도 없었는데, 이는 경험을 하며 실제로 공부하고, 배워서 자신을 발전시키는지 아닌지에 대한 차이인 것 같다. 서로 소통해야 하는 사람 수가 전체 비용에 영향을 미친다. 사람이 많을수록 커뮤니케이션 부담은 N(N-1)/2 배가 되며 어느 순간 인력(맨-먼스, Man-Month) 을 투입해서 얻는 이익보다 손실이 더 많아질 지경에 이르게 될 수 있다. 이것은 비용의 대부분이 커뮤니케이션, 그리고 잘못된 커뮤니케이션의 부작용을 바로잡는 데 소요되기 때문이다. 이는 가능하면 적은 수의 사람들에 의해 시스템이 만들어는 편이 낫다는 것을 시사한다. 개념적 일관성이 부족한 결과물을 만들어 내기 때문이기도 하다. 보통 프로그래머 수백 명이 투입된 프로젝트보다 일급 멤버들로 구성된 작고 예리한 팀이 낫다고 하는데, 그 말 아래에는 앞의 수백 명은 평범하다는 뜻이 깔려 있다. 하지만 이는 “어떻게 해야 ‘큰’ 시스템을 의미 있는 일정 내에 만들어 낼 수 있는가?” 라는 어려운 질문을 회피하는 것을 뜻한다. 예를 들어보자. 200명이 투입된 프로젝트 내에 관리자이면서 가장 유능하고 경험 많은 프로그래머가 25명이 있다면, 나머지 175명은 해고하고 그 관리자들을 다시 프로그래밍에 투입하는 것이다. 하지만 이는 작은 팀은 아닌데, 보통 작은 팀이라면 10명 이하를 뜻하기 때문이다. 25명이면 최소 두 단계로 관리가 이루어지거나 5명의 관리자를 두어야 하는 규모이다. 이 팀에는 재무, 인사, 사무 공간, 비서 업무, 장비 운영에 추가 지원도 필요할 것이다. 하지만 다른 한편으로, 200명인 원래 팀은 정말로 큰 시스템을 주먹구구식으로 만들기에 충분한 규모가 아니다. OS/360의 개발에는 프로젝트에 1000명 넘게 투입되었고, 1963~1966년까지 이 시스템의 설계-구축-문서화에 들어간 공수는 대략 5000맨이어(Man-Year) 정도였다. 밀스Mills의 제안 커다란 전체 업무를 여러 팀에 나눠서 맡기되, 각 팀을 외과 수술 팀처럼 조직할 것의 제안이다. 즉, 모든 팀원이 다 같이 문제에 달려드는 것이 아니라, 한 명이 문제를 해결해 가는 동안 다른 이들은 그 사람이 효율과 생산성을 높일 수 있도록 여러 방면에서 지원해 주는 것이다. 이는 사실 현재로썬 당연한데(이 책은 1975년에 1판, 1995년에 2판이 나왔다), 설계와 구축에는 적은 수의 사람이 개입하면서, 작업에는 여러 사람이 개입한다. 외과의: 수석 프로그래머. 이 사람은 기능과 성능 명세를 직접 정의하며, 프로그램을 설계/코딩/테스트/문서화 한다. 그리고 전체 시스템에 실질적인 접속 권한을 가지고 있으며, 뛰어난 재능과 10년 이상의 경력, 시스템 및 응용 분야에 관한 상당 수준의 지식이 요구된다. 그 분야는 응용 수학이나 비즈니스 데이터 처리 등 무엇이나 될 수 있다. 부조종사: 외과의의 분신. 업무의 어떤 부분이든 수행 가능하지만 경험은 많지 않으며, 주된 역할은 설계 과정에 참여하여 같이 고민-토론-평가 하는 것이다. 외과의가 부조종사와 여러 아이디어를 시도할 수는 있지만, 부조종사의 의견에 구애받지는 않는다. 모든 코드를 상세하게 알고 있고, 대안적인 설계에 대한 전략을 연구하며 종종 팀을 대표한다. 행정 담당: 외과의는 인사, 임금 등의 최종 결정권이 있지만 이 부분에 시간을 할애해서는 안된다. 그러므로 돈, 사람, 공간, 장비를 관장하고 다른 부서의 행정 파트와 소통을 맡아줄 전문적인 행정 담당이 필요하다. 어떤 프로젝트에 법률적 계약적 중대 사안이 있거나, 보고를 강화해야하거나, 재무적 이슈가 있지 않다면 보통 한 명의 행정 담당이 두 팀을 맡을 수 있다. 편집자: 문서 생산은 최대한의 명확성을 위해 외과의가 직접 작성해야 한다. 외부/내부 문서에 동일하게 적용되지만, 외과의가 작성한 초안/구술 원고를 읽은 후에 그것을 비평/재작업/레퍼런스 보충/버전 관리/문서 생산 관리는 편집자가 담당해야 한다. 두 명의 비서: 행정 담당과 편집자는 비서가 한 명씩 필요하며, 행정 비서는 프로젝트 관련 우편물/일반적인 업무 서류를 관리한다. 프로그램 사무원: 이 사람은 팀에서 생산되는 모든 기술적인 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 컴퓨터에서 작업이 실행되는 전 과정을 팀의 멤버 누구나 볼 수 있게 하고, 프로그래밍이라는 작업을 “개인적인 예술에서 공개적인 실행으로” 바꾼다. 이 작업은 현대에서는 소스 컨트롤과 CI/CD라는 작업이 도맡아서 한다. 도구 담당: 여러 편집기, 서비스 중 확실히 신뢰할 수 있고 팀에 적합한 도구를 찾고, 이들을 구축-유지-업그레이드 하는 책임을 받는다. 종종 특화된 유틸리티/목록으로 정리된 프로시저/매크로 라이브러리 등을 구축하기도 한다. 테스터: 테스트 케이서를 만들고, 테스트 순서를 계획하고, 구성 요소 테스트를 위한 Scaffolding을 짠다. 이는 현대에 들어서 TDD(테스트 주도 개발) 과 같은 형태로 바뀌어 모든 프로그래머가 테스트를 작성하게 하기도 한다. 언어 전문가 책에서는 특정 언어를 마스터한 사람을 일컫지만, 알고리즘 전문가 또한 이곳에 포함될 수 있다고 생각한다. 즉, 특정 언어나 기술의 수학적이고 복잡한 부분을 잘 다루는 사람을 뜻한다. 대개 2명~3명의 외과의를 도울 수 있다. 한가지 경고할 점은, 이는 1975년도에 쓰여진 책이고 지금은 이런 내용들이 당연시 여겨지고 있으며 몇몇은 시대를 많이 지났다는 것이다. 하지만 그렇기에 교과서적인 기초와 개발체제의 탄생 배경을 알 수 있기에 참고해볼 만한 가치가 있다. 명세서 잘 짜여진 명세서는 [완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성] 이 있어야 한다. 완전성completeness 사용자의 모든 요구 사항이 누락되지 않고 완전하게 반영되었는가? 일관성consistency 요구 사항이 서로 모순/충돌되는 점은 없고, 산출물이나 요구사항의 내용이 일관성을 유지하는가? 명확성unambiguity 서술된 명세서의 내용이 애매하지 않고 모든 참여자가 명확히 이해 가능한가? 기능성functionality 서술된 명세서의 내용이 ‘어떻게’보다 ‘무엇을’에 관점을 두고 서술되었는가? 검증 가능성verifiability 서술된 명세서의 내용이 사용자의 요구를 만족하는지 검증할 수 있는가? 추적 가능성traceability 사용자 요구 분석 명세서와 설계 사양서를 추적할 수 있는가? 변경 용이성easily changeable 요구 분석 명세서의 내용을 변경하고자 할 때 쉽게 찾아 변경할 수 있는가? AWS EC2 서버 구축하기 운영 서버란? 개발이나 테스트 목적이 아닌, 실제 사용자들을 대상으로 서비스하는 서버를 말합니다. 테스트 할 때와는 다르게 트래픽 대응과 빠른 응답속도, 그리고 높은 가용성을 고려해야 합니다. 운영 서버 관리법은 크게 ‘환경 구성’, ‘코드 배포’, ‘모니터링’의 세 단계로 나뉩니다. ‘환경 구성’은 서비스할 코드를 구동시킬 수 있는 서버 인프라를 구축하는 것이고, ‘코드 배포’는 구성한 환경에 최신 버전의 코드를 빠르고 안전하게 배포하는 것이고, 마지막으로 ‘모니터링’은 안정적인 서비스 운영을 위해 서버와 코드에 어떤 이상이 없는지 바로 파악하고 대응할 수 있게 도와주는 것입니다. AWS(Amazon Web Services) 란? 미국의 대형 인터넷 쇼핑몰인 아마존(Amazon)에서 자사를 위해 개발하였던 인프라 시스템인데, 이 기술을 2006년에 공개하며 서비스하기 시작해서 만들어졌습니다. 컴퓨팅 서버를 클라우드로 제공하여서 원래는 물리적인 기계를 구매하여 배치하고, 구축하고, 작동해야 했기 때문에 전문 인력들이 필요했고, 서버의 상태가 어떻게 될 지 확실하지 않기 때문에 필요 이상의 규모를 구축해야 하지만, AWS와 같은 클라우드 서비스를 이용하면 몇번의 클릭만으로 가용량을 조정할 수 있습니다. 그래서 비용, 시간, 인력적인 면에서 많은 비용 절감이 가능하게 되죠. AWS EC2 인스턴스 생성하기 EC2(Elastic Compute Cloud)는 사양을 고르고 원하는 시간만큼 사용 가능한 가상 서버입니다. 필요할 때마다 키거나 끌 수 있고, 사용한 시간에 대해서만 비용을 지급합니다. 시작하기 전에, 알아야 할 세 가지 개념을 알려드리겠습니다. AMI(Amazon Machine Image) EC2 인스턴스의 기반이 되는 이미지입니다. 운영체제를 설치하기 위해 CD나 ISO 파일을 만드는 것과 같은 원리입니다. 이것을 이용하여 원하는 운영체제, 환경이 구성된 서버를 설치할 수 있습니다. 즉, 자신이나 타인이 구성한 서버 환경을 이미지 파일로 만들어서 재사용할 수 있습니다. 보안 그룹(Security Group) 보안을 위해 IP와 포트 번호를 이용해 정의하는 서버 접속 규칙입니다. 키 페어(Key pair) 서버에 접속하기 위한 보안키입니다. 서버에는 공개 키(public key)를 두고 사용자는 개인 키(private key)를 들고 접속하게 됩니다. AWS에 로그인하고, AWS 콘솔에 접속하고 서버의 위치를 서울로 설정합니다. 왼쪽 위의 서비스를 눌러 펼치고, EC2를 선택합니다. 왼쪽 [인스턴스] 카테고리의 [인스턴스] 를 선택하고 [인스턴스 시작] 버튼을 클릭합니다. Amazon Linux 2를 선택합니다. CentOS 기반으로 AWS에 적합하게 튜닝한 Linux OS입니다. 프리티어가 사용 가능한 t2.micro를 선택하고, 오른쪽 아래의 [다음: 인스턴스 세부 정보 구성] 을 클릭합니다. 설정은 건드리지 않고 [다음: 스토리지 추가] 를 클릭합니다. 마찬가지로 [다음: 태그 추가] 를 클릭합니다. [다른 태그 추가]를 클릭하고 원하는 키와 값을 입력하고, 다음으로 넘어갑니다. [새 보안 그룹 생성] 을 누른 후 이름과 설명을 지정합니다. 그리고 소스 부분에 드롭다운 메뉴에서 [내 IP] 를 선택합니다. 보통은 회사의 IP를 이용합니다. [검토 및 시작] 을 누르고 [시작] 을 누릅니다. 그 후 [새 키 페어 생성] 을 선택하고 이름을 적고, 키 페어를 다운로드합니다. 이 파일을 이용해야 서버에 접속할 수 있기 때문에 분실되거나 유출되어서는 안됩니다. 전부 다 끝났다면 [인스턴스 시작] 을 누르면 완료입니다. [인스턴스 보기] 를 누르면 인스턴스 상태가 보이고, “실행 중” 이 될 때까지 기다립니다. EC2는 서버가 켜져있는 만큼 비용이 지불되므로, 사용하지 않을때는 꼭 [중지] 합니다. 이는 잠깐 꺼두는 명령이고, [종료] 는 인스턴스를 삭제하는 명령입니다. 단, 서버의 디스크를 점유하고 있기 때문에 해당 사항에 대한 사용료는 지불됩니다. 이제 생성된 인스턴스에 접속하기 위해서는 SSH를 사용해야 하는데, 윈도우에서는 주로 PuTTY를 이용해서 접속하고 macOS나 Linux는 ssh 명령어로 접속합니다. 인스턴스 ID를 클릭하면 세부 정보를 확인할 수 있는데, 여기서 퍼블릭 도메인과 IP는 별도의 설정을 하지 않으면 인스턴스가 꺼질 때 사라지고 켜질 때마다 새로 할당받습니다. 윈도우에서 PuTTY로 SSH 접속하기 이 링크 에서 사용중인 운영체제에 해당하는 파일을 다운로드합니다. PuTTY로 키 파일인 .pem 파일을 바로 사용할 수 없기 때문에 “PuTTY Key Generator”를 이용해서 변환해주어야합니다. “puttygen.exe” 이라는 이름이고, 실행 후 [Load] 를 눌러 .pem 파일을 찾아(안보인다면 확장자 선택을 [All Files (.)] 으로)서 선택합니다. Parameters에서 RSA를 선택하고 Actions에서 Save private key를 선택합니다. 참고로, 여기서 Key passphrase: 와 그 밑의 Confirm passphrase: 는 선택 사항이지만 키가 유출된 경우 비밀번호로 한번 더 보호하는 기능을 합니다. 이제 “putty.exe” 를 실행하고, 카테고리에서 Session을 선택한 후에 “Host Name”에 [ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt;] 를 입력하고, Connection type는 SSH, 포트는 22(SSH의 포트)를 입력합니다. 그리고 왼쪽의 카테고리에서 Connection -&gt; SSH -&gt; Auth 메뉴에서 “Private key file for authentication” 에 아까 변환한 .ppk 파일을 지정하고, 아래의 [Open] 버튼을 누릅니다. 서버의 fingerprint를 레지스트에 키로 등록하겠냐는 경고창이 나오면 [예]를 클릭합니다. 참고) Session 카테고리에서 현재 세션의 정보를 Save해서 더블클릭으로 빠르게 접속할 수 있습니다. macOS/Linux에서 SSH 접속하기 터미널을 실행하고, 다운로드한 키 페어 파일의 권한을 변경합니다. chmod 400 /path/to/&lt;이름&gt;.pem SSH의 접속하기 위해 명령어를 입력합니다. ssh -i /path/to/&lt;이름&gt;.pem ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt; 서버의 fingerprint 값과 함께 접속을 계속하겠냐는 메시지가 나오면 ‘yes’ 를 입력합니다. 위의 모든 과정을 따라하셨다면 EC2 인스턴스의 생성과 접속까지 끝났습니다! AWS를 사용해서 웹 서버, 게임 서버 등 원하는 서버를 쉽고 간편하게 구축해 보세요. 투자 시장의 흐름이나 추세에 따라 거래하는 사람들은 단기간에 수익을 내기 위해 주가의 단기 변동을 예상하려고 노력한다. 하지만 이런 방법으로 수익을 낼 수 있는 사람은 거의 없고, 어느 누구도 아직까지 완벽한 방법을 개발하지 못했다. 시장의 추세를 찾으려고 노력하면 주가가 바닥을 치고 올라가는 시점에서 주식을 팔고 주가가 상승했다가 하락하는 시점에서 주식을 시작하는, 거꾸로 된 투자를 하게 된다 사람들은 자신이 운이 없기 때문에 이런 일이 생긴다고 생각하지만, 사실은 불가능한 일을 하려고 하기 때문이다. 사람들은 또한 폭락이나 조정을 받을 때 주식에 투자하는 것은 위험하다고 생각하는데, 이 시기에 주식을 파는 것이 위험한 행동이다. 이들은 주가가 가파르게 상승하는 얼마 안 되는 짧은 시간에 주식에 투자할 수 있는 기회를 놓치는 위험을 안고 있는 것이다. 주식을 살 때는 해당 기업이 많은 고객을 보유하고 앞으로도 늘어나는지를 보아야 한다. 그러니까, 해당 기업이 좋은 제품을 만드는지를 보아야 한다. 하지만 그 외에도, 자금을 현명하게 사용하는지, 부채의 규모는 어떤지, 매출이 어떤 속도로 증가/감소하고 있는지, 과거와 미래의 수익은 얼마인지, 주식이 어떤 가격에 팔리는지, 배당금은 어느정도인지도 보아야 한다. 수익, 매출, 부채, 배당금은 주식 종목을 선택하는 데 가장 중요한 숫자이다. TDD(테스트주도개발)의 3가지 법칙 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 조합 탐색combinatorial search 동적 계획법과 그리디 기법은 한계가 있기 때문에 결국 완전 탐색으로 풀어야 할 때가 오는데, 이 때 완전 탐색을 최적화하기 위해 완전 탐색을 포함하여 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 “조합 탐색” 이라고 부른다. 이 조합 탐색들은 기본적으로 최적해가 될 가능성이 없는 답의 수를 줄이는 것을 목표로 하고, 이것을 위한 최적화 기법들이 여러가지 있다. 가지치기pruning 탐색 과정에서 최적해로 연결될 가능성이 없는 부분을 잘라낸다. 예를 들어, 탐색들의 최적해를 기억해두고 있을 때 현재 상태의 최적해가 지금까지 구해놓은 최적해보다 좋지 않다면 이 탐색은 더이상 진행하지 않아도 좋다. 휴리스틱heuristic 기준점과 조정 휴리스틱 자신이 알고 있는 수치로 임의의 기준선을 설정한 후, 적절하다고 생각하는 것에 맞게 결정하는것. 가용성 휴리스틱 사건의 가능성을 기억의 가용성에 근거해 추정하는 것. 즉, 기억에서 잘 떠오르는 대상에 대해 상대적으로 높은 평가를 내리는 것 대표성 휴리스틱 어떤 집합에 속하는 임의의 한 특징이 그 집합의 특성을 대표한다고 간주해 빈도와 확률을 판단하는 방법 감정 휴리스틱 어떤 사건이나 상황에 대해 판단을 할 경우 경험으로 형성된 감정에 따라 평가를 다르게 하는 것 메타 휴리스틱 발견법은 해결하려는 문제마다 각기의 특성에 맞추어 개발해야 하는데, 특정 문제가 갖는 정보에 크게 구속되지 않고 다양한 문제들에 적용가능한 상위수준의 발견적 기법이다. 유전 알고리즘, 담금질 기법, 타부 서치가 있다. 드로잉 “캐릭터”를 그린다는 것은 무언가 인물을 그리는 것이 아니라 실제로 의미 그대로 “어떤 성격”을 시각적으로 표현함을 의미한다. 사람의 성격은 너무 복잡하기 때문에 우리 인간은 대상을 관념화해서 “쟤는 소심한 애야, 과격한 애야, 나쁜 애야”라고 단순하게 생각하는데, 이를 그림으로 나타낸 것이 바로 캐릭터이다. 이 캐릭터의 성장기부터 하는 행동을 다 설명할 순 없으니 직관적으로 알아볼 수 있도록 만들어야 하는 것이다. 그림을 그릴땐 모사(모작)부터 시작해야 하는데, 그 이유는 자신의 눈 앞에 있는것도 그릴 수 없는데 자신의 머리속에 있는 것은 그릴 수 없기 때문이다. 모사를 할 때의 방법은 수직/수평선 어딘가에 수직/수평선을 그리면 그곳을 기준으로 어디가 더 들어갔는지, 나와있는지, 비율과 대략적인 위치를 더 정확히 가늠할 수 있기 때문에 유용하게 사용될 수 있다. 가끔 창작물에 나오는 화가가 연필을 세로나 가로로 세워서 보는 것이 이것을 하는 작업이다. 격자 어떤 하나의 큰 그림을 그린다고 할때 이 그림은 한번에 그리는 것이 거의 불가능하니 격자로 부분을 나눠서 부분들을 그리다 보면 전체가 완성되는 것이다. 그래서 모사할 대상과 그릴 그림을 실제로 선으로 된 격자로 나눠 부분을 그리면 더 정확하게 그릴 수 있다. 실루엣 안쪽이 아닌 바깥쪽을 보는 것, 무엇의 윤곽을 보는 것이다. 그러니 그리려는 대상의 전경을 그리는 것이 전체적인 틀을 잡기 더 쉬워진다. 변상증 인간은 의미없는 것에 의미를 부여하기를 좋아한다. 왜냐면 알수 없는 개체가 나타났을 때 우리는 위협에 대비해야 하기 때문이다. 이를 응용하여 그림을 그릴때 부분들이 “무언가를 닮았다” 라고 생각하여 그리다 보면 이 부분들이 모여 하나의 완성된 그림이 된다. 그림을 그릴 때, 특히 사람과 같은 복잡한 것을 그릴때는 그것에 대해 이미 가지고 있는 지식때문에 그림을 그리기가 힘든데, 그래서 대상을 대상으로 바라보지 않는, 그저 빛과 어둠(검고 흰것)으로 이루어진 도형이라고 인식하는 연습이 필요하다. 위의 4가지 방법은 익숙해지면 실제로 수직/수평선을 그리거나 하지 않아도 자연스럽게 머리속에서 그려지게 된다. 참고로 요약자의 경우 1년정도 취미로 모작을 했었는데, 단순 취미의 영역이라면 많이 하면 이 부분은 자연스럽게 가능해질 것이라 생각한다." /><link rel="canonical" href="https://termsigening97.github.io/posts/Scraps/" /><meta property="og:url" content="https://termsigening97.github.io/posts/Scraps/" /><meta property="og:site_name" content="Sigening" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-12T13:30:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="지식 스크랩" /><meta name="twitter:site" content="@termsigening97" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-12T14:00:33+09:00","datePublished":"2022-05-12T13:30:00+09:00","description":"Informative URLS Refactoring &amp; Design Pattern Website Unreal Engine Multiplayer - Replication Youtube Tiny Facts 깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는, 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 상황이 보인다. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. 구상한 아이디어로 프로토타입을 작성하여 플레이테스트를 해 보아라. 이 때, 프로토타입은 필수적인 기능만 빠르게 작성하도록 한다. 또한, 반복작업을 통해 개선하라. 프로토타입이 좋다고 해도 이를 바로 최종 결과물로 가능한 작성하지 마라. 프로토타입에서 아이디어가 나오지는 않는다. 이는 단지 어떤 것이 좋은 아이디어인지, 나쁜 아이디어인지 판단을 가능하게 해 준다. 만약 내 게임을 설명할 때 “어떤 게임과 비슷하지만 어떤 스토리와 배경을 가지고 있다” 와 같이 기존 게임의 복제판에 불과한 게임을 만들고 싶지 않다면 자신의 원래 개념으로 돌아가 “이 아이디어에서 특별한 것은 무엇인가?” 라고 묻는 것이다. Personal Studies 인생의 12가지 법칙 - 질서너머 中 기존 제도나 창의적 변화를 함부로 깎아내리지 마라 내가 누구일 수 있는지 상상하고, 그것을 목표로 삼아라 원치 않는 것을 안개 속에 묻어두지 마라 남들이 책임을 방치한 곳에 기회가 숨어 있음을 인식하라 하고 싶지 않은 것을 하지 마라 이데올로기를 버려라 최소한 한 가지 일에 최대한 파고들고, 그 결과를 지켜보라 방 하나를 할 수 있는 한 아름답게 꾸며보라 여전히 나를 괴롭히는 기억이 있다면 아주 자세하게 글로 써보라 관계의 낭만을 유지하기 위해 성실히 계획하고 관리하라 분개하거나 거짓되거나 교만하지 마라 고통스러울지라도 감사하라 여기서 가장 큰 교훈은, 무언가를 평가하기 위해서는 그것에 대해 완전히 이해해야 한다는 점이다. 젊은 혈기에 근거없이 현재의 제도를 비판하지 말고 그 제도의 이유를 먼저 알고, 설득하라. 더 높은 도덕을 위해 법칙을 깨려는 사람은 처음에는 그 법칙을 철저히 익히고 훈련해서 그 필요성을 이해해야 한다. 그리고 법칙의 자구字句 가 아니라 그 정신에 맞게 법칙을 깨야 한다. 반복 설계iterative design 어떤 설계안은 본질적으로 오류가 발생하기 쉬우므로 고치지 말고 버려야 한다, 설계 과정에서 이런 막다른 골목을 예상해야 한다, 막다른 골목에 이르기까디 쏟아 부은 노력은 깔끔하고 산뜻한 새 출발을 위해 치르는 작은 대가에 불과하다. 하지만 많은 관리자들이 그랬다가는 상사와 굉장히 곤란한 정치적 갈등에 빠지리라 생각한다. 이는 장기적으로 돈이 더 들더라도 불량 버전을 수선하는 게 낫다고 생각하는 것과 같다. 무지의 5단계 0단계 무지 - 무지의 부재 (Lack of Ignorance) 무엇을 해야할지, 어떻게 표현할 지 알고 있는 단계 1단계 무지 - 지식의 부재(Lack of Knowledge) 어떻게 해야 할지 모르지만, 하기 위해서 무엇을 배워야 할 지 아는 단계. 2단계 무지 - 지각의 부재(Lack of Awareness) 어떤 것을 모른 다는 것을 모르는 단계. 3단계 무지 - 프로세스의 부재(Lack of Process) 어떤 모르는 것에 대해서 모른 다는 것(2단계 무지)을 알아내기 위한 적당하고 효율적인 방법 모르는 단계 4단계 무지 - 메타 무지 (Meta-Ignorance) 무지의 5단계에 대해서 모르는 단계. 산만의 지속 세대 차이를 뚜렷이 부각하는 요소는 집중이다. 나이 든 사람은 한 번에 한두 가지 일에 집중하는 반면 젊은이들은 온갖 일에 주의를 분산한다. 아이팟으로 음악을 틀어놓고, 끊임없이 문자를 하며, SNS 사이트는 24시간 열어두고, 학교 숙제 도중에 간간히 비디오 게임도 해가며 공부하는 세대를 린다 스톤은 “산만의 지속” 이라고 묘사한다. 젊은 신입은 이런 환경에서 가장 효율적으로 일한다고 말한다. 문제는 산만의 지속이 몰입과는 정확히 반대 상태라는 사실이다. 일을 하는데 몰입이 필수라는 것에 동의한다면, 어느 선에서 주의의 분산을 제지해야 한다. 업무 시간 2%를 한번에 연달아 페이스북에 쏟는 경우와 종일 주의의 2%를 페이스북에 쏟는 경우가 다르다는 사실을 젊은 신입이 이해하게 해야된다. 몰입하지 못해 일에 장애가 생기기 때문이다. 인적 자본 투자 회사가 사람에게 투자하는 돈에 관리자가 바라보는 관점은 중요하다. 인적 자본에는 실체가 있다. 이것을 버리는 돈(경비)로 잘못 생각하면 조직이 투자한 가치를 보존하지 못하는 행동을 관리자가 무심코 저지르게 만들지도 모른다. 물론 ‘조직이 투자한 가치를 보존하지 못하는 행동’은 문제 있는 관리의 전형적인 표본이다. 중간 관리층과 경영진이 장기적인 성장을 희생해 단기적인 성과를 내는(당장의 분기 수익을 높이는)더 나은 방법을 내놓겠다고 서로 경쟁하며 싸운다. 보통은 이것을 “손익 계산만을 문제 삼은 의식”이라 부르지만, 우리는 또 다른 이름인 “종자용 옥수수 먹기” 라 부른다. 잘못된 면접 방식 똑똑한 척하는 면접관을 세운다: 이 면접관은 사사로운 즐거움을 위해 지원자를 힘든 상황으로 몰아붙일것이다. 수수께끼식 질문을 던진다: 비행기에 골프 공이 몇 개나 들어갈까? 구글이 했었던 면접이지만 이제 그 당사자들도 잘못된 것을 깨닫고 이런 질문을 그만둔지 오래이다. 개발능력과 아무 상관이 없다. 답을 모르는 질문을 한다: 면접관으로서 어떤 질문에 어떤 답변이 나와야 하는지 잘 모르겠다면 채용 중인 직무와 관련해서는 그다지 중요한 질문이 아닐 가능성이 높다. 지원자를 바보로 만든다: “내가 질문에 대답을 다 하고, 구현했던 아키텍처에 대해 설명을 요청해 주었을 때 즉시 일어나서 화이트보드에 설명을 했다. 그때 내 직속 상관이 될 면접관이 “너무 단순하네요. 그건 제대로 된 실제 아키텍처가 아닙니다.” 라고 하였다. 그래서 “감사합니다. 이 단순한 아키텍처가 3개 대륙에 걸쳐 2천만 명이 넘는 가입자를 서비스하고 있습니다. 간단한 시스템으로 해냈다는 것을 기쁘게 생각합니다.” 라고 말했고, 면접 기회를 준 것에 감사를 표하고 자리를 떠났다. 인터넷 접속을 막는다: 코딩 면접을 할 때 진짜 코딩 실력을 알겠다는 이유로 이러는 것은 말도 안된다. 솔루션 탐색 능력 또한 지원자에게 필요한 능력이며, 인터넷 검색때문에 코딩 면접이 변별력을 잃을 수 있다면 면접 과제 자체에 문제가 있는 것이다. 종이에 코드를 작성하게 한다: 우리는 학교처럼 의사 코드로 평가하는 것이 아니다. 실제도구를 이용해서 생산된 실제 코드를 평가해야 한다. 알고리즘 문제를 낸다: 시스템 개발에 필요한 상당수의 업무들이 알고리즘에 대한 깊은 이해를 필요로 하지 않는다. “지원자의 문제 해결 능력을 보아야 한다.” 라는 이유인데, 맞는 말이지만 회사의 실제 프로젝트와 가까운 다른 연습문제를 통해서도 이를 평가할 수 있다. 여러 시스템의 문제는 테스트가 부족하거나, 잘못된 설계, 떨어지는 응집성, 깊은 종속성, 새 기능 추가 시 부족한 리팩토링, 지속적인 요구사항 변경, 도메인 모델이 정교하지 못했다는 것들 등이 흔한 문제이다. 알고리즘은 절차적이고 함수적이며, 구현할 때 비즈니스 도메인 모델이나 클래스를 만들지는 않는다. 문제의 요지는, 회사에 필요한 개발능력을 평가해야한다. 알고리즘이 필요한거라면 알고리즘을, TDD(테스트주도개발)능력이 필요한거라면 그에 걸맞는 코딩 문제를 재시해야한다. 전화 면접을 한다: 시간이 부족할때만 해라. 딱딱하게 진행될 가능성이 높다. 잘못된 채용 공고 로 애들러Lou Adler “ 기술과 경험을 나열하는 전통적인 직무 요건은 재능에도 반하고, 다양성에도 반하며, 성공적인 채용과의 상관관계도 최악이다 “ 절대적인 숫자 숫자는 임의적이고 오해하기 쉬우며 변덕스럽다. 5년 간의 자바 경력… 얼마 이상의 대학 학점… 과 같은것은 후보자를 제대로 선별하는 데 별 도움이 안된다. 채용된 후에 새로운 기술 학습 없이 같은 기술만으로 오래 일하는 개발자들이 많고, 이는 매년 새로운 기술을 익힌 개발자에 비해 1/5의 가치를 지니고 있다고 할 수도 있다. 키워드 매칭 채용 담당자들은 특정 기술이나 플랫폼에 대한 약어들을 선호하지 않는다. 채용 담당자는 해당 업무의 본질적인 부분을 잘 모르기 때문에 선무당에게 굿을 맡기는 결과가 된다. 기술 목록의 나열 불필요하게 너무 많은 기술 목록을 나열하면 재능있고 정직한 개발자가 스스로 지원을 포기하게 만들 수 있다. 보통 더 나은 개발잘르 선별하려는 욕심에 필요한 기술에 희망 기술까지 더해지기 일쑤다. 이는 후보군만 줄이는 행동이며 실제 그 업무를 잘하기 위한 것과 전혀 관계가 없다. 잘못된 기업 문화 설명 기업의 가치와 기대되는 태도, 책임을 채용 공고에 잘못 설명하는 경우가 많다. 팀워크, 긍정적 태도, 열정, 지혜로움과 같은 단어들을 나열하지 않도록 한다. 이러한 것들 중 어느 하나라도 자신이 해당하지 않는다고 스스로를 배제하는 지원자는 없다. 잘못된 요구 항목 더 훌륭한 개발자를 유인하기 위해서는 기술, 경력 년수, 일한 산업군, 출신 학교, 학점보다 그 직무에서 무엇을 책임져야 하는지 설명하는 것이 훨씬 낫다. 위에 나열된 항목들은 실제 역량과 전혀 일치하지 않는다. 잘못된 선별 조건 직무 요건들은 최고의 인재를 얻기 위함이 아닌 아닌 최악의 인재들을 걸러내기 위한 목적으로 설계되어 있다. 최고의 개발자들은 특정 기술의 사용 유무보다 회사의 문화, 업무에서의 책임, 프로젝트의 종류를 훨씬 더 중요하게 여긴다. 승진 요건과의 불일치 승진심사 때, 특정 프레임워크의 API를 알고있거나 자바 경력이 몇년 이상이라서 승진하지 않고, 그가 이룬 성과와 리더십, 팀워크와 같은 다른 중요한 이유로 승진을 한다. 채용 공고의 직무 요건이 이러한 승진 요건과 합치되는 부분이 없다면 그 직무 요건으로 필터링된 사람들이 회사 안에서 좋은 성과를 낼 거라는 기대 자체가 모순이다. 단순한 설계를 위한 네 가지 원칙 모든 테스트의 통과 중복의 최소화 : 동작/설정에 중복이 있으면 안된다. 명료성의 최대화 : 명료하고, 충분히 표현되고, 일관되어야 한다. 구성요소의 최소화 : 메서드, 클래스, 모듈의 수는 가능한 적어야 한다. 오디션 개최 (in “Peopleware”) 우리가 몸담은 업계는 기술적이보다는 사회적이다. 직원-기계의 소통 능력보다 서로와 소통하는 능력이 더 주요하다. 그러므로 직원 채용 절차는 최소한 사회적이고 인간적인 의사소통 역량에 초점을 맞춰야 하며, 이 책의 저자가 발견한 최선의 방법은 후보자에 대한 오디션이다. 개념은 간단하다. 과거에 자신이 수행한 업무와 관련해 10분에서 15분정도 프레젠테이션을 시킨다. 생전 처음 써봤던 새 기술/경험일 수도 있고, 힙겹게 깨우친 관리 경험일 수도 있고, 아주 재미있었던 프로젝트일 수도 있다. 주제는 지원자가 선택하고, 발표일을 정해 지원자와 함께 일할 사람들로 소규모 청중을 구성한다. 물론 지원자는 긴장하고, 안 하려고 들지도 모른다. 누구나 긴장하기 마련이라고 말해주라. 오디션을 여는 이유도 설명하라. 다양한 지원자들의 의사소통 능력을 보고, 미래 동료 직원들을 채용 과정에 참여시키려는 의도라 설명한다. 오디션을 마치고 지원자가 떠난 다음 참석자들과 간단히 후기를 나눈다. 각 참석자가 돌아가며 지원자가 업무에 적합한지, 그리고 팀과 잘 어울릴지 의견을 말한다. 물론 최종적인 결정은 관리자에게 달렸지만 미래 동료 직원들이 내놓는 의견은 굉장히 소중한다. 게다가 이렇게 고용한 신입 직원은 팀도 무리 없이 받아들인다. 팀원들이 뽑자 햇기 때문이다. ” 오디션을 열면 신입 직원과 기존 직원들이 더 빨리 친해진다. 성공적인 오디션은 동료들로부터 받는 일종의 인증이었고, 반대의 경우도 역시 일종의 인증이었다. 실패한 오디션 후에는 직원들의 사기가 확 올라갔다. 자신을 채용한 이유가 하필 그 때 관리자의 책상에 이력서가 놓여 있었던 뜻밖의 행운 때문이 아니라는 사실을 지속적으로 보여주는 증거이기 때문이다. “ 오디션을 열 대는 한 가지 주의할 사항이 있다. 지원자는 회사가 하는 일과 직접 관련 있는 주제를 다뤄야 한다. “랭커 찍은 게임” 이나 “정원 가꾸기” 등 극단적인 주제라면 지원자는 굉장한 열정으로 발표하겠지만, 직장에서는 그런 열정을 못 볼지도 모른다. 베테랑 프로그래머와 대규모 프로젝트 뛰어난 프로그래머들과 좀 처지는 이들 간에는 상당한 생산성 차이가 있고, 이를 대부분의 관리자는 알고 있지만 정확히 수치적으로 나타낸다면 가장 뛰어난 사람과 가장 못한 사람의 생산성 비율이 평균 10:1이나 되고, 실행 속도와 사용 공간 면에서는 다섯 배의 차이가 난다. 간단히 말해, 연복 2만 달러를 받는 프로그래머가 1만 달러를 받는 이에 비해 열 배의 생산성을 발휘할 수 있다는 뜻이며, 물론 그 반대 또한 가능하다. 이 연구의 데이터에서는 경력 연차와 성과 사이에 어떠한 상관 관계도 없었는데, 이는 경험을 하며 실제로 공부하고, 배워서 자신을 발전시키는지 아닌지에 대한 차이인 것 같다. 서로 소통해야 하는 사람 수가 전체 비용에 영향을 미친다. 사람이 많을수록 커뮤니케이션 부담은 N(N-1)/2 배가 되며 어느 순간 인력(맨-먼스, Man-Month) 을 투입해서 얻는 이익보다 손실이 더 많아질 지경에 이르게 될 수 있다. 이것은 비용의 대부분이 커뮤니케이션, 그리고 잘못된 커뮤니케이션의 부작용을 바로잡는 데 소요되기 때문이다. 이는 가능하면 적은 수의 사람들에 의해 시스템이 만들어는 편이 낫다는 것을 시사한다. 개념적 일관성이 부족한 결과물을 만들어 내기 때문이기도 하다. 보통 프로그래머 수백 명이 투입된 프로젝트보다 일급 멤버들로 구성된 작고 예리한 팀이 낫다고 하는데, 그 말 아래에는 앞의 수백 명은 평범하다는 뜻이 깔려 있다. 하지만 이는 “어떻게 해야 ‘큰’ 시스템을 의미 있는 일정 내에 만들어 낼 수 있는가?” 라는 어려운 질문을 회피하는 것을 뜻한다. 예를 들어보자. 200명이 투입된 프로젝트 내에 관리자이면서 가장 유능하고 경험 많은 프로그래머가 25명이 있다면, 나머지 175명은 해고하고 그 관리자들을 다시 프로그래밍에 투입하는 것이다. 하지만 이는 작은 팀은 아닌데, 보통 작은 팀이라면 10명 이하를 뜻하기 때문이다. 25명이면 최소 두 단계로 관리가 이루어지거나 5명의 관리자를 두어야 하는 규모이다. 이 팀에는 재무, 인사, 사무 공간, 비서 업무, 장비 운영에 추가 지원도 필요할 것이다. 하지만 다른 한편으로, 200명인 원래 팀은 정말로 큰 시스템을 주먹구구식으로 만들기에 충분한 규모가 아니다. OS/360의 개발에는 프로젝트에 1000명 넘게 투입되었고, 1963~1966년까지 이 시스템의 설계-구축-문서화에 들어간 공수는 대략 5000맨이어(Man-Year) 정도였다. 밀스Mills의 제안 커다란 전체 업무를 여러 팀에 나눠서 맡기되, 각 팀을 외과 수술 팀처럼 조직할 것의 제안이다. 즉, 모든 팀원이 다 같이 문제에 달려드는 것이 아니라, 한 명이 문제를 해결해 가는 동안 다른 이들은 그 사람이 효율과 생산성을 높일 수 있도록 여러 방면에서 지원해 주는 것이다. 이는 사실 현재로썬 당연한데(이 책은 1975년에 1판, 1995년에 2판이 나왔다), 설계와 구축에는 적은 수의 사람이 개입하면서, 작업에는 여러 사람이 개입한다. 외과의: 수석 프로그래머. 이 사람은 기능과 성능 명세를 직접 정의하며, 프로그램을 설계/코딩/테스트/문서화 한다. 그리고 전체 시스템에 실질적인 접속 권한을 가지고 있으며, 뛰어난 재능과 10년 이상의 경력, 시스템 및 응용 분야에 관한 상당 수준의 지식이 요구된다. 그 분야는 응용 수학이나 비즈니스 데이터 처리 등 무엇이나 될 수 있다. 부조종사: 외과의의 분신. 업무의 어떤 부분이든 수행 가능하지만 경험은 많지 않으며, 주된 역할은 설계 과정에 참여하여 같이 고민-토론-평가 하는 것이다. 외과의가 부조종사와 여러 아이디어를 시도할 수는 있지만, 부조종사의 의견에 구애받지는 않는다. 모든 코드를 상세하게 알고 있고, 대안적인 설계에 대한 전략을 연구하며 종종 팀을 대표한다. 행정 담당: 외과의는 인사, 임금 등의 최종 결정권이 있지만 이 부분에 시간을 할애해서는 안된다. 그러므로 돈, 사람, 공간, 장비를 관장하고 다른 부서의 행정 파트와 소통을 맡아줄 전문적인 행정 담당이 필요하다. 어떤 프로젝트에 법률적 계약적 중대 사안이 있거나, 보고를 강화해야하거나, 재무적 이슈가 있지 않다면 보통 한 명의 행정 담당이 두 팀을 맡을 수 있다. 편집자: 문서 생산은 최대한의 명확성을 위해 외과의가 직접 작성해야 한다. 외부/내부 문서에 동일하게 적용되지만, 외과의가 작성한 초안/구술 원고를 읽은 후에 그것을 비평/재작업/레퍼런스 보충/버전 관리/문서 생산 관리는 편집자가 담당해야 한다. 두 명의 비서: 행정 담당과 편집자는 비서가 한 명씩 필요하며, 행정 비서는 프로젝트 관련 우편물/일반적인 업무 서류를 관리한다. 프로그램 사무원: 이 사람은 팀에서 생산되는 모든 기술적인 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 컴퓨터에서 작업이 실행되는 전 과정을 팀의 멤버 누구나 볼 수 있게 하고, 프로그래밍이라는 작업을 “개인적인 예술에서 공개적인 실행으로” 바꾼다. 이 작업은 현대에서는 소스 컨트롤과 CI/CD라는 작업이 도맡아서 한다. 도구 담당: 여러 편집기, 서비스 중 확실히 신뢰할 수 있고 팀에 적합한 도구를 찾고, 이들을 구축-유지-업그레이드 하는 책임을 받는다. 종종 특화된 유틸리티/목록으로 정리된 프로시저/매크로 라이브러리 등을 구축하기도 한다. 테스터: 테스트 케이서를 만들고, 테스트 순서를 계획하고, 구성 요소 테스트를 위한 Scaffolding을 짠다. 이는 현대에 들어서 TDD(테스트 주도 개발) 과 같은 형태로 바뀌어 모든 프로그래머가 테스트를 작성하게 하기도 한다. 언어 전문가 책에서는 특정 언어를 마스터한 사람을 일컫지만, 알고리즘 전문가 또한 이곳에 포함될 수 있다고 생각한다. 즉, 특정 언어나 기술의 수학적이고 복잡한 부분을 잘 다루는 사람을 뜻한다. 대개 2명~3명의 외과의를 도울 수 있다. 한가지 경고할 점은, 이는 1975년도에 쓰여진 책이고 지금은 이런 내용들이 당연시 여겨지고 있으며 몇몇은 시대를 많이 지났다는 것이다. 하지만 그렇기에 교과서적인 기초와 개발체제의 탄생 배경을 알 수 있기에 참고해볼 만한 가치가 있다. 명세서 잘 짜여진 명세서는 [완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성] 이 있어야 한다. 완전성completeness 사용자의 모든 요구 사항이 누락되지 않고 완전하게 반영되었는가? 일관성consistency 요구 사항이 서로 모순/충돌되는 점은 없고, 산출물이나 요구사항의 내용이 일관성을 유지하는가? 명확성unambiguity 서술된 명세서의 내용이 애매하지 않고 모든 참여자가 명확히 이해 가능한가? 기능성functionality 서술된 명세서의 내용이 ‘어떻게’보다 ‘무엇을’에 관점을 두고 서술되었는가? 검증 가능성verifiability 서술된 명세서의 내용이 사용자의 요구를 만족하는지 검증할 수 있는가? 추적 가능성traceability 사용자 요구 분석 명세서와 설계 사양서를 추적할 수 있는가? 변경 용이성easily changeable 요구 분석 명세서의 내용을 변경하고자 할 때 쉽게 찾아 변경할 수 있는가? AWS EC2 서버 구축하기 운영 서버란? 개발이나 테스트 목적이 아닌, 실제 사용자들을 대상으로 서비스하는 서버를 말합니다. 테스트 할 때와는 다르게 트래픽 대응과 빠른 응답속도, 그리고 높은 가용성을 고려해야 합니다. 운영 서버 관리법은 크게 ‘환경 구성’, ‘코드 배포’, ‘모니터링’의 세 단계로 나뉩니다. ‘환경 구성’은 서비스할 코드를 구동시킬 수 있는 서버 인프라를 구축하는 것이고, ‘코드 배포’는 구성한 환경에 최신 버전의 코드를 빠르고 안전하게 배포하는 것이고, 마지막으로 ‘모니터링’은 안정적인 서비스 운영을 위해 서버와 코드에 어떤 이상이 없는지 바로 파악하고 대응할 수 있게 도와주는 것입니다. AWS(Amazon Web Services) 란? 미국의 대형 인터넷 쇼핑몰인 아마존(Amazon)에서 자사를 위해 개발하였던 인프라 시스템인데, 이 기술을 2006년에 공개하며 서비스하기 시작해서 만들어졌습니다. 컴퓨팅 서버를 클라우드로 제공하여서 원래는 물리적인 기계를 구매하여 배치하고, 구축하고, 작동해야 했기 때문에 전문 인력들이 필요했고, 서버의 상태가 어떻게 될 지 확실하지 않기 때문에 필요 이상의 규모를 구축해야 하지만, AWS와 같은 클라우드 서비스를 이용하면 몇번의 클릭만으로 가용량을 조정할 수 있습니다. 그래서 비용, 시간, 인력적인 면에서 많은 비용 절감이 가능하게 되죠. AWS EC2 인스턴스 생성하기 EC2(Elastic Compute Cloud)는 사양을 고르고 원하는 시간만큼 사용 가능한 가상 서버입니다. 필요할 때마다 키거나 끌 수 있고, 사용한 시간에 대해서만 비용을 지급합니다. 시작하기 전에, 알아야 할 세 가지 개념을 알려드리겠습니다. AMI(Amazon Machine Image) EC2 인스턴스의 기반이 되는 이미지입니다. 운영체제를 설치하기 위해 CD나 ISO 파일을 만드는 것과 같은 원리입니다. 이것을 이용하여 원하는 운영체제, 환경이 구성된 서버를 설치할 수 있습니다. 즉, 자신이나 타인이 구성한 서버 환경을 이미지 파일로 만들어서 재사용할 수 있습니다. 보안 그룹(Security Group) 보안을 위해 IP와 포트 번호를 이용해 정의하는 서버 접속 규칙입니다. 키 페어(Key pair) 서버에 접속하기 위한 보안키입니다. 서버에는 공개 키(public key)를 두고 사용자는 개인 키(private key)를 들고 접속하게 됩니다. AWS에 로그인하고, AWS 콘솔에 접속하고 서버의 위치를 서울로 설정합니다. 왼쪽 위의 서비스를 눌러 펼치고, EC2를 선택합니다. 왼쪽 [인스턴스] 카테고리의 [인스턴스] 를 선택하고 [인스턴스 시작] 버튼을 클릭합니다. Amazon Linux 2를 선택합니다. CentOS 기반으로 AWS에 적합하게 튜닝한 Linux OS입니다. 프리티어가 사용 가능한 t2.micro를 선택하고, 오른쪽 아래의 [다음: 인스턴스 세부 정보 구성] 을 클릭합니다. 설정은 건드리지 않고 [다음: 스토리지 추가] 를 클릭합니다. 마찬가지로 [다음: 태그 추가] 를 클릭합니다. [다른 태그 추가]를 클릭하고 원하는 키와 값을 입력하고, 다음으로 넘어갑니다. [새 보안 그룹 생성] 을 누른 후 이름과 설명을 지정합니다. 그리고 소스 부분에 드롭다운 메뉴에서 [내 IP] 를 선택합니다. 보통은 회사의 IP를 이용합니다. [검토 및 시작] 을 누르고 [시작] 을 누릅니다. 그 후 [새 키 페어 생성] 을 선택하고 이름을 적고, 키 페어를 다운로드합니다. 이 파일을 이용해야 서버에 접속할 수 있기 때문에 분실되거나 유출되어서는 안됩니다. 전부 다 끝났다면 [인스턴스 시작] 을 누르면 완료입니다. [인스턴스 보기] 를 누르면 인스턴스 상태가 보이고, “실행 중” 이 될 때까지 기다립니다. EC2는 서버가 켜져있는 만큼 비용이 지불되므로, 사용하지 않을때는 꼭 [중지] 합니다. 이는 잠깐 꺼두는 명령이고, [종료] 는 인스턴스를 삭제하는 명령입니다. 단, 서버의 디스크를 점유하고 있기 때문에 해당 사항에 대한 사용료는 지불됩니다. 이제 생성된 인스턴스에 접속하기 위해서는 SSH를 사용해야 하는데, 윈도우에서는 주로 PuTTY를 이용해서 접속하고 macOS나 Linux는 ssh 명령어로 접속합니다. 인스턴스 ID를 클릭하면 세부 정보를 확인할 수 있는데, 여기서 퍼블릭 도메인과 IP는 별도의 설정을 하지 않으면 인스턴스가 꺼질 때 사라지고 켜질 때마다 새로 할당받습니다. 윈도우에서 PuTTY로 SSH 접속하기 이 링크 에서 사용중인 운영체제에 해당하는 파일을 다운로드합니다. PuTTY로 키 파일인 .pem 파일을 바로 사용할 수 없기 때문에 “PuTTY Key Generator”를 이용해서 변환해주어야합니다. “puttygen.exe” 이라는 이름이고, 실행 후 [Load] 를 눌러 .pem 파일을 찾아(안보인다면 확장자 선택을 [All Files (.)] 으로)서 선택합니다. Parameters에서 RSA를 선택하고 Actions에서 Save private key를 선택합니다. 참고로, 여기서 Key passphrase: 와 그 밑의 Confirm passphrase: 는 선택 사항이지만 키가 유출된 경우 비밀번호로 한번 더 보호하는 기능을 합니다. 이제 “putty.exe” 를 실행하고, 카테고리에서 Session을 선택한 후에 “Host Name”에 [ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt;] 를 입력하고, Connection type는 SSH, 포트는 22(SSH의 포트)를 입력합니다. 그리고 왼쪽의 카테고리에서 Connection -&gt; SSH -&gt; Auth 메뉴에서 “Private key file for authentication” 에 아까 변환한 .ppk 파일을 지정하고, 아래의 [Open] 버튼을 누릅니다. 서버의 fingerprint를 레지스트에 키로 등록하겠냐는 경고창이 나오면 [예]를 클릭합니다. 참고) Session 카테고리에서 현재 세션의 정보를 Save해서 더블클릭으로 빠르게 접속할 수 있습니다. macOS/Linux에서 SSH 접속하기 터미널을 실행하고, 다운로드한 키 페어 파일의 권한을 변경합니다. chmod 400 /path/to/&lt;이름&gt;.pem SSH의 접속하기 위해 명령어를 입력합니다. ssh -i /path/to/&lt;이름&gt;.pem ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt; 서버의 fingerprint 값과 함께 접속을 계속하겠냐는 메시지가 나오면 ‘yes’ 를 입력합니다. 위의 모든 과정을 따라하셨다면 EC2 인스턴스의 생성과 접속까지 끝났습니다! AWS를 사용해서 웹 서버, 게임 서버 등 원하는 서버를 쉽고 간편하게 구축해 보세요. 투자 시장의 흐름이나 추세에 따라 거래하는 사람들은 단기간에 수익을 내기 위해 주가의 단기 변동을 예상하려고 노력한다. 하지만 이런 방법으로 수익을 낼 수 있는 사람은 거의 없고, 어느 누구도 아직까지 완벽한 방법을 개발하지 못했다. 시장의 추세를 찾으려고 노력하면 주가가 바닥을 치고 올라가는 시점에서 주식을 팔고 주가가 상승했다가 하락하는 시점에서 주식을 시작하는, 거꾸로 된 투자를 하게 된다 사람들은 자신이 운이 없기 때문에 이런 일이 생긴다고 생각하지만, 사실은 불가능한 일을 하려고 하기 때문이다. 사람들은 또한 폭락이나 조정을 받을 때 주식에 투자하는 것은 위험하다고 생각하는데, 이 시기에 주식을 파는 것이 위험한 행동이다. 이들은 주가가 가파르게 상승하는 얼마 안 되는 짧은 시간에 주식에 투자할 수 있는 기회를 놓치는 위험을 안고 있는 것이다. 주식을 살 때는 해당 기업이 많은 고객을 보유하고 앞으로도 늘어나는지를 보아야 한다. 그러니까, 해당 기업이 좋은 제품을 만드는지를 보아야 한다. 하지만 그 외에도, 자금을 현명하게 사용하는지, 부채의 규모는 어떤지, 매출이 어떤 속도로 증가/감소하고 있는지, 과거와 미래의 수익은 얼마인지, 주식이 어떤 가격에 팔리는지, 배당금은 어느정도인지도 보아야 한다. 수익, 매출, 부채, 배당금은 주식 종목을 선택하는 데 가장 중요한 숫자이다. TDD(테스트주도개발)의 3가지 법칙 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 조합 탐색combinatorial search 동적 계획법과 그리디 기법은 한계가 있기 때문에 결국 완전 탐색으로 풀어야 할 때가 오는데, 이 때 완전 탐색을 최적화하기 위해 완전 탐색을 포함하여 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 “조합 탐색” 이라고 부른다. 이 조합 탐색들은 기본적으로 최적해가 될 가능성이 없는 답의 수를 줄이는 것을 목표로 하고, 이것을 위한 최적화 기법들이 여러가지 있다. 가지치기pruning 탐색 과정에서 최적해로 연결될 가능성이 없는 부분을 잘라낸다. 예를 들어, 탐색들의 최적해를 기억해두고 있을 때 현재 상태의 최적해가 지금까지 구해놓은 최적해보다 좋지 않다면 이 탐색은 더이상 진행하지 않아도 좋다. 휴리스틱heuristic 기준점과 조정 휴리스틱 자신이 알고 있는 수치로 임의의 기준선을 설정한 후, 적절하다고 생각하는 것에 맞게 결정하는것. 가용성 휴리스틱 사건의 가능성을 기억의 가용성에 근거해 추정하는 것. 즉, 기억에서 잘 떠오르는 대상에 대해 상대적으로 높은 평가를 내리는 것 대표성 휴리스틱 어떤 집합에 속하는 임의의 한 특징이 그 집합의 특성을 대표한다고 간주해 빈도와 확률을 판단하는 방법 감정 휴리스틱 어떤 사건이나 상황에 대해 판단을 할 경우 경험으로 형성된 감정에 따라 평가를 다르게 하는 것 메타 휴리스틱 발견법은 해결하려는 문제마다 각기의 특성에 맞추어 개발해야 하는데, 특정 문제가 갖는 정보에 크게 구속되지 않고 다양한 문제들에 적용가능한 상위수준의 발견적 기법이다. 유전 알고리즘, 담금질 기법, 타부 서치가 있다. 드로잉 “캐릭터”를 그린다는 것은 무언가 인물을 그리는 것이 아니라 실제로 의미 그대로 “어떤 성격”을 시각적으로 표현함을 의미한다. 사람의 성격은 너무 복잡하기 때문에 우리 인간은 대상을 관념화해서 “쟤는 소심한 애야, 과격한 애야, 나쁜 애야”라고 단순하게 생각하는데, 이를 그림으로 나타낸 것이 바로 캐릭터이다. 이 캐릭터의 성장기부터 하는 행동을 다 설명할 순 없으니 직관적으로 알아볼 수 있도록 만들어야 하는 것이다. 그림을 그릴땐 모사(모작)부터 시작해야 하는데, 그 이유는 자신의 눈 앞에 있는것도 그릴 수 없는데 자신의 머리속에 있는 것은 그릴 수 없기 때문이다. 모사를 할 때의 방법은 수직/수평선 어딘가에 수직/수평선을 그리면 그곳을 기준으로 어디가 더 들어갔는지, 나와있는지, 비율과 대략적인 위치를 더 정확히 가늠할 수 있기 때문에 유용하게 사용될 수 있다. 가끔 창작물에 나오는 화가가 연필을 세로나 가로로 세워서 보는 것이 이것을 하는 작업이다. 격자 어떤 하나의 큰 그림을 그린다고 할때 이 그림은 한번에 그리는 것이 거의 불가능하니 격자로 부분을 나눠서 부분들을 그리다 보면 전체가 완성되는 것이다. 그래서 모사할 대상과 그릴 그림을 실제로 선으로 된 격자로 나눠 부분을 그리면 더 정확하게 그릴 수 있다. 실루엣 안쪽이 아닌 바깥쪽을 보는 것, 무엇의 윤곽을 보는 것이다. 그러니 그리려는 대상의 전경을 그리는 것이 전체적인 틀을 잡기 더 쉬워진다. 변상증 인간은 의미없는 것에 의미를 부여하기를 좋아한다. 왜냐면 알수 없는 개체가 나타났을 때 우리는 위협에 대비해야 하기 때문이다. 이를 응용하여 그림을 그릴때 부분들이 “무언가를 닮았다” 라고 생각하여 그리다 보면 이 부분들이 모여 하나의 완성된 그림이 된다. 그림을 그릴 때, 특히 사람과 같은 복잡한 것을 그릴때는 그것에 대해 이미 가지고 있는 지식때문에 그림을 그리기가 힘든데, 그래서 대상을 대상으로 바라보지 않는, 그저 빛과 어둠(검고 흰것)으로 이루어진 도형이라고 인식하는 연습이 필요하다. 위의 4가지 방법은 익숙해지면 실제로 수직/수평선을 그리거나 하지 않아도 자연스럽게 머리속에서 그려지게 된다. 참고로 요약자의 경우 1년정도 취미로 모작을 했었는데, 단순 취미의 영역이라면 많이 하면 이 부분은 자연스럽게 가능해질 것이라 생각한다.","headline":"지식 스크랩","mainEntityOfPage":{"@type":"WebPage","@id":"https://termsigening97.github.io/posts/Scraps/"},"url":"https://termsigening97.github.io/posts/Scraps/"}</script><title>지식 스크랩 | Sigening</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sigening"><meta name="application-name" content="Sigening"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/Profile.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sigening</a></div><div class="site-subtitle font-italic">Game Dev</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/termsigening97" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/termsigening97" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['termsigening97','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>지식 스크랩</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>지식 스크랩</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/termsigening97">Jun Hwi Gu</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1652329800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-12 </em> </span> <span> Updated <em class="timeago" data-ts="1652331633" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-12 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11100 words"> <em>61 min</em> read</span></div></div></div><div class="post-content"><h1 id="informative-urls">Informative URLS</h1><p>Refactoring &amp; Design Pattern <a href="https://refactoring.guru">Website</a> <br /> Unreal Engine Multiplayer - Replication <a href="https://youtu.be/JOJP0CvpB8w">Youtube</a></p><h1 id="tiny-facts">Tiny Facts</h1><ul><li><p>깨끗한 코드는 읽으면서 놀랄 일이 없어야 한다. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 읽으면서 짐작한 대로 돌아가는, 명백하고 단순해 마음이 끌리는 코드가 깨끗한 코드다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 상황이 보인다.</p><li><p>코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.</p><li><p>구상한 아이디어로 프로토타입을 작성하여 플레이테스트를 해 보아라. 이 때, 프로토타입은 필수적인 기능만 빠르게 작성하도록 한다. 또한, 반복작업을 통해 개선하라. 프로토타입이 좋다고 해도 이를 바로 최종 결과물로 가능한 작성하지 마라. 프로토타입에서 아이디어가 나오지는 않는다. 이는 단지 어떤 것이 좋은 아이디어인지, 나쁜 아이디어인지 판단을 가능하게 해 준다.</p></ul><p>만약 내 게임을 설명할 때 “어떤 게임과 비슷하지만 어떤 스토리와 배경을 가지고 있다” 와 같이 기존 게임의 복제판에 불과한 게임을 만들고 싶지 않다면 자신의 원래 개념으로 돌아가 “이 아이디어에서 특별한 것은 무엇인가?” 라고 묻는 것이다.</p><h1 id="personal-studies">Personal Studies</h1><blockquote><p>인생의 12가지 법칙 - 질서너머 中</p></blockquote><ol><li><p>기존 제도나 창의적 변화를 함부로 깎아내리지 마라</p><li><p>내가 누구일 수 있는지 상상하고, 그것을 목표로 삼아라</p><li><p>원치 않는 것을 안개 속에 묻어두지 마라</p><li><p>남들이 책임을 방치한 곳에 기회가 숨어 있음을 인식하라</p><li><p>하고 싶지 않은 것을 하지 마라</p><li><p>이데올로기를 버려라</p><li><p>최소한 한 가지 일에 최대한 파고들고, 그 결과를 지켜보라</p><li><p>방 하나를 할 수 있는 한 아름답게 꾸며보라</p><li><p>여전히 나를 괴롭히는 기억이 있다면 아주 자세하게 글로 써보라</p><li><p>관계의 낭만을 유지하기 위해 성실히 계획하고 관리하라</p><li><p>분개하거나 거짓되거나 교만하지 마라</p><li><p>고통스러울지라도 감사하라</p></ol><p>여기서 가장 큰 교훈은, 무언가를 평가하기 위해서는 그것에 대해 완전히 이해해야 한다는 점이다. 젊은 혈기에 근거없이 현재의 제도를 비판하지 말고 그 제도의 이유를 먼저 알고, 설득하라.</p><p>더 높은 도덕을 위해 법칙을 깨려는 사람은 처음에는 그 법칙을 철저히 익히고 훈련해서 그 필요성을 이해해야 한다. 그리고 법칙의 자구字句 가 아니라 그 정신에 맞게 법칙을 깨야 한다.</p><blockquote><p>반복 설계iterative design</p></blockquote><p>어떤 설계안은 본질적으로 오류가 발생하기 쉬우므로 고치지 말고 버려야 한다, 설계 과정에서 이런 막다른 골목을 예상해야 한다, 막다른 골목에 이르기까디 쏟아 부은 노력은 깔끔하고 산뜻한 새 출발을 위해 치르는 작은 대가에 불과하다.</p><p>하지만 많은 관리자들이 그랬다가는 상사와 굉장히 곤란한 정치적 갈등에 빠지리라 생각한다. 이는 장기적으로 돈이 더 들더라도 불량 버전을 수선하는 게 낫다고 생각하는 것과 같다.</p><blockquote><p>무지의 5단계</p></blockquote><ol><li><p>0단계 무지 - 무지의 부재 (Lack of Ignorance) 무엇을 해야할지, 어떻게 표현할 지 알고 있는 단계</p><li><p>1단계 무지 - 지식의 부재(Lack of Knowledge) 어떻게 해야 할지 모르지만, 하기 위해서 무엇을 배워야 할 지 아는 단계.</p><li><p>2단계 무지 - 지각의 부재(Lack of Awareness) 어떤 것을 모른 다는 것을 모르는 단계.</p><li><p>3단계 무지 - 프로세스의 부재(Lack of Process) 어떤 모르는 것에 대해서 모른 다는 것(2단계 무지)을 알아내기 위한 적당하고 효율적인 방법 모르는 단계</p><li><p>4단계 무지 - 메타 무지 (Meta-Ignorance) 무지의 5단계에 대해서 모르는 단계.</p></ol><blockquote><p>산만의 지속</p></blockquote><p>세대 차이를 뚜렷이 부각하는 요소는 집중이다. 나이 든 사람은 한 번에 한두 가지 일에 집중하는 반면 젊은이들은 온갖 일에 주의를 분산한다. 아이팟으로 음악을 틀어놓고, 끊임없이 문자를 하며, SNS 사이트는 24시간 열어두고, 학교 숙제 도중에 간간히 비디오 게임도 해가며 공부하는 세대를 린다 스톤은 “산만의 지속” 이라고 묘사한다. 젊은 신입은 이런 환경에서 가장 효율적으로 일한다고 말한다.</p><p>문제는 산만의 지속이 몰입과는 정확히 반대 상태라는 사실이다. 일을 하는데 몰입이 필수라는 것에 동의한다면, 어느 선에서 주의의 분산을 제지해야 한다. 업무 시간 2%를 한번에 연달아 페이스북에 쏟는 경우와 종일 주의의 2%를 페이스북에 쏟는 경우가 다르다는 사실을 젊은 신입이 이해하게 해야된다. 몰입하지 못해 일에 장애가 생기기 때문이다.</p><blockquote><p>인적 자본 투자</p></blockquote><p>회사가 사람에게 투자하는 돈에 관리자가 바라보는 관점은 중요하다. 인적 자본에는 실체가 있다. 이것을 버리는 돈(경비)로 잘못 생각하면 조직이 투자한 가치를 보존하지 못하는 행동을 관리자가 무심코 저지르게 만들지도 모른다.</p><p>물론 ‘조직이 투자한 가치를 보존하지 못하는 행동’은 문제 있는 관리의 전형적인 표본이다. 중간 관리층과 경영진이 장기적인 성장을 희생해 단기적인 성과를 내는(당장의 분기 수익을 높이는)더 나은 방법을 내놓겠다고 서로 경쟁하며 싸운다. 보통은 이것을 “손익 계산만을 문제 삼은 의식”이라 부르지만, 우리는 또 다른 이름인 “종자용 옥수수 먹기” 라 부른다.</p><blockquote><p>잘못된 면접 방식</p></blockquote><ul><li><p>똑똑한 척하는 면접관을 세운다: 이 면접관은 사사로운 즐거움을 위해 지원자를 힘든 상황으로 몰아붙일것이다.</p><li><p>수수께끼식 질문을 던진다: 비행기에 골프 공이 몇 개나 들어갈까? 구글이 했었던 면접이지만 이제 그 당사자들도 잘못된 것을 깨닫고 이런 질문을 그만둔지 오래이다. 개발능력과 아무 상관이 없다.</p><li><p>답을 모르는 질문을 한다: 면접관으로서 어떤 질문에 어떤 답변이 나와야 하는지 잘 모르겠다면 채용 중인 직무와 관련해서는 그다지 중요한 질문이 아닐 가능성이 높다.</p><li><p>지원자를 바보로 만든다: “내가 질문에 대답을 다 하고, 구현했던 아키텍처에 대해 설명을 요청해 주었을 때 즉시 일어나서 화이트보드에 설명을 했다. 그때 내 직속 상관이 될 면접관이 “너무 단순하네요. 그건 제대로 된 실제 아키텍처가 아닙니다.” 라고 하였다. 그래서 “감사합니다. 이 단순한 아키텍처가 3개 대륙에 걸쳐 2천만 명이 넘는 가입자를 서비스하고 있습니다. 간단한 시스템으로 해냈다는 것을 기쁘게 생각합니다.” 라고 말했고, 면접 기회를 준 것에 감사를 표하고 자리를 떠났다.</p><li><p>인터넷 접속을 막는다: 코딩 면접을 할 때 진짜 코딩 실력을 알겠다는 이유로 이러는 것은 말도 안된다. 솔루션 탐색 능력 또한 지원자에게 필요한 능력이며, 인터넷 검색때문에 코딩 면접이 변별력을 잃을 수 있다면 면접 과제 자체에 문제가 있는 것이다.</p><li><p>종이에 코드를 작성하게 한다: 우리는 학교처럼 의사 코드로 평가하는 것이 아니다. 실제도구를 이용해서 생산된 실제 코드를 평가해야 한다.</p><li><p>알고리즘 문제를 낸다: 시스템 개발에 필요한 상당수의 업무들이 알고리즘에 대한 깊은 이해를 필요로 하지 않는다. “지원자의 문제 해결 능력을 보아야 한다.” 라는 이유인데, 맞는 말이지만 회사의 실제 프로젝트와 가까운 다른 연습문제를 통해서도 이를 평가할 수 있다. 여러 시스템의 문제는 테스트가 부족하거나, 잘못된 설계, 떨어지는 응집성, 깊은 종속성, 새 기능 추가 시 부족한 리팩토링, 지속적인 요구사항 변경, 도메인 모델이 정교하지 못했다는 것들 등이 흔한 문제이다. <strong>알고리즘은 절차적이고 함수적이며, 구현할 때 비즈니스 도메인 모델이나 클래스를 만들지는 않는다.</strong> 문제의 요지는, 회사에 필요한 개발능력을 평가해야한다. 알고리즘이 필요한거라면 알고리즘을, TDD(테스트주도개발)능력이 필요한거라면 그에 걸맞는 코딩 문제를 재시해야한다.</p><li><p>전화 면접을 한다: 시간이 부족할때만 해라. 딱딱하게 진행될 가능성이 높다.</p></ul><blockquote><p>잘못된 채용 공고</p></blockquote><p>로 애들러Lou Adler “ 기술과 경험을 나열하는 전통적인 직무 요건은 재능에도 반하고, 다양성에도 반하며, 성공적인 채용과의 상관관계도 최악이다 “</p><ul><li><dl><dt>절대적인 숫자<dd>숫자는 임의적이고 오해하기 쉬우며 변덕스럽다. 5년 간의 자바 경력… 얼마 이상의 대학 학점… 과 같은것은 후보자를 제대로 선별하는 데 별 도움이 안된다. 채용된 후에 새로운 기술 학습 없이 같은 기술만으로 오래 일하는 개발자들이 많고, 이는 매년 새로운 기술을 익힌 개발자에 비해 1/5의 가치를 지니고 있다고 할 수도 있다.</dl><li><dl><dt>키워드 매칭<dd>채용 담당자들은 특정 기술이나 플랫폼에 대한 약어들을 선호하지 않는다. 채용 담당자는 해당 업무의 본질적인 부분을 잘 모르기 때문에 선무당에게 굿을 맡기는 결과가 된다.</dl><li><dl><dt>기술 목록의 나열<dd>불필요하게 너무 많은 기술 목록을 나열하면 재능있고 정직한 개발자가 스스로 지원을 포기하게 만들 수 있다. 보통 더 나은 개발잘르 선별하려는 욕심에 필요한 기술에 희망 기술까지 더해지기 일쑤다. 이는 후보군만 줄이는 행동이며 실제 그 업무를 잘하기 위한 것과 전혀 관계가 없다.</dl><li><dl><dt>잘못된 기업 문화 설명<dd>기업의 가치와 기대되는 태도, 책임을 채용 공고에 잘못 설명하는 경우가 많다. 팀워크, 긍정적 태도, 열정, 지혜로움과 같은 단어들을 나열하지 않도록 한다. 이러한 것들 중 어느 하나라도 자신이 해당하지 않는다고 스스로를 배제하는 지원자는 없다.</dl><li><dl><dt>잘못된 요구 항목<dd>더 훌륭한 개발자를 유인하기 위해서는 기술, 경력 년수, 일한 산업군, 출신 학교, 학점보다 그 직무에서 무엇을 책임져야 하는지 설명하는 것이 훨씬 낫다. 위에 나열된 항목들은 실제 역량과 전혀 일치하지 않는다.</dl><li><dl><dt>잘못된 선별 조건<dd>직무 요건들은 최고의 인재를 얻기 위함이 아닌 아닌 최악의 인재들을 걸러내기 위한 목적으로 설계되어 있다. 최고의 개발자들은 특정 기술의 사용 유무보다 회사의 문화, 업무에서의 책임, 프로젝트의 종류를 훨씬 더 중요하게 여긴다.</dl><li><dl><dt>승진 요건과의 불일치<dd>승진심사 때, 특정 프레임워크의 API를 알고있거나 자바 경력이 몇년 이상이라서 승진하지 않고, 그가 이룬 성과와 리더십, 팀워크와 같은 다른 중요한 이유로 승진을 한다. 채용 공고의 직무 요건이 이러한 승진 요건과 합치되는 부분이 없다면 그 직무 요건으로 필터링된 사람들이 회사 안에서 좋은 성과를 낼 거라는 기대 자체가 모순이다.</dl></ul><blockquote><p>단순한 설계를 위한 네 가지 원칙</p></blockquote><ol><li>모든 테스트의 통과<li>중복의 최소화 : 동작/설정에 중복이 있으면 안된다.<li>명료성의 최대화 : 명료하고, 충분히 표현되고, 일관되어야 한다.<li>구성요소의 최소화 : 메서드, 클래스, 모듈의 수는 가능한 적어야 한다.</ol><blockquote><p>오디션 개최 (in “Peopleware”)</p></blockquote><p>우리가 몸담은 업계는 기술적이보다는 사회적이다. 직원-기계의 소통 능력보다 서로와 소통하는 능력이 더 주요하다. 그러므로 직원 채용 절차는 최소한 사회적이고 인간적인 의사소통 역량에 초점을 맞춰야 하며, 이 책의 저자가 발견한 최선의 방법은 후보자에 대한 오디션이다.</p><p>개념은 간단하다. 과거에 자신이 수행한 업무와 관련해 10분에서 15분정도 프레젠테이션을 시킨다. 생전 처음 써봤던 새 기술/경험일 수도 있고, 힙겹게 깨우친 관리 경험일 수도 있고, 아주 재미있었던 프로젝트일 수도 있다. 주제는 지원자가 선택하고, 발표일을 정해 지원자와 함께 일할 사람들로 소규모 청중을 구성한다.</p><p>물론 지원자는 긴장하고, 안 하려고 들지도 모른다. 누구나 긴장하기 마련이라고 말해주라. 오디션을 여는 이유도 설명하라. 다양한 지원자들의 의사소통 능력을 보고, 미래 동료 직원들을 채용 과정에 참여시키려는 의도라 설명한다.</p><p>오디션을 마치고 지원자가 떠난 다음 참석자들과 간단히 후기를 나눈다. 각 참석자가 돌아가며 지원자가 업무에 적합한지, 그리고 팀과 잘 어울릴지 의견을 말한다. 물론 최종적인 결정은 관리자에게 달렸지만 미래 동료 직원들이 내놓는 의견은 굉장히 소중한다. 게다가 이렇게 고용한 신입 직원은 팀도 무리 없이 받아들인다. 팀원들이 뽑자 햇기 때문이다.</p><p>” 오디션을 열면 신입 직원과 기존 직원들이 더 빨리 친해진다. 성공적인 오디션은 동료들로부터 받는 일종의 인증이었고, 반대의 경우도 역시 일종의 인증이었다. 실패한 오디션 후에는 직원들의 사기가 확 올라갔다. 자신을 채용한 이유가 하필 그 때 관리자의 책상에 이력서가 놓여 있었던 뜻밖의 행운 때문이 아니라는 사실을 지속적으로 보여주는 증거이기 때문이다. “</p><p>오디션을 열 대는 한 가지 주의할 사항이 있다. 지원자는 회사가 하는 일과 직접 관련 있는 주제를 다뤄야 한다. “랭커 찍은 게임” 이나 “정원 가꾸기” 등 극단적인 주제라면 지원자는 굉장한 열정으로 발표하겠지만, 직장에서는 그런 열정을 못 볼지도 모른다.</p><blockquote><p>베테랑 프로그래머와 대규모 프로젝트</p></blockquote><p>뛰어난 프로그래머들과 좀 처지는 이들 간에는 상당한 생산성 차이가 있고, 이를 대부분의 관리자는 알고 있지만 정확히 수치적으로 나타낸다면 가장 뛰어난 사람과 가장 못한 사람의 생산성 비율이 평균 10:1이나 되고, 실행 속도와 사용 공간 면에서는 다섯 배의 차이가 난다. 간단히 말해, 연복 2만 달러를 받는 프로그래머가 1만 달러를 받는 이에 비해 열 배의 생산성을 발휘할 수 있다는 뜻이며, 물론 그 반대 또한 가능하다. 이 연구의 데이터에서는 경력 연차와 성과 사이에 어떠한 상관 관계도 없었는데, 이는 경험을 하며 실제로 공부하고, 배워서 자신을 발전시키는지 아닌지에 대한 차이인 것 같다.</p><p>서로 소통해야 하는 사람 수가 전체 비용에 영향을 미친다. 사람이 많을수록 커뮤니케이션 부담은 N(N-1)/2 배가 되며 어느 순간 인력(맨-먼스, Man-Month) 을 투입해서 얻는 이익보다 손실이 더 많아질 지경에 이르게 될 수 있다. 이것은 비용의 대부분이 커뮤니케이션, 그리고 잘못된 커뮤니케이션의 부작용을 바로잡는 데 소요되기 때문이다. 이는 가능하면 적은 수의 사람들에 의해 시스템이 만들어는 편이 낫다는 것을 시사한다. 개념적 일관성이 부족한 결과물을 만들어 내기 때문이기도 하다.</p><p>보통 프로그래머 수백 명이 투입된 프로젝트보다 일급 멤버들로 구성된 작고 예리한 팀이 낫다고 하는데, 그 말 아래에는 앞의 수백 명은 평범하다는 뜻이 깔려 있다. 하지만 이는 “어떻게 해야 ‘큰’ 시스템을 의미 있는 일정 내에 만들어 낼 수 있는가?” 라는 어려운 질문을 회피하는 것을 뜻한다.</p><p>예를 들어보자. 200명이 투입된 프로젝트 내에 관리자이면서 가장 유능하고 경험 많은 프로그래머가 25명이 있다면, 나머지 175명은 해고하고 그 관리자들을 다시 프로그래밍에 투입하는 것이다.</p><p>하지만 이는 작은 팀은 아닌데, 보통 작은 팀이라면 10명 이하를 뜻하기 때문이다. 25명이면 최소 두 단계로 관리가 이루어지거나 5명의 관리자를 두어야 하는 규모이다. 이 팀에는 재무, 인사, 사무 공간, 비서 업무, 장비 운영에 추가 지원도 필요할 것이다.</p><p>하지만 다른 한편으로, 200명인 원래 팀은 정말로 큰 시스템을 주먹구구식으로 만들기에 충분한 규모가 아니다. OS/360의 개발에는 프로젝트에 1000명 넘게 투입되었고, 1963~1966년까지 이 시스템의 설계-구축-문서화에 들어간 공수는 대략 5000맨이어(Man-Year) 정도였다.</p><hr /><blockquote><p>밀스Mills의 제안</p></blockquote><p>커다란 전체 업무를 여러 팀에 나눠서 맡기되, 각 팀을 외과 수술 팀처럼 조직할 것의 제안이다. 즉, 모든 팀원이 다 같이 문제에 달려드는 것이 아니라, 한 명이 문제를 해결해 가는 동안 다른 이들은 그 사람이 효율과 생산성을 높일 수 있도록 여러 방면에서 지원해 주는 것이다.</p><p>이는 사실 현재로썬 당연한데(이 책은 1975년에 1판, 1995년에 2판이 나왔다), 설계와 구축에는 적은 수의 사람이 개입하면서, 작업에는 여러 사람이 개입한다.</p><ul><li><p><strong>외과의:</strong> 수석 프로그래머. 이 사람은 기능과 성능 명세를 직접 정의하며, 프로그램을 설계/코딩/테스트/문서화 한다. 그리고 전체 시스템에 실질적인 접속 권한을 가지고 있으며, 뛰어난 재능과 10년 이상의 경력, 시스템 및 응용 분야에 관한 상당 수준의 지식이 요구된다. 그 분야는 응용 수학이나 비즈니스 데이터 처리 등 무엇이나 될 수 있다.</p><li><p><strong>부조종사:</strong> 외과의의 분신. 업무의 어떤 부분이든 수행 가능하지만 경험은 많지 않으며, 주된 역할은 설계 과정에 참여하여 같이 고민-토론-평가 하는 것이다. 외과의가 부조종사와 여러 아이디어를 시도할 수는 있지만, 부조종사의 의견에 구애받지는 않는다. 모든 코드를 상세하게 알고 있고, 대안적인 설계에 대한 전략을 연구하며 종종 팀을 대표한다.</p><li><p><strong>행정 담당:</strong> 외과의는 인사, 임금 등의 최종 결정권이 있지만 이 부분에 시간을 할애해서는 안된다. 그러므로 돈, 사람, 공간, 장비를 관장하고 다른 부서의 행정 파트와 소통을 맡아줄 전문적인 행정 담당이 필요하다. 어떤 프로젝트에 법률적 계약적 중대 사안이 있거나, 보고를 강화해야하거나, 재무적 이슈가 있지 않다면 보통 한 명의 행정 담당이 두 팀을 맡을 수 있다.</p><li><p><strong>편집자:</strong> 문서 생산은 최대한의 명확성을 위해 외과의가 직접 작성해야 한다. 외부/내부 문서에 동일하게 적용되지만, 외과의가 작성한 초안/구술 원고를 읽은 후에 그것을 비평/재작업/레퍼런스 보충/버전 관리/문서 생산 관리는 편집자가 담당해야 한다.</p><li><p><strong>두 명의 비서:</strong> 행정 담당과 편집자는 비서가 한 명씩 필요하며, 행정 비서는 프로젝트 관련 우편물/일반적인 업무 서류를 관리한다.</p><li><p><strong>프로그램 사무원:</strong> 이 사람은 팀에서 생산되는 모든 기술적인 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 컴퓨터에서 작업이 실행되는 전 과정을 팀의 멤버 누구나 볼 수 있게 하고, 프로그래밍이라는 작업을 “개인적인 예술에서 공개적인 실행으로” 바꾼다. 이 작업은 현대에서는 소스 컨트롤과 CI/CD라는 작업이 도맡아서 한다.</p><li><p><strong>도구 담당:</strong> 여러 편집기, 서비스 중 확실히 신뢰할 수 있고 팀에 적합한 도구를 찾고, 이들을 구축-유지-업그레이드 하는 책임을 받는다. 종종 특화된 유틸리티/목록으로 정리된 프로시저/매크로 라이브러리 등을 구축하기도 한다.</p><li><p><strong>테스터:</strong> 테스트 케이서를 만들고, 테스트 순서를 계획하고, 구성 요소 테스트를 위한 Scaffolding을 짠다. 이는 현대에 들어서 TDD(테스트 주도 개발) 과 같은 형태로 바뀌어 모든 프로그래머가 테스트를 작성하게 하기도 한다.</p><li><p><strong>언어 전문가</strong> 책에서는 특정 언어를 마스터한 사람을 일컫지만, 알고리즘 전문가 또한 이곳에 포함될 수 있다고 생각한다. 즉, 특정 언어나 기술의 수학적이고 복잡한 부분을 잘 다루는 사람을 뜻한다. 대개 2명~3명의 외과의를 도울 수 있다.</p></ul><p>한가지 경고할 점은, 이는 1975년도에 쓰여진 책이고 지금은 이런 내용들이 당연시 여겨지고 있으며 몇몇은 시대를 많이 지났다는 것이다. 하지만 그렇기에 교과서적인 기초와 개발체제의 탄생 배경을 알 수 있기에 참고해볼 만한 가치가 있다.</p><hr /><blockquote><p>명세서</p></blockquote><p>잘 짜여진 명세서는 [완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성] 이 있어야 한다.</p><ul><li>완전성completeness</ul><p>사용자의 모든 요구 사항이 누락되지 않고 완전하게 반영되었는가?</p><ul><li>일관성consistency</ul><p>요구 사항이 서로 모순/충돌되는 점은 없고, 산출물이나 요구사항의 내용이 일관성을 유지하는가?</p><ul><li>명확성unambiguity</ul><p>서술된 명세서의 내용이 애매하지 않고 모든 참여자가 명확히 이해 가능한가?</p><ul><li>기능성functionality</ul><p>서술된 명세서의 내용이 ‘어떻게’보다 ‘무엇을’에 관점을 두고 서술되었는가?</p><ul><li>검증 가능성verifiability</ul><p>서술된 명세서의 내용이 사용자의 요구를 만족하는지 검증할 수 있는가?</p><ul><li>추적 가능성traceability</ul><p>사용자 요구 분석 명세서와 설계 사양서를 추적할 수 있는가?</p><ul><li>변경 용이성easily changeable</ul><p>요구 분석 명세서의 내용을 변경하고자 할 때 쉽게 찾아 변경할 수 있는가?</p><hr /><blockquote><p>AWS EC2 서버 구축하기</p></blockquote><p>운영 서버란? 개발이나 테스트 목적이 아닌, 실제 사용자들을 대상으로 서비스하는 서버를 말합니다. 테스트 할 때와는 다르게 트래픽 대응과 빠른 응답속도, 그리고 높은 가용성을 고려해야 합니다.</p><p>운영 서버 관리법은 크게 ‘환경 구성’, ‘코드 배포’, ‘모니터링’의 세 단계로 나뉩니다. ‘환경 구성’은 서비스할 코드를 구동시킬 수 있는 서버 인프라를 구축하는 것이고, ‘코드 배포’는 구성한 환경에 최신 버전의 코드를 빠르고 안전하게 배포하는 것이고, 마지막으로 ‘모니터링’은 안정적인 서비스 운영을 위해 서버와 코드에 어떤 이상이 없는지 바로 파악하고 대응할 수 있게 도와주는 것입니다.</p><p>AWS(Amazon Web Services) 란? 미국의 대형 인터넷 쇼핑몰인 아마존(Amazon)에서 자사를 위해 개발하였던 인프라 시스템인데, 이 기술을 2006년에 공개하며 서비스하기 시작해서 만들어졌습니다. 컴퓨팅 서버를 클라우드로 제공하여서 원래는 물리적인 기계를 구매하여 배치하고, 구축하고, 작동해야 했기 때문에 전문 인력들이 필요했고, 서버의 상태가 어떻게 될 지 확실하지 않기 때문에 필요 이상의 규모를 구축해야 하지만, AWS와 같은 클라우드 서비스를 이용하면 몇번의 클릭만으로 가용량을 조정할 수 있습니다. 그래서 비용, 시간, 인력적인 면에서 많은 비용 절감이 가능하게 되죠.</p><p>AWS EC2 인스턴스 생성하기 EC2(Elastic Compute Cloud)는 사양을 고르고 원하는 시간만큼 사용 가능한 가상 서버입니다. 필요할 때마다 키거나 끌 수 있고, 사용한 시간에 대해서만 비용을 지급합니다. 시작하기 전에, 알아야 할 세 가지 개념을 알려드리겠습니다.</p><ul><li><p>AMI(Amazon Machine Image) EC2 인스턴스의 기반이 되는 이미지입니다. 운영체제를 설치하기 위해 CD나 ISO 파일을 만드는 것과 같은 원리입니다. 이것을 이용하여 원하는 운영체제, 환경이 구성된 서버를 설치할 수 있습니다. 즉, 자신이나 타인이 구성한 서버 환경을 이미지 파일로 만들어서 재사용할 수 있습니다.</p><li><p>보안 그룹(Security Group) 보안을 위해 IP와 포트 번호를 이용해 정의하는 서버 접속 규칙입니다.</p><li><p>키 페어(Key pair) 서버에 접속하기 위한 보안키입니다. 서버에는 공개 키(public key)를 두고 사용자는 개인 키(private key)를 들고 접속하게 됩니다.</p></ul><ol><li><p>AWS에 로그인하고, AWS 콘솔에 접속하고 서버의 위치를 서울로 설정합니다.</p><li><p>왼쪽 위의 서비스를 눌러 펼치고, EC2를 선택합니다.</p><li><p>왼쪽 [인스턴스] 카테고리의 [인스턴스] 를 선택하고 [인스턴스 시작] 버튼을 클릭합니다.</p><li><p>Amazon Linux 2를 선택합니다. CentOS 기반으로 AWS에 적합하게 튜닝한 Linux OS입니다.</p><li><p>프리티어가 사용 가능한 t2.micro를 선택하고, 오른쪽 아래의 [다음: 인스턴스 세부 정보 구성] 을 클릭합니다.</p><li><p>설정은 건드리지 않고 [다음: 스토리지 추가] 를 클릭합니다.</p><li><p>마찬가지로 [다음: 태그 추가] 를 클릭합니다.</p><li><p>[다른 태그 추가]를 클릭하고 원하는 키와 값을 입력하고, 다음으로 넘어갑니다.</p><li><p>[새 보안 그룹 생성] 을 누른 후 이름과 설명을 지정합니다. 그리고 소스 부분에 드롭다운 메뉴에서 [내 IP] 를 선택합니다. 보통은 회사의 IP를 이용합니다.</p><li><p>[검토 및 시작] 을 누르고 [시작] 을 누릅니다. 그 후 [새 키 페어 생성] 을 선택하고 이름을 적고, 키 페어를 다운로드합니다. 이 파일을 이용해야 서버에 접속할 수 있기 때문에 분실되거나 유출되어서는 안됩니다.</p></ol><p>전부 다 끝났다면 [인스턴스 시작] 을 누르면 완료입니다. [인스턴스 보기] 를 누르면 인스턴스 상태가 보이고, “실행 중” 이 될 때까지 기다립니다. EC2는 서버가 켜져있는 만큼 비용이 지불되므로, 사용하지 않을때는 꼭 [중지] 합니다. 이는 잠깐 꺼두는 명령이고, [종료] 는 인스턴스를 삭제하는 명령입니다. 단, 서버의 디스크를 점유하고 있기 때문에 해당 사항에 대한 사용료는 지불됩니다.</p><p>이제 생성된 인스턴스에 접속하기 위해서는 SSH를 사용해야 하는데, 윈도우에서는 주로 PuTTY를 이용해서 접속하고 macOS나 Linux는 ssh 명령어로 접속합니다.</p><p>인스턴스 ID를 클릭하면 세부 정보를 확인할 수 있는데, 여기서 퍼블릭 도메인과 IP는 별도의 설정을 하지 않으면 인스턴스가 꺼질 때 사라지고 켜질 때마다 새로 할당받습니다.</p><p>윈도우에서 PuTTY로 SSH 접속하기 이 링크 에서 사용중인 운영체제에 해당하는 파일을 다운로드합니다.</p><p>PuTTY로 키 파일인 .pem 파일을 바로 사용할 수 없기 때문에 “PuTTY Key Generator”를 이용해서 변환해주어야합니다. “puttygen.exe” 이라는 이름이고, 실행 후 [Load] 를 눌러 .pem 파일을 찾아(안보인다면 확장자 선택을 [All Files (<em>.</em>)] 으로)서 선택합니다. Parameters에서 RSA를 선택하고 Actions에서 Save private key를 선택합니다. 참고로, 여기서 Key passphrase: 와 그 밑의 Confirm passphrase: 는 선택 사항이지만 키가 유출된 경우 비밀번호로 한번 더 보호하는 기능을 합니다.</p><p>이제 “putty.exe” 를 실행하고, 카테고리에서 Session을 선택한 후에 “Host Name”에 [ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt;] 를 입력하고, Connection type는 SSH, 포트는 22(SSH의 포트)를 입력합니다. 그리고 왼쪽의 카테고리에서 Connection -&gt; SSH -&gt; Auth 메뉴에서 “Private key file for authentication” 에 아까 변환한 .ppk 파일을 지정하고, 아래의 [Open] 버튼을 누릅니다. 서버의 fingerprint를 레지스트에 키로 등록하겠냐는 경고창이 나오면 [예]를 클릭합니다.</p><p>참고) Session 카테고리에서 현재 세션의 정보를 Save해서 더블클릭으로 빠르게 접속할 수 있습니다.</p><p>macOS/Linux에서 SSH 접속하기 터미널을 실행하고, 다운로드한 키 페어 파일의 권한을 변경합니다.</p><p><code class="language-plaintext highlighter-rouge">chmod 400 /path/to/&lt;이름&gt;.pem</code> SSH의 접속하기 위해 명령어를 입력합니다.</p><p><code class="language-plaintext highlighter-rouge">ssh -i /path/to/&lt;이름&gt;.pem ec2-user@&lt;인스턴스의 퍼블릭 도메인/퍼블릭 IP 주소&gt;</code> 서버의 fingerprint 값과 함께 접속을 계속하겠냐는 메시지가 나오면 ‘yes’ 를 입력합니다.</p><p>위의 모든 과정을 따라하셨다면 EC2 인스턴스의 생성과 접속까지 끝났습니다! AWS를 사용해서 웹 서버, 게임 서버 등 원하는 서버를 쉽고 간편하게 구축해 보세요.</p><blockquote><p>투자</p></blockquote><p>시장의 흐름이나 추세에 따라 거래하는 사람들은 단기간에 수익을 내기 위해 주가의 단기 변동을 예상하려고 노력한다. 하지만 이런 방법으로 수익을 낼 수 있는 사람은 거의 없고, 어느 누구도 아직까지 완벽한 방법을 개발하지 못했다.</p><p>시장의 추세를 찾으려고 노력하면 <strong>주가가 바닥을 치고 올라가는 시점에서 주식을 팔고 주가가 상승했다가 하락하는 시점에서 주식을 시작하는, 거꾸로 된 투자를 하게 된다</strong> 사람들은 자신이 운이 없기 때문에 이런 일이 생긴다고 생각하지만, 사실은 불가능한 일을 하려고 하기 때문이다.</p><p>사람들은 또한 폭락이나 조정을 받을 때 주식에 투자하는 것은 위험하다고 생각하는데, 이 시기에 주식을 파는 것이 위험한 행동이다. 이들은 주가가 가파르게 상승하는 얼마 안 되는 짧은 시간에 주식에 투자할 수 있는 기회를 놓치는 위험을 안고 있는 것이다.</p><p>주식을 살 때는 해당 기업이 많은 고객을 보유하고 앞으로도 늘어나는지를 보아야 한다. 그러니까, 해당 기업이 좋은 제품을 만드는지를 보아야 한다. 하지만 그 외에도, 자금을 현명하게 사용하는지, 부채의 규모는 어떤지, 매출이 어떤 속도로 증가/감소하고 있는지, 과거와 미래의 수익은 얼마인지, 주식이 어떤 가격에 팔리는지, 배당금은 어느정도인지도 보아야 한다. <strong>수익, 매출, 부채, 배당금</strong>은 주식 종목을 선택하는 데 가장 중요한 숫자이다.</p><blockquote><p>TDD(테스트주도개발)의 3가지 법칙</p></blockquote><ul><li>실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.<li>컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.<li>현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.</ul><blockquote><p>조합 탐색combinatorial search</p></blockquote><p>동적 계획법과 그리디 기법은 한계가 있기 때문에 결국 완전 탐색으로 풀어야 할 때가 오는데, 이 때 완전 탐색을 최적화하기 위해 완전 탐색을 포함하여 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 “조합 탐색” 이라고 부른다. 이 조합 탐색들은 기본적으로 최적해가 될 가능성이 없는 답의 수를 줄이는 것을 목표로 하고, 이것을 위한 최적화 기법들이 여러가지 있다.</p><ul><li>가지치기pruning 탐색 과정에서 최적해로 연결될 가능성이 없는 부분을 잘라낸다. 예를 들어, 탐색들의 최적해를 기억해두고 있을 때 현재 상태의 최적해가 지금까지 구해놓은 최적해보다 좋지 않다면 이 탐색은 더이상 진행하지 않아도 좋다.</ul><p>휴리스틱heuristic</p><ul><li><p>기준점과 조정 휴리스틱 자신이 알고 있는 수치로 임의의 기준선을 설정한 후, 적절하다고 생각하는 것에 맞게 결정하는것.</p><li><p>가용성 휴리스틱 사건의 가능성을 기억의 가용성에 근거해 추정하는 것. 즉, 기억에서 잘 떠오르는 대상에 대해 상대적으로 높은 평가를 내리는 것</p><li><p>대표성 휴리스틱 어떤 집합에 속하는 임의의 한 특징이 그 집합의 특성을 대표한다고 간주해 빈도와 확률을 판단하는 방법</p><li><p>감정 휴리스틱 어떤 사건이나 상황에 대해 판단을 할 경우 경험으로 형성된 감정에 따라 평가를 다르게 하는 것</p><li><p>메타 휴리스틱 발견법은 해결하려는 문제마다 각기의 특성에 맞추어 개발해야 하는데, 특정 문제가 갖는 정보에 크게 구속되지 않고 다양한 문제들에 적용가능한 상위수준의 발견적 기법이다.</p></ul><p>유전 알고리즘, 담금질 기법, 타부 서치가 있다.</p><blockquote><p>드로잉</p></blockquote><p>“캐릭터”를 그린다는 것은 무언가 인물을 그리는 것이 아니라 실제로 의미 그대로 “어떤 성격”을 시각적으로 표현함을 의미한다. 사람의 성격은 너무 복잡하기 때문에 우리 인간은 대상을 관념화해서 “쟤는 소심한 애야, 과격한 애야, 나쁜 애야”라고 단순하게 생각하는데, 이를 그림으로 나타낸 것이 바로 캐릭터이다. 이 캐릭터의 성장기부터 하는 행동을 다 설명할 순 없으니 직관적으로 알아볼 수 있도록 만들어야 하는 것이다.</p><p>그림을 그릴땐 모사(모작)부터 시작해야 하는데, 그 이유는 자신의 눈 앞에 있는것도 그릴 수 없는데 자신의 머리속에 있는 것은 그릴 수 없기 때문이다. 모사를 할 때의 방법은</p><ol><li>수직/수평선 어딘가에 수직/수평선을 그리면 그곳을 기준으로 어디가 더 들어갔는지, 나와있는지, 비율과 대략적인 위치를 더 정확히 가늠할 수 있기 때문에 유용하게 사용될 수 있다. 가끔 창작물에 나오는 화가가 연필을 세로나 가로로 세워서 보는 것이 이것을 하는 작업이다.<li>격자 어떤 하나의 큰 그림을 그린다고 할때 이 그림은 한번에 그리는 것이 거의 불가능하니 격자로 부분을 나눠서 부분들을 그리다 보면 전체가 완성되는 것이다. 그래서 모사할 대상과 그릴 그림을 실제로 선으로 된 격자로 나눠 부분을 그리면 더 정확하게 그릴 수 있다.<li>실루엣 안쪽이 아닌 바깥쪽을 보는 것, 무엇의 윤곽을 보는 것이다. 그러니 그리려는 대상의 전경을 그리는 것이 전체적인 틀을 잡기 더 쉬워진다.<li>변상증 인간은 의미없는 것에 의미를 부여하기를 좋아한다. 왜냐면 알수 없는 개체가 나타났을 때 우리는 위협에 대비해야 하기 때문이다. 이를 응용하여 그림을 그릴때 부분들이 “무언가를 닮았다” 라고 생각하여 그리다 보면 이 부분들이 모여 하나의 완성된 그림이 된다.</ol><p>그림을 그릴 때, 특히 사람과 같은 복잡한 것을 그릴때는 그것에 대해 이미 가지고 있는 지식때문에 그림을 그리기가 힘든데, 그래서 대상을 대상으로 바라보지 않는, 그저 빛과 어둠(검고 흰것)으로 이루어진 도형이라고 인식하는 연습이 필요하다.</p><p>위의 4가지 방법은 익숙해지면 실제로 수직/수평선을 그리거나 하지 않아도 자연스럽게 머리속에서 그려지게 된다.</p><p>참고로 요약자의 경우 1년정도 취미로 모작을 했었는데, 단순 취미의 영역이라면 많이 하면 이 부분은 자연스럽게 가능해질 것이라 생각한다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/develop/'>Develop</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/other/" class="post-tag no-text-decoration" >Other</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=지식 스크랩 - Sigening&amp;url=https://termsigening97.github.io/posts/Scraps/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=지식 스크랩 - Sigening&amp;u=https://termsigening97.github.io/posts/Scraps/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://termsigening97.github.io/posts/Scraps/&amp;text=지식 스크랩 - Sigening" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/unity-optimization/">유니티 그래픽스 최적화</a><li><a href="/posts/Scraps/">지식 스크랩</a><li><a href="/posts/data-structure-and-algorithms/">자료구조와 알고리즘</a><li><a href="/posts/C-lecture/">C언어 총정리</a><li><a href="/posts/game-design/">게임 디자인</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cpp/">CPP</a> <a class="post-tag" href="/tags/essence/">Essence</a> <a class="post-tag" href="/tags/game-design/">Game Design</a> <a class="post-tag" href="/tags/architect/">Architect</a> <a class="post-tag" href="/tags/optimize/">Optimize</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/unity-optimization/"><div class="card-body"> <em class="timeago small" data-ts="1652331600" > 2022-05-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>유니티 그래픽스 최적화</h3><div class="text-muted small"><p> 2종류의 드로우콜 드로우콜이란 CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것이다. GPU는 이 드로우콜 명령에 해당하는 상태 정보 테이블을 가지고 있으며, 텍스처/쉐이더/버텍스 등을 무엇을 사용할 지 결정하게 해준다. 단, 처음 그린 후에 변경되지 않은 내용은 자동으로 호출하지 않는다. 유니티에는 이 드로우콜이 두종류가 존재한다. Bat...</p></div></div></a></div><div class="card"> <a href="/posts/algorithmic-paradigm/"><div class="card-body"> <em class="timeago small" data-ts="1648825200" > 2022-04-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>알고리즘 패러다임</h3><div class="text-muted small"><p> 알고리즘 패러다임 알고리즘 패러다임(Algorithmic Paradigm) 혹은 알고리즘 디자인 패러다임은 자주 등장하는 알고리즘 접근법을 의미하며, 여러 문제에 통상적으로 사용될 수 있습니다. 이 게시글을 이해하기 위해서는 일반적인 자료구조와 재귀함수를 응용할 수 있어야 함을 알립니다. 완전탐색 브루트 포스(Brute Force) 알고리즘이며,...</p></div></div></a></div><div class="card"> <a href="/posts/BOJ-2481/"><div class="card-body"> <em class="timeago small" data-ts="1647858180" > 2022-03-21 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[BOJ] 2481 해밍 경로</h3><div class="text-muted small"><p> KOI 2010 M3 이 문제를 풀기 위해서는 각 이진수들끼리의 서로 다른 비트의 개수를 구한 다음, 해밍 경로가 되는 이진수끼리 연결한 그래프를 만들어 BFS를 이용해 1번 이진수까지의 경로를 구해야 합니다. 입력 처리 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;map...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/algorithmic-paradigm/" class="btn btn-outline-primary" prompt="Older"><p>알고리즘 패러다임</p></a> <a href="/posts/unity-optimization/" class="btn btn-outline-primary" prompt="Newer"><p>유니티 그래픽스 최적화</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "termsigening97/termsigening97.github.io", "data-repo-id": "R_kgDOG6QKqw", "data-category": "Announcements", "data-category-id": "DIC_kwDOG6QKq84CBWWc", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/termsigening97">Jun Hwi Gu</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cpp/">CPP</a> <a class="post-tag" href="/tags/essence/">Essence</a> <a class="post-tag" href="/tags/game-design/">Game Design</a> <a class="post-tag" href="/tags/architect/">Architect</a> <a class="post-tag" href="/tags/optimize/">Optimize</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
