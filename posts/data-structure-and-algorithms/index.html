<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="자료구조와 알고리즘" /><meta property="og:locale" content="ko" /><meta name="description" content="Introduction to Data Structure" /><meta property="og:description" content="Introduction to Data Structure" /><link rel="canonical" href="https://termsigening97.github.io/posts/data-structure-and-algorithms/" /><meta property="og:url" content="https://termsigening97.github.io/posts/data-structure-and-algorithms/" /><meta property="og:site_name" content="Sigening" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-27T12:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="자료구조와 알고리즘" /><meta name="twitter:site" content="@termsigening97" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-09T16:49:36+09:00","datePublished":"2022-01-27T12:00:00+09:00","description":"Introduction to Data Structure","headline":"자료구조와 알고리즘","mainEntityOfPage":{"@type":"WebPage","@id":"https://termsigening97.github.io/posts/data-structure-and-algorithms/"},"url":"https://termsigening97.github.io/posts/data-structure-and-algorithms/"}</script><title>자료구조와 알고리즘 | Sigening</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sigening"><meta name="application-name" content="Sigening"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/Profile.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sigening</a></div><div class="site-subtitle font-italic">Game Dev</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/termsigening97" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/termsigening97" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['termsigening97','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>자료구조와 알고리즘</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>자료구조와 알고리즘</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/termsigening97">Jun Hwi Gu</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1643252400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-01-27 </em> </span> <span> Updated <em class="timeago" data-ts="1649490576" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-09 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="14196 words"> <em>78 min</em> read</span></div></div></div><div class="post-content"><blockquote><p><strong>Introduction to Data Structure</strong></p></blockquote><p>코딩을 조금 하고 나면 프로그래밍은 데이터를 주로 다룬다는 것을 알 수 있습니다. 컴퓨터 프로그램은 데이터를 입력받고, 조작하고, 반환하는 게 끝입니다. “Hello, World” 라는 문자열과 숫자들이 바로 데이터이죠. 자료구조는 이런 데이터들을 조직하는 방법이며, 코드의 실행 속도에 영향을 미칩니다. 데이터를 어떻게 조직하는지에 따라 프로그램이 수백 수천배보다도 더 빠르거나 느리게 실행될 수 있기 때문이죠.</p><p>즉, 자료구조는 데이터를 저장하고 정리하여 접근과 수정을 가능하게 해주는 것으로 자료구조는 모든 목적에 적합할 수 없기 때문에 장점과 한계들을 아는 것이 중요합니다.</p><h2 id="자료구조의-연산"><span class="mr-2">자료구조의 연산</span><a href="#자료구조의-연산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>대부분의 자료구조는 코드와 자료구조가 상호작용하기 위해 네 가지 기본 방법을 사용하는데, 이를 연산 이라고 부릅니다.</p><ul><li><p>읽기 : 자료 구조 내 특정 위치의 데이터를 가져오는 것입니다.</p><li><p>검색 : 자료 구조 내에서 특정 값을 찾는 것입니다.</p><li><p>삽입 : 자료 구조에 새로운 값을 추가하는 것입니다.</p><li><p>삭제 : 자료 구조에서 값을 제거하는 것입니다.</p></ul><p>여기서 이 연산들이 얼마나 “빠른지” 측정하기 위해서는 시간 관점에서 연산이 빠른지가 아니라 얼마나 많은 단계가 필요한지를 보아야 합니다. 그 이유는, 어떤 연산이 정확히 몇 초가 걸린다고 할 수 없기 때문입니다. 같은 연산도 성능 좋은 컴퓨터에서는 더 빠르고, 반대의 경우 더 느릴 수 있기 때문이죠. 예를들어 연산 A에 5단계가 필요하고 연산 B에 500단계가 필요하면 모든 하드웨어에서 연산 A가 연산 B보다 항상 빠를 것을 알 수 있습니다.</p><h2 id="배열array"><span class="mr-2">배열Array</span><a href="#배열array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>배열은 단순히 데이터 원소들의 리스트입니다. 예를들어 다음과 같은 배열은 요일의 이름을 나타내죠.</p><p><code class="language-plaintext highlighter-rouge">weeks = ["mon", "tue", "wed", "thr", "fri", "sat", "sun"]</code></p><p>배열의 인덱스(번호)는 특정 데이터가 배열의 어디에 있는지 알려주는 숫자입니다. 대부분의 프로그래밍 언어에서 인덱스는 0부터 시작합니다. “mon”은 인덱스 0에 위치하고 “sun”은 인덱스 6에 위치합니다.</p><p>이제 이 배열에 대한 <strong>연산</strong> 들의 단계와 방법들을 알아보도록 하겠습니다.</p><h3 id="배열의-읽기"><span class="mr-2">배열의 읽기</span><a href="#배열의-읽기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>배열에서의 읽기란 특정 인덱스에 어떤 값이 들어있는 지 찾아보는 것입니다. 읽기의 단계는 딱 한 단계인데, 컴퓨터는 배열 내의 특정 인덱스에 한번에 접근해서 볼 수 있기 때문입니다.</p><p>이게 왜 가능한지 알기 위해서는 메모리 구조에 대해서 알아야 하는데, 메모리는 일정 간격으로 나뉜 셀들로 이루어져 있는 공간이라고 생각할 수 있습니다. 프로그램에서 배열을 선언하면 연속된 빈 셀들의 집합을 할당합니다. 위쪽의 <code class="language-plaintext highlighter-rouge">weeks</code> 배열을 예로 들면, 7개의 값이 들어가기 위한 7개의 연속된 빈 셀들이 있는 위치를 찾아 배열로 지정합니다.</p><p>그리고, 컴퓨터 메모리 내의 각 셀에는 숫자로 이루어진 주소가 존재합니다. 편의를 위해 간단하게 설명하자면, 첫번째 셀의 주소가 0일때, 그 뒤의 주소는 1, 2, 3, 4… 이렇게 1씩 증가합니다. 그래서 만약에 배열의 시작 주소를 알 수 있으면, 시작한 위치부터 3칸 뒤의 주소가 바로 네 번째 데이터의 값(<code class="language-plaintext highlighter-rouge">"thr"</code>)이기 때문에, 한 번의 단계로 끝나는 것이죠. 이게 바로 인덱스가 0부터 시작하는 이유입니다. 참, 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있습니다.</p><h3 id="배열의-검색"><span class="mr-2">배열의 검색</span><a href="#배열의-검색" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>배열에서 특정 값을 찾기 위해서는, 인덱스 0부터 시작해서 차례로 읽기 연산을 하고, 찾던 값이 아니면 다음 인덱스로 넘어가 찾을 때까지 이를 반복합니다. 예를 들어 <code class="language-plaintext highlighter-rouge">weeks</code> 배열에서 <code class="language-plaintext highlighter-rouge">"wed"</code> 를 찾기 위해서는 0번째 -&gt; 1번째 -&gt; 2번째 만큼 움직여야지만 알 수 있으므로 총 3단계가 걸렸습니다. 우리는 눈으로 보고 바로 알 수 있지만 컴퓨터에는 눈이 없기 때문에 이렇게 할 수밖에 없죠.</p><p>이와 같이 한번에 하나씩 확인하는 검색 연산을 <strong>선형 검색</strong> 이라고 합니다. 그럼 이 때 최대 단계 수는 어떻게 될까요? 간단하게 배열의 길이가 N이라면 N개의 단계가 필요하다고 할 수 있습니다.</p><h3 id="배열의-삽입"><span class="mr-2">배열의 삽입</span><a href="#배열의-삽입" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>배열에서 삽입을 할 때, 맨 마지막에 삽입한다면 그냥 배열의 맨 뒤에 추가하면 되기 때문에 한 단계만 필요하지만, 만약 중간 어딘가에 삽입한다면, 데이터를 삽입하고 원래 있던 데이터부터 끝에 있는 데이터까지는 전부 한 칸씩 뒤로 이동시켜 줘야 하기 때문에 많은 단계가 필요합니다. 각 데이터가 사람들이 서있는 줄이라고 할 때, 줄 중간에 들어가려면 사람들이 전부 뒤로 한칸씩 비켜줘야 하는 것을 생각할 수 있습니다.</p><p>이 경우에도 최대 단계, 즉 최악의 경우에 N개의 단계가 필요합니다. 맨 앞에 데이터를 삽입하려면 모든 데이터가 뒤로 한칸씩 움직여야 하기 때문이죠.</p><h3 id="배열의-삭제"><span class="mr-2">배열의 삭제</span><a href="#배열의-삭제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>삭제 또한 삽입과 똑같습니다. 중간에 데이터를 삭제하면, 삭제한 곳부터 뒤에있는 모든 데이터는 모두 앞으로 한 칸씩 이동시켜 줘야 하기 때문이죠.</p><blockquote><p><strong>Introduction to Algorithm</strong></p></blockquote><p>알고리즘이란, 단순히 어떤 문제를 해결하는 절차입니다. 예를 들어 유튜브를 보는 알고리즘은 다음과 같습니다.</p><ol><li>웹브라우저를 연다<li>youtube.com에 접속한다<li>원하는 영상을 검색한다<li>영상을 클릭해서 시청한다</ol><p>컴퓨팅에서의 알고리즘도 이와 같이 특정 연산의 해결을 위핸 절차입니다. 자료구조에서 읽기, 검색, 삽입, 삭제를 위한 절차도 알고리즘이죠. 이 알고리즘을 어떻게 작성하냐에 따라 코드가 매우 빠르게 실행되기도, 느리게 실행되기도 합니다. 그럼 알고리즘의 예제를 살펴보도록 합시다.</p><blockquote><p>기술적인 의미의 알고리즘</p></blockquote><p>컴퓨터가 무제한의 속도를 가지고 있고 메모리가 무비용이라고 해도 그래도 아직 알고리즘이 필요할까요? 그렇습니다. 메모리가 무비용이라도 개발한 기능이 올바른 답과 함께 종료되길 원할 것이고, 컴퓨터가 무제한의 속도였다면 아무 알고리즘이나 사용할 수 있겠지만 소프트웨어 공학적으로 잘 작성, 기술되어지길 원할 것이기 때문입니다.</p><h2 id="정렬된-배열"><span class="mr-2">정렬된 배열</span><a href="#정렬된-배열" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>배열인데, 숫자가 순서대로 정렬되어있어야 하는 자료구조를 생각해봅시다. 그러면 삽입 연산을 할 때마다 검색 연산이 필요하게 됩니다. 예를들어 아래와 같은 값들이 들어있는 배열이라 할때 <code class="language-plaintext highlighter-rouge">[10, 20, 40, 50]</code> 여기에 30을 삽입하기 위해서는, 우선 30보다 큰 값<code class="language-plaintext highlighter-rouge">(40)</code>을 검색하고 해당 위치에 삽입하게 됩니다. 그러면 40, 50은 전부 오른쪽으로 한칸씩 이동해야 해고 생긴 자리에 30을 넣을 수 있게 되는 것이죠. <code class="language-plaintext highlighter-rouge">[10, 20, 30, 40, 50]</code></p><p>여기까지만 보면 쓸데없이 정렬한다고 생각될 수 있습니다. 하지만 정렬된 배열의 진가는 <strong>탐색</strong> 연산에서 드러납니다.</p><h2 id="이진-검색"><span class="mr-2">이진 검색</span><a href="#이진-검색" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><em>배열의 검색</em> 에서 사용된 방법은 선형 검색이었습니다. 첫번째 원소부터 끝번째 원소까지 전부 차례대로 확인하는 것이죠. 하지만 만약 배열이 정렬되어 있다면, <strong>이진 검색</strong>을 사용할 수 있습니다.</p><p>방법은 간단합니다. 예를들어 <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> 가 배열에 있다고 할 때, 9를 찾는다고 합시다. 그럼 우선 중간 인덱스<code class="language-plaintext highlighter-rouge">(0+9/2 = 4)</code> 에 있는 값<code class="language-plaintext highlighter-rouge">(5)</code> 을 봅시다. 9는 5보다 크니까 이제 <strong>인덱스 4부터 인덱스 9</strong> 의 중간 인덱스<code class="language-plaintext highlighter-rouge">(4+9/2 = 6)</code>의 값<code class="language-plaintext highlighter-rouge">(7)</code>을 봅시다. 9는 7보다 크니까 이제 <strong>인덱스 7부터 인덱스 9</strong> 의 중간 인덱스<code class="language-plaintext highlighter-rouge">(7+9/2 = 8)</code>의 값<code class="language-plaintext highlighter-rouge">(9)</code>를 봅시다. 찾았네요!</p><p>선형 검색으로 처리했다면 9단계가 걸렸겠지만, 이진 검색으로는 3단계만 필요했습니다. 이는 숫자가 커지면 더 극적으로 차이가 벌어지는데, 원소가 10,000개인 배열에서 선형 검색은 최대 10,000단계가 필요하지만, 이진 검색은 13단계면 충분합니다. 왜냐면 이진 검색은 <strong>데이터를 두 배로 늘릴 때마다 단계가 최대 하나씩만</strong> 추가되기 때문인데, 이것을 두고 우리는 로그 형태의 단계가 들어간다고 합니다.</p><p>만약 코딩 문법을 알고 있다면, C언어로 표현된 이진 탐색의 코드는 다음과 같습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">binary_search</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">array_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">lower_bound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">array_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">lower_bound</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower_bound</span> <span class="o">+</span> <span class="n">upper_bound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
      <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
      <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// 결과 인덱스를 반환</span>
  <span class="p">}</span>

  <span class="c1">// while문 내에서 return되지 않았다면 값이 없는것이기 때문에 없다는 표시로 -1을 반환</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>물론 그렇다고 우리가 정렬된 배열만 쓸 필요는 없습니다. 검색이 많이 필요한 상황이라면 정렬된 배열이 좋겠지만, 검색을 쓰지 않는 상황이라면 굳이 삽입 때 시간을 소모하지 않는 일반 배열을 쓰는 게 더 효율적이기 때문이죠. 그래서 자료구조들은 상황에 맞게 적재적소에 사용된다고 생각하시면 됩니다.</p><h2 id="빅-오-표기법"><span class="mr-2">빅-오 표기법</span><a href="#빅-오-표기법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>우리가 어떤 알고리즘(자료구조의 연산 등) 의 효율성을 나타낼 때, 얘는 2000단계가 필요해요! 라고 말하지 않습니다. 전문적이지 않을 뿐더러, 상황에 따라 필요한 단계가 다르기 때문에 빅-오 표기법을 사용해서 “배열에 N개의 원소가 있을 때 선형 검색에 N단계가 필요합니다” 라는것을 “이 알고리즘는 <strong><em>O(N)</em></strong>” 이다. 와 같이 나타냅니다. 시간복잡도가 O(N) 이라고 하기도 하죠.</p><p>어 그런데, 만약 내가 <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5]</code> 가 들어있는 배열에서 1을 검색할 때는 한 단계만 필요한데 N단계가 아니잖아요! 라고 할 수 있습니다. 네, 빅-오 표기법은 <strong>최악의 상황</strong> 을 가정해서 표기하게 됩니다. 최악을 대비함과 동시에 알고리즘 선택에 중요한 영향을 미치기 때문이죠. 물론, 평균적인 성능을 나타내기도 하지만 빅-오 표기를 어떻게 하는지와 그 종류에 대해서 알아보록 합시다.</p><h3 id="상수-시간"><span class="mr-2">상수 시간</span><a href="#상수-시간" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong><em>O(1)</em></strong> 이라고 표기하며, 데이터가 얼마나 많든 상관없이 고정적인 단계를 가질 경우를 나타냅니다. 예를 들어, 배열에서 읽기는 O(1)입니다. 언제나 한 단계만 필요하기 때문이죠. 하지만 만약 10,000 단계가 필요했다고 해도 O(1)으로 표기합니다.</p><h3 id="선형-시간"><span class="mr-2">선형 시간</span><a href="#선형-시간" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong><em>O(N)</em></strong> 이라고 표기하며, 데이터의 개수만큼 단계가 늘어남을 나타냅니다. 그래프로 그리면 완벽한 대각선(일차방정식)이 나오기 때문에 “선형 시간” 이라고 부릅니다.</p><h3 id="로그-시간"><span class="mr-2">로그 시간</span><a href="#로그-시간" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong><em>O(log N)</em></strong> 이라고 표현합니다. 여기서 log의 <strong>밑</strong>은 2입니다. 이게 무슨 뜻이냐면, “2를 몇제곱해야 N이 되는가?” 입니다. 예를들어 log8 = 3 입니다. 2의 3승이 8이기 때문이죠. 하지만 수학문제가 아니기 때문에 대략 “2로 몇번 나눠야 1이 되는가?” 라고 생각하셔도 좋습니다.</p><p>이 외에도 지수시간<code class="language-plaintext highlighter-rouge">O(N^2)</code> (N의 제곱) 등이 존재하지만, 보시면 아실 수 있습니다.</p><h3 id="빅-오의-특징"><span class="mr-2">빅-오의 특징</span><a href="#빅-오의-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>여기서 빅-오의 특징으로, 빅-오에서는 상수를 무시해줍니다. 예를 들어 어떤 알고리즘의 시간복잡도가 <code class="language-plaintext highlighter-rouge">O(N^2)</code> 이고 여기에 100단계정도가 더 추가되더라도 그대로 <code class="language-plaintext highlighter-rouge">O(N^2)</code> 입니다. N의 값이 한없이 커짐에 따라 100은 의미가 없어지기 때문이죠.</p><p>같은 이유로, 다항 시간<code class="language-plaintext highlighter-rouge">ex) N^3 + N^2 + N</code> 인 알고리즘의 경우 <strong>가장 높은 차수</strong> 만이 빅-오에 표시됩니다. 그래서 위같은 알고리즘의 빅-오 표기는 <code class="language-plaintext highlighter-rouge">O(N^3)</code> 이 됩니다. 이는 상수와 같은 이유로 N의 값이 한없이 커지면 N^3의 변화율을 N^2나 N이 따라오지 못하기 때문이죠. 이해가 잘 안되신다면, 정렬 알고리즘에 대해 공부해보면서 익혀봅시다.</p><h2 id="on2인-정렬-알고리즘"><span class="mr-2">O(N^2)인 정렬 알고리즘</span><a href="#on2인-정렬-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>정렬</strong> 은 프로그래밍에 있어서 매우 자주 사용되는 알고리즘이며, 그로인해 다양한 알고리즘들이 존재합니다. 여기서는 간단한 기초 알고리즘인 “버블 정렬” 과 “삽입 정렬” 에 대해서만 알려드리겠습니다.</p><h3 id="버블-정렬"><span class="mr-2">버블 정렬</span><a href="#버블-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>배열의 처음부터 배열의 길이 - 1 까지 연속된 두 원소를 비교해서, 만약에 오른쪽의 수가 더 작으면 두 수의 위치를 교환합니다. 예를들어 <code class="language-plaintext highlighter-rouge">[ 3, 2, 1 ]</code> 을 정렬한다면 인덱스 0과 1의 원소인 <code class="language-plaintext highlighter-rouge">3</code> 과 <code class="language-plaintext highlighter-rouge">2</code> 를 비교합니다. <code class="language-plaintext highlighter-rouge">2</code>가 더 작으니 위치를 교환합니다. <code class="language-plaintext highlighter-rouge">[ 2, 3, 1 ]</code> 이제 인덱스 1과 2를 비교하면 <code class="language-plaintext highlighter-rouge">3</code> 과 <code class="language-plaintext highlighter-rouge">1</code> 중 1이 더 작으니 위치를 교환합니다. <code class="language-plaintext highlighter-rouge">[ 2, 1, 3 ]</code>. 이 작업을 <strong>배열의 길이 - 1</strong> 만큼 반복하면 됩니다. 왜냐면 최악의 경우 맨 오른쪽의 값이 맨 왼쪽까지 오려면 배열의 길이 - 1 만큼 이동해야 하기 때문이죠.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</pre></table></code></div></div><p>버블 정렬은 (N-1)^2 + N 의 단계가 필요합니다. 빅-오로 표기하면 <strong><em>O(N^2)</em></strong> 가 됩니다. -1은 N이 한없이 커질수록 값의 차이가 미미해지기 때문에, 빅-오에서 상수는 전부 무시해줍니다. 같은 이유로, N^2 + N 에서도 N=100 만 되어도 10000 + 100 이라는 100:1 이라는 큰 차이이기 때문에 빅-오에서는 가장 높은 차수만 사용해줍니다.</p><p><strong>[?]</strong> 혹시 “값의 교환은 왜 단계로 쳐주지 않나요?” 라는 의문점이 들었다면, 값의 교환 또한 단계가 있는 것은 맞지만 그것을 포함하더라도 많아야 <code class="language-plaintext highlighter-rouge">2 * N^2</code> 정도기 때문에 상수는 무시된 것입니다. 빅-오는 코드의 <strong>반복문의 반복횟수</strong> 로 계산해주면 됩니다.</p><p><strong>[?]</strong> 만약 버블정렬에서 한번 반복할 때마다 끝에서부터 값이 하나씩 정렬이 완료된다는 사실을 눈치채셨다면, 맞습니다. 하지만 O(N^2) 를 좀 더 효과적으로 설명해드리기 위해 여기서는 일부러 생략하였습니다.</p><h3 id="선택-정렬"><span class="mr-2">선택 정렬</span><a href="#선택-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>선택 정렬은 사실 버블 정렬보다 간단합니다. 일단 처음 인덱스부터 시작합니다. 그 다음 인덱스부터 배열의 끝까지 검색하면서 최솟값을 찾습니다. 검색이 끝나면, 처음 인덱스와 찾은 최솟값의 위치를 교환해줍니다. 예를 들어, 배열이 <code class="language-plaintext highlighter-rouge">[ 5, 2, 1, 4, 3 ]</code> 가 있었다면, 처음부터 끝까지 반복하면 최솟값의 인덱스는 <strong>2</strong>이라고 알 수 있습니다. 그럼 인덱스 0과 교환해주면 배열은 다음과 같이 됩니다. <code class="language-plaintext highlighter-rouge">[ 1, 2, 5, 4, 3 ]</code> 이 이후에는 인덱스 1부터 끝까지, 그 다음에는 인덱스 2부터 끝까지… 그러면 검색을 할 때마다 보아야 하는 원소의 개수가 하나씩 감소하는 것을 알 수 있습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">minidx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">minidx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
      <span class="n">minidx</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">minidx</span><span class="p">];</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">minidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</pre></table></code></div></div><p>그래서 총 <code class="language-plaintext highlighter-rouge">O(N^2 / 2)</code> 가 되어야 할 것 같은데… 상수를 무시해주기 때문에 이 또한 <code class="language-plaintext highlighter-rouge">O(N^2)</code> 가 됩니다. 여기서 더 알아야 하는 점은, 이와 같은 이유 때문에 같은 시간복잡도의 알고리즘이라도 데이터의 상황에 따라, 알고리즘의 효율은 다를 수 있다는 점입니다. 만약 <code class="language-plaintext highlighter-rouge">O(N^2)</code> 과 <code class="language-plaintext highlighter-rouge">O(N)</code> 알고리즘 중에서 선택하라면 당연히 O(N)을 선택하는 것이 좋지만, 같은 <code class="language-plaintext highlighter-rouge">O(N)</code> 이라면 효율성 분석을 좀 더 자세히 하는 것이 좋습니다.</p><h3 id="삽입-정렬"><span class="mr-2">삽입 정렬</span><a href="#삽입-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>인덱스 1부터 시작하는데, 자신의 값을 임시변수에 저장해놓고, 0번째 인덱스까지 비교하며 만약 임시변수의 값보다 크다면 오른쪽으로 이동해줍니다. 그러다 만약 임시 변수의 값보다 작은 값을 만나면 그 다음 인덱스에서 멈춰줍니다. 글로 읽기에는 복잡할 수 있으니 한번 예시를 보여드리죠.</p><p><code class="language-plaintext highlighter-rouge">[3, 2, 1, 5, 4]</code> 가 있을 때, 임시변수에 인덱스 1의 값을 저장합니다. <code class="language-plaintext highlighter-rouge">tmp = 2</code> 그 후, 인덱스 0의 값을 보았더니 임시변수의 2보다 크기 때문에 오른쪽으로 이동해줍니다 <code class="language-plaintext highlighter-rouge">[3, 3, 1, 5, 4]</code> 어짜피 덮어씌워질테니 오른쪽으로 대입만 해도 괜찮습니다 인덱스의 마지막(0) 에 도달했기 때문에 임시변수의 값을 넣습니다</p><p><code class="language-plaintext highlighter-rouge">[2, 3, 1, 5, 4]</code> 임시변수에 인덱스 2의 값을 저장합니다. <code class="language-plaintext highlighter-rouge">tmp = 1</code> 그 후, 비교를 하니 임시변수의 1보다 크기 때문에 오른쪽으로 이동해줍니다 <code class="language-plaintext highlighter-rouge">[2, 3, 3, 5, 4]</code> 그 후, 인덱스 0과 비교를 하니 1보다 크기 때문에 오른쪽으로 이동해줍니다 <code class="language-plaintext highlighter-rouge">[2, 2, 3, 5, 4]</code> 인덱스의 마지막(0) 에 도달했기 때문에 임시변수의 값을 넣습니다 <code class="language-plaintext highlighter-rouge">[1, 2, 3, 5, 4]</code></p><p>이와 같은 과정을 끝까지 반복해주면 정렬이 완료됩니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">pos</span><span class="o">--</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

  <span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이제 지금까지와는 다르게 코드 하나하나의 단계를 자세히 살펴봅시다. 삽입 정렬은 최악의 경우에 N^2 / 2 번의 비교와 이동이 일어나므로 N^2 단계가 필요합니다. 임시변수에 값을 저장하고 다시 배열에 값을 삽입하는 횟수는 각각 N - 1번이므로 2N - 2 단계가 필요합니다. 그래서 총 <strong>N^2 + 2N - 2</strong> 단계가 필요하게 됩니다. 빅-오는 가장 높은 차수만 고려하고, 상수를 무시하기 때문에 <strong>O(N^2)</strong> 라고 할 수 있죠.</p><h3 id="최선-최악-평균"><span class="mr-2">최선, 최악, 평균</span><a href="#최선-최악-평균" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>여기까지만 보면 버블, 선택, 삽입 정렬중에서 선택 정렬이 가장 빨라보입니다. 최악의 경우에는 확실히 선택 정렬이 제일 빠르죠. 하지만 <strong>평균적인 경우</strong> 에서는 다릅니다. 왜냐하면 삽입 정렬은 최악의 경우(예를 들어 내림차순인 데이터를 오름차순으로 정렬할때) 모든 데이터를 비교&amp;이동하지만 평균적인 경우(적당히 무작위인 숫자인 경우) 데이터의 절반정도만 비교해도 정렬이 완료될 것이기 때문이죠.</p><p>선택 정렬의 경우 최선, 평균, 최악의 경우 모두 동일하게 <strong>O(N^2/2)</strong> 의 시간복잡도를 가집니다. 정렬이 되어있던 아니던 모두 비교해야하기 때문이죠. 하지만 삽입 정렬의 경우 최악에 <strong>O(N^2)</strong>, 평균에 <strong>O(N^2 / 2)</strong>, 최선에 <strong>O(N)</strong> 의 시간이 걸립니다. 데이터가 이미 정렬되어 있는 경우 반복을 도중에 종료할 수 있기 때문이죠.</p><p>이것은 각 알고리즘에 대해 더 깊은 고찰의 여지를 남기는 내용이지만, 또한 알고리즘을 작성할 때에 “가능하면 도중에 종료한다” 와 같이 일반적인 수행을 고려한 내용을 넣어 주어야 한다는 말이기도 합니다. 예를 들어, 정렬 알고리즘의 각 반복마다 배열이 정렬되었는지 확인하고, 정렬되었다면 나가는 코드를 작성한다면 “일반적으로 정렬된 데이터가 들어오는” 상황에서 알고리즘을 <strong>O(N)</strong> 으로 단축시킬 수도 있게 되는 것이죠.</p><p>결론적으로, 우리는 어떤 알고리즘의 <strong>최선, 최악, 평균</strong> 의 경우를 모두 따져봐야 한다고 할 수 있습니다.</p><h2 id="해시-테이블"><span class="mr-2">해시 테이블</span><a href="#해시-테이블" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>해시 테이블은 배열과 비슷하지만, 인덱스가 0부터 시작하는 숫자가 아닌 특별한 문자열이 사용될 수 있다는 점이 다릅니다. 그래서 특정 값을 볼 때 매우 빠르게 볼 수 있죠.</p><p>예를들어, 사이트나 게임에서 아이디와 비밀번호를 입력하고 로그인하려 할 때 시스템에서 만약 배열을 사용한다면, 배열에서 아이디를 검색해서 해당 아이디에 저장된 비밀번호와 사용자가 입력한 비밀번호가 같은지 확인해야 할 겁니다. 이 과정마다 검색이 필요한데, 해시 테이블은 이 과정을 O(1) 만에 해결할 수 있습니다.</p><p>이게 가능한 방법은 해시 함수를 사용하기 때문인데, 이는 문자열을 하나의 숫자로 변환하는 것이라 할 수 있습니다. 예를들어, A=1, B=2, C=3… 라고 한다면, “DAC” 라는 문자열은 413 이라고 할 수 있습니다. 여기서 이 413에 4 * 1 * 3 과 같은 작업을 하면 “DAC”의 해시 값은 12가 됩니다. 이는 해시 함수의 한 예일 뿐이고, 실제로는 더 복잡한 식이 사용됩니다.</p><p>해시 함수가 유효하기 위해서는 동일한 문자열을 해시 함수에 적용할 때마다 항상 <strong>동일한 숫자</strong> 로 변환되어야 하는 조건을 가지고 있습니다. 일관적이어야 한다는 것이죠. 그런데 “CAD” 또한 3 * 1 * 4 로 12가 나와 해시 값에 <strong>충돌</strong> 이 있다는 것을 알 수 있습니다. 이는 잠시 후에 알아보도록 하죠.</p><p>그럼 이제 해시 함수에 대해 알아보았으니, 해시 테이블이 어떻게 작동되는지 봅시다. 배열과 비슷하게 해시 테이블에 값은 다음과 같이 삽입합니다. <code class="language-plaintext highlighter-rouge">dictionary["ABC"] = "Hello"</code> 여기서 인덱스로 사용된 “ABC” 를 <strong>키(Key)</strong>, 안에 들어간 “Hello”를 <strong>값(Value)</strong> 라고 합니다. 그러면 이는 dictionary 라는 해시 테이블의 “ABC” 번째, 즉 1 * 2 * 3 = 6 번째 인덱스에 “Hello” 라는 값을 삽입하게 됩니다. 그럼 값을 꺼낼때는 <code class="language-plaintext highlighter-rouge">search = dictionary["ABC"]</code> 와 같이 할 수 있으며, 해시 테이블은 또한번 “ABC” 에 해시 함수를 적용시켜 6번째 인덱스의 “Hello” 값을 읽게 됩니다.</p><h3 id="해시-충돌-해결하기"><span class="mr-2">해시 충돌 해결하기</span><a href="#해시-충돌-해결하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>해시값의 충돌은 여러 방법으로 해결할 수 있지만, 여기서는 그 중 가장 간단하고 직관적인 방법을 알려드리겠습니다.</p><p>해시 테이블에 실제 값이 아니라 “참조 값” 을 저장하게 합니다. 그러니까, 해시 테이블의 각 인덱스에는 배열이 있고, 삽입 시에 해시 값의 충돌이 일어나면 인덱스 안의 배열에 추가해주는 것이죠. 그리고 충돌이 있는 해시 값을 읽어오려고 할 때는, 해당 인덱스의 배열을 검색해서 입력받은 키(Key) 값과 일치하는 것을 찾습니다. 이를 체이닝(chaining) 이라고 합니다.</p><blockquote class="prompt-info"><div><p>배열이 아니라 연결 리스트와 같은 자료 구조를 사용할 수도 있습니다.</p></div></blockquote><p>예를 들어 <code class="language-plaintext highlighter-rouge">dict["ABC"] = "Pencil"</code>, <code class="language-plaintext highlighter-rouge">dict["CBA"] = "Sun"</code> 이라고 한다면 6번째 인덱스에는 <code class="language-plaintext highlighter-rouge">["ABC" : "Pencil", "CBA" : "Sun"]</code> 과 같은 배열이 들어있게 됩니다. 여기서 <code class="language-plaintext highlighter-rouge">dict["CBA"]</code> 를 읽어오려고 한다면, 위의 배열에서 <code class="language-plaintext highlighter-rouge">"CBA"</code> 를 <strong>검색</strong> 해서 “Sun” 을 반환하는 것이죠.</p><p>하지만 이 경우, 해시 값의 충돌이 빈번하게 발생한다면 해시 테이블의 효율성이 떨어지게 됩니다. 그래서 가능하면 해시 테이블에 충돌이 없도록 해야합니다.</p><p>해시 테이블은 3가지 요인에 의해 효율성이 정해집니다.</p><ol><li>해시 테이블에 얼마나 많은 데이터를 저장하는가<li>해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가<li>어떤 해시 함수를 사용하는가</ol><p>해시 테이블에 관해서는 더 깊고 자세히 알아볼 수도 있지만, 대부분은 언어 차원에서 기능을 지원하기 때문에 여기서는 원리만 이해해도 괜찮습니다. 해시 테이블은 언어에 따라 해시, 맵, 해시 맵, 딕셔너리(사전), 연관 배열 등으로 불립니다.</p><h2 id="스택-큐"><span class="mr-2">스택, 큐</span><a href="#스택-큐" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p><strong>스택</strong></p></blockquote><p>스택(Stack) 은 배열과 같지만, 다음과 같은 규칙이 존재합니다.</p><p><strong>스택의 끝에서만 데이터를 읽기, 삽입, 삭제할 수 있다</strong></p><p>책이 쌓여있는 것을 생각할 수 있습니다. 맨 위의 책의 표지만 볼 수 있고, 맨 위에 책을 올려서 쌓거나(Stack) 맨 위에서 책을 빼갈 수 있기 때문이죠. 여기서 스택의 끝을 <strong><em>탑(top)</em></strong> 이라고 부릅니다. 그리고 스택에 삽입하는 것을 <strong>푸시(Push)</strong> 한다고 합니다.</p><p>스택은 LIFO(Last In First Out) 자료구조라고도 불리는데, “마지막에 들어간 게 먼저 나온다” 라는 후입선출의 형태를 가지고 있기 때문입니다.</p><p>스택은 이렇게만 보면 어디다 쓸지 막막하지만, 실제론 알고리즘에서 자주 활용됩니다. 예를 들어, 괄호쌍이 제대로 이루어져있는지 확인하거나 계산식을 후위형으로 바꾸기도 합니다.</p><p>괄호쌍을 예로 들면 <code class="language-plaintext highlighter-rouge">[(){()}]</code> 이란 괄호쌍이 올바르게 열리고 닫혔나 확인하기 위해서, 문자열의 인덱스 0부터 반복하며 <strong>왼쪽 괄호라면 푸시(Push) 하고 오른쪽 괄호라면 팝(Pop)</strong> 해주고, 팝해준 괄호가 오른쪽 괄호랑 같은 종류가 맞는지 확인해 주는 방법을 사용할 수 있습니다.</p><p>이 외에도 실행취소(Ctrl+Z) 나 이전에 방문한 사이트들을 저장하는 일 등에도 스택이 사용됩니다.</p><blockquote><p><strong>큐</strong></p></blockquote><p>큐(Queue) 또한 스택과 비슷한데, 이는 FIFO(First In First Out) 이라는 선입선출 형태를 가지고 있습니다. 대기열이라는 뜻을 가진 큐는 <strong>큐의 끝에서만 삽입할 수 있고, 큐의 앞에서만 읽고 삭제할 수 있다</strong> 라는 규칙을 가지고 있습니다. 큐에 값을 삭제/제거하는것은 언어마다 스택과 같이 Push/Pop 이라고 부르거나 Enqueue/Dequeue 라고 부르기도 하니 용어에 유의해주시기 바랍니다.</p><p>큐의 맨 앞은 <strong><em>프론트(Front)</em></strong> 라고 부르고, 맨 뒤는 <strong><em>리어(Rear)</em></strong> 라고 부릅니다. 큐는 좀 더 직관적으로 게임에서의 대기열 등 선착순의 개념이 존재하는 알고리즘들에서 사용됩니다.</p><h2 id="재귀-호출"><span class="mr-2">재귀 호출</span><a href="#재귀-호출" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>함수는 자기 자신을 호출해서 반복할 수 있습니다. 여기서 함수가 자기 자신을 호출하는 것을 <strong>재귀(recursion)</strong> 라고 하고, 이런 함수를 재귀 함수라고 합니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">print_something</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hello</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">print_something</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위 코드는 <code class="language-plaintext highlighter-rouge">"Hello"</code> 라는 문자열을 무한히 반복하며 출력합니다. 왜냐면 <code class="language-plaintext highlighter-rouge">print()</code> 함수가 자기 자신을 호출하고 있기 때문이죠. 그럼 자기가 자기를 호출하고… 이렇게 무한 반복이 되는겁니다. 그래서 보통은 반복문을 쓸 때와 비슷하게 나가는 조건과 값을 변화시킬 식을 포함합니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위 코드는 팩토리얼(5! = 5*4*3*2*1) 을 계산해주는 재귀함수입니다. 재귀호출을 할 때마다 n이 1씩 감소하고, n이 1이면 더이상 재귀호출을 하지 않아 재귀가 멈추고, 지금까지 계산된 식이 전부 실행되며 결과가 계산되죠. 여기서 재귀 호출을 멈추게 하는 조건을 <strong>기저 조건(base case)</strong> 라고 하며, 위 코드의 경우 <code class="language-plaintext highlighter-rouge">1</code> 이 기저 조건입니다.</p><p>재귀 함수를 사용해본 적이 없다면 위 코드가 읽기 난해할텐데, 재귀 함수를 쉽게 이해하는 방법이 존재합니다.</p><ol><li>기저 조건을 찾는다<li>기저 조건에 맞을 경우의 함수의 상태를 본다<li>기저 조건의 바로 전의 함수의 상태를 본다<li>계속 단계를 올려가며 함수의 상태를 본다</ol><p>위 코드를 예로 들면, n에 1이 들어있을 경우에 함수가 어떻게 되는지 봅니다. 1을 반환하네요. <code class="language-plaintext highlighter-rouge">fact(1) = 1</code> 이란 것을 알았습니다. 재귀 호출에서 <code class="language-plaintext highlighter-rouge">n - 1</code> 을 넘겨주고 있기 때문에, 다음에는 n이 2인 경우를 봅니다. <code class="language-plaintext highlighter-rouge">2 * fact(1)</code> 인데, <code class="language-plaintext highlighter-rouge">fact(1)</code> 은 1이므로 2 * 1 을 계산하여 <code class="language-plaintext highlighter-rouge">fact(2) = 2</code> 라는 것을 알 수 있습니다. 다음으로 3을 보면…</p><p>이렇게 한 단계씩 살펴보면 좀 더 수월하게 재귀함수를 파악할 수 있습니다.</p><p>여기서 추가적으로 알아야 할 것이 있는데, 바로 <strong>호출 스택</strong> 이라는 개념입니다. 코드에서 함수를 실행하면, 컴퓨터는 함수를 실행한 지점 등의 정보를 “호출 스택” 에 푸시(Push) 해줍니다. 그 이유는, 함수를 호출했다면 해당 함수가 종료된 후에 다시 함수를 호출한 곳부터 코드를 이어서 실행해야 하기 때문이죠.</p><p>그래서 <code class="language-plaintext highlighter-rouge">fact(3)</code> 를 호출하면 <code class="language-plaintext highlighter-rouge">[ fact(3), fact(2), fact(1) ]</code> 와 같이 호출 스택에 들어가게 되고 <code class="language-plaintext highlighter-rouge">fact(1)</code> 부터 차례대로 팝(Pop) 하게 됩니다. 그래서 실행한 것의 역순으로 코드가 끝나게 되죠. 여기서 만약에 재귀 호출이 매우 많아져서 메모리에 공간이 부족해지면 <strong>스택 오버플로(Stack Overflow)</strong> 라는 오류가 발생합니다.</p><p>자 그럼, 이 재귀함수가 왜 필요할까요? 재귀함수는 하나의 큰 문제를 작은 <strong>부분문제</strong> 들로 나눌 수 있습니다. 위의 팩토리얼 예제를 보아도 함수가 하나의 팩토리얼을 전부 계산하지 않고 현재 자신 번째의 값만 계산하고, 다음 값의 계산은 재귀호출로 처리하였습니다. 또는, 한 알고리즘에서 같은 알고리즘을 반복해야 하는 경우에도 사용됩니다. 예를 들어, 한 폴더를 지정해서 그 폴더 안의 모든 파일을 출력하는 알고리즘의 경우, 반복문으로는 풀기 힘듭니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// ...생략</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dir</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="s">"Folder"</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
      <span class="c1">// ...중략</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><p>위는 실제 동작하지는 않는 의사 코드(Pseudo Code) 인데, 만약 보고있는 파일이 폴더라면 그 폴더에 대해 반복문을 추가로 돌아야 하는데, 폴더가 몇 단계까지 되어있는지도 모르고, 그렇다 하더라도 반복문을 계속 이어나갈 수는 없죠. 여기서 재귀 함수를 쓰면 훨씬 간단하게 처리할 수 있습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">printFileNames</span><span class="p">(</span><span class="n">Directory</span> <span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dir</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="s">"Folder"</span><span class="p">)</span>
      <span class="n">printFileNames</span><span class="p">(</span><span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>읽은 파일 타입이 폴더일 경우, 자기 자신에 해당 파일(폴더)를 매개변수로 넣어 호출해주는 것이죠. 이로 인해 코드도 매우 작고 깔끔해졌습니다. 작동하는 코드가 아니라 작동 방식은 이해하기 힘들어도, 어떤 느낌인지는 파악했다고 생각합니다. 재귀 함수는 알고리즘 풀이에서 기초이자 필수인 부분으로, 꼭 여러 예제와 문제들을 살펴보아 복습하시길 바랍니다.</p><h2 id="연결-리스트"><span class="mr-2">연결 리스트</span><a href="#연결-리스트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>연결 리스트는, 배열과 비슷하지만 내부 기능은 전혀 다른 자료구조입니다. 배열은 한번 선언하면 메모리 내에 연속적으로 존재하게 되어서 처음 인덱스부터 N칸 뒤의 메모리 주소에 접근하는 것으로 O(1) 만에 읽기가 가능하다고 했었습니다. 하지만 연결 리스트는 원소들이 전부 메모리에 따로따로 위치한 자료구조입니다.</p><p>그럼 어떻게 값들을 저장하는 것일까요? 배열의 각 원소는 저장해야 할 값 뿐만 아니라 다음 원소의 주소 또한 지니고 있습니다. 그래서 만약 인덱스 4의 원소를 읽으려면 인덱스 0부터 시작해서 다음 주소, 다음 주소… 이렇게 0 - 1 - 2 - 3 인덱스를 참조해야 인덱스 4를 읽을 수 있습니다. 이 때 이 연속되게 위치하지 않은 원소들을 <strong>노드(Node)</strong> 라고 부릅니다.</p><p>그래서 배열과 비교해서 연결 리스트의 장점은 무엇일까요? 우선 배열의 경우, 원소를 10000개 가지게 선언하려면 원소 10000개 만큼의 <strong>연속된 빈 메모리 공간</strong> 이 있어야 합니다. 하지만 연결 리스트는 연속되지 않더라도 10000개의 빈 공간만 있어도 되죠. 배열에서 읽기는 O(1)이지만, 연결 리스트에서 읽기는 O(N)입니다. 그래서 읽기를 많이 하는 경우라면, 배열이 더 좋겠죠. 검색은 둘 다 동일하게 O(N)이 걸립니다.</p><p>하지만 삭제와 삽입의 경우, 배열은 O(N)이지만 연결 리스트는 <strong><em>O(1)</em></strong> 이 걸립니다. 왜냐하면, 배열의 경우 중간에 있는 원소를 삭제하거나 중간에 삽입하려면 원소들을 전부 한 칸씩 밀어주어야 하지만 연결 리스트는 그냥 “A-&gt;B-&gt;C 에서 B를 삭제하려면, A가 C를 가리키게 한다” 고 하면 끝이기 때문이죠. 삽입의 경우에도 “A-&gt;C 사이에 B를 넣으려면 A가 B를 가리키게 만들고, B는 C를 가리키게 만든다” 라고 하면 끝입니다. 물론 삽입하는 공간을 찾기 위해서 O(N) 정도가 소요되기는 하죠.</p><p>C언어와 포인터를 다루지 않았다면, 이를 직접 구현할 일은 없고 언어에서 지원하는 것을 사용하게 될 겁니다. 직접 구현한다 하더라도, C#과 Java처럼 가비지 컬렉터(Garbage Collector, 안쓰이는 메모리를 자동으로 해제) 가 있지 않다면 수동으로 메모리를 해제해야 한다는 것 또한 까다롭습니다. 그러니까 연결 리스트는 개념만 알아두도록 합시다!</p><p>여기서 <strong>이중 연결 리스트</strong> 라는 것도 볼 수 있는데, 이는 노드 하나가 자신의 다음 번째 원소뿐 아니라 자신의 이전 번째 원소의 위치 또한 가지고 있게 하는 것입니다. 그래서 원래는 0번째부터 단방향 이었다면 이중 연결 리스트는 양방향으로 움직일 수 있다는 거죠.</p><p>결론적으로, 연결 리스트는 “값의 삭제와 삽입이 빈번하게 일어나는 경우” 에 사용된다고 볼 수 있습니다. 적재적소에 필요한 자료구조를 사용하도록 합시다!</p><h2 id="이진-트리"><span class="mr-2">이진 트리</span><a href="#이진-트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>이진 트리(Binary Tree)는 <strong>트리(Tree)</strong> 자료구조의 한 종류로, 연결 리스트와 비슷하게 각 노드가 여러 노드의 주소를 지니고 있는 자료구조입니다.</p><pre><code class="language-mermaid">flowchart TD
    Food --&gt; Fruit &amp; Meat
    Fruit --&gt; Apple &amp; Mango
    Meat --&gt; Beef &amp; Pork
</code></pre><p>이진 트리는 위와 같이 Food가 <code class="language-plaintext highlighter-rouge">Fruit과 Meat</code>로, Fruit가 <code class="language-plaintext highlighter-rouge">Apple과 Mango</code>로, Meat가 <code class="language-plaintext highlighter-rouge">Beef와 Pork</code>로 연결되어 있습니다. 여기서 가장 상위인 노드인 Food를 <strong>루트(Root)</strong> 라고 부르며, 트리의 꼭대기가 됩니다. 여기서 Food를 Fruit과 Meat의 <strong>부모</strong> 라고 하고, Fruit과 Meat는 Food의 <strong>자식</strong> 이라고 합니다. 그리고 트리에는 깊이를 뜻하는 <strong>레벨(Level)</strong> 이 있는데, 위 트리의 레벨은 3입니다.</p><p>“트리” 의 경우, 한 노드가 여러 개의 자식을 지닐 수 있지만 이진 트리는 <strong>2개 이하</strong>로만 자식을 지닐 수 있다는 제약이 존재합니다. 이번 예제에서는 여기에서 더 나아가 “왼쪽은 부모보다 작은 값을 가지고, 오른쪽은 부모보다 큰 값을 가진다” 라는 조건을 더해보겠습니다. 그러면 루트부터 시작해서 원하는 값을 찾을 때, 현재 찾으려는 값이 노드의 값보다 더 크다면 오른쪽 자식으로, 작다면 왼쪽 자식으로 이동하며 <strong>이진 검색</strong> 과 동일한 구조를 보여줄 수 있죠. 이는 “정렬된 배열에서의 이진 검색” 과 비슷하지만, 연결 리스트와 같이 노드 기반의 자료구조이기 때문에 삽입과 삭제 시에도 O(log N)이 걸린다는 특징이 있습니다. (이를 “이진 검색 트리” 라고 합니다)</p><p>이진 트리는 검색, 삽입, 삭제에서 모두 O(log N) 이기 때문에 안정적이면서 매우 효율적인 자료구조이고, 그로 인해 힙 트리(Heap) 등 다양한 분류가 존재합니다. 물론 이 외에도 트리 자체가 일상 생활에서 자주 보는 계층 구조를 가지고 있기 때문에 B트리, 레드-블랙 트리 등 다양하니 한번 더 찾아보는 것을 추천합니다!</p><h3 id="힙"><span class="mr-2">힙</span><a href="#힙" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>힙(Heap)은 <strong>완전 이진 트리</strong> 로써, 완전 이진 트리란 마지막 레벨의 노드를 제외하면 모두 두 개의 자식 노드가 있고 마지막 레벨에서는 왼쪽부터 차례대로 노드가 있는 트리입니다. 완전 이진 트리는 루트를 1번째부터 시작하면 자식 노드를 i * 2 + 1과 i * 2 + 2번째에 위치시킬 수 있어 배열로 간단하게 구현이 가능합니다. 여기서 힙의 특징은, 최대/최소값이 항상 루트에 존재해야 하고 부모 노드는 자식 노드보다 항상 크거나 작아야 합니다. 이를 각각 최대 힙과 최소 힙이라고 합니다.</p><blockquote><p>힙의 삽입 연산</p></blockquote><p>최대 힙을 기준으로 설명하면, 힙의 조건을 만족하기 위해 마지막 노드의 오른쪽에 원소를 삽입한 후에 부모와 값을 비교하여 만약 부모보다 크다면 서로 위치를 교환합니다. 이를 재귀적으로 실행하여 자신의 값이 부모보다 작을 때까지 반복합니다.</p><blockquote><p>힙의 삭제 연산</p></blockquote><p>힙에서는 가장 큰 원소만 삭제할 수 있기 때문에 루트 노드를 삭제해야 하는데, 이 후에 힙의 조건을 만족하기 위해 트리의 마지막 노드와 루트 노드를 교환하고, 마지막 노드를 삭제합니다. 그 후에 루트 노드부터 자식 노드들을 비교하며 둘 중 더 큰 노드와 위치를 교환합니다. 이를 재귀적으로 실행하여 루트 노드의 값보다 큰 값이 없을 때까지 반복합니다.</p><p>힙의 삽입과 삭제는 모두 O(log N) 의 시간이 걸립니다. 여기서 추가로 힙의 초기화 연산에 대해서 알아보도록 하겠습니다.</p><blockquote><p>힙의 초기화</p></blockquote><p>힙을 초기화한다고 하면, 원소를 전부 삽입하는 것을 떠오를 수 있습니다. 이는 O(N log N) 의 시간이 걸리는데, 힙 생성 알고리즘을 사용하면 O(N) 시간만에 초기화가 가능합니다. 개념은 간단한데, 트리의 맨 밑부터 완성해 나아가는 방식입니다. 보통 힙을 직접 구현할 일은 없기 때문에 언어 차원에서 지원하는 힙 초기화 알고리즘을 사용하면 됩니다.</p><p>C++의 경우는 STL의 priority_queue를 사용하면 됩니다.</p><h3 id="세그먼트-트리"><span class="mr-2">세그먼트 트리</span><a href="#세그먼트-트리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>아래 글과 같이 그림으로 각 단계별 설명을 보는 것이 나을 것이라 생각하여 링크를 첨부합니다. 참고로, N이 입력값이고 H가 트리의 높이일 때 H = log<sub>2</sub>N이고 배열의 크기이자 노드의 최대개수는 2^H-1 라고 하는데, 문제풀이에서는 N*4 를 트리 배열의 크기로 해도 괜찮습니다. 적당히 비슷하지만 모자라지 않는 값이 나오기 때문이죠.</p><p><a href="https://book.acmicpc.net/ds/segment-tree">BOJ Book - Segment Tree</a></p><h2 id="그래프"><span class="mr-2">그래프</span><a href="#그래프" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>그래프는 데이터의 연결관계를 나타내는 자료구조입니다.</p><p><img data-src="https://termsigening97.github.io/assets/img/Lecture/Basic/Graph.png" alt="Graph" data-proofer-ignore></p><p>여기서 1, 2, 3 과 같은 각 노드(node)들을 정점이라고 부르고 각 선을 간선(edge) 라고 부릅니다. 여기서 정점은 편의상 노드라고 부르는 경우가 많습니다.</p><p>그래프는 일반적으로 해시 테이블을 이용해 구현하는데, 예를들어 친구관계를 나타낼 때 다음과 같이 할 수 있습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">friends</span><span class="p">[</span><span class="s">"Tom"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Jerry"</span><span class="p">;</span>
<span class="n">friends</span><span class="p">[</span><span class="s">"Tom"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Clancy"</span><span class="p">;</span>
<span class="n">friends</span><span class="p">[</span><span class="s">"Jerry"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Tom"</span><span class="p">;</span>
<span class="n">friends</span><span class="p">[</span><span class="s">"Clancy"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Tom"</span><span class="p">;</span>
</pre></table></code></div></div><p>하지만 일반적인 알고리즘 문제를 풀 때나, 단순 번호로 각 노드들을 나타낸다면 일반 배열도 사용할 수 있습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">friends</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">friends</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">friends</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">friends</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><p>위와 같이 각 노드들이 전부 서로 연결되어 있는 <strong>무방향 그래프</strong>도 있지만, A에서 B로 갈 수는 있지만 B에서 A를 갈 수는 없는 그래프도 존재하는데 이걸 <strong>방향 그래프</strong> 라고 합니다. 또한, 간선마다 가중치(weight) 가 있어서 예를들어 A 도시에서 B로 가는 거리 등을 수치로 나타낸 것을 <strong>가중 그래프</strong> 라고 합니다.</p><h3 id="bfs"><span class="mr-2">BFS</span><a href="#bfs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>A-B-C-D 로 연결되어 있을때, A와 연결된 모든 정점들을 알려면 어떻게 해야할까요? 이렇게 그래프를 탐색할 일이 많기 때문에 이를 위한 알고리즘이 존재합니다.</p><p>BFS는 그래프 전체를 탐색하기 위한 방법이며 너비우선탐색(Broad-First-Search) 라고 불립니다. 너비우선탐색이라는 이름이 붙은 이유는 시작한 정점과 이어진 정점을 먼저 탐색하고, 그 다음에는 한 칸 떨어진 정점을 전부 탐색하고, 그 다음에는 두 칸… 이런식으로 거리가 i인 정점을 먼저 전부 방문해야만 거리가 i + 1인 정점을 방문하기 때문입니다. 이를 구현하기 위해 큐(Queue)를 사용하여 자신이 다음에 방문할 정점들을 저장합니다. 가장 가까이 연결된 정점들이 먼저 큐에 저장되고, 먼저 꺼내지기 때문에 가까이 있는 순서대로 방문하게 되는 것이죠.</p><p>BFS를 구현하기 위해 우선, 시작하고 싶은 정점을 선택하여 큐에 넣습니다. 이 큐는 “앞으로 내가 방문해야 하는 정점들의 목록” 을 방문할 순서대로 넣어두기 위해 사용됩니다.</p><p>그 후에 큐에서 정점을 꺼내서 해당 정점과 연결된 모든 정점들 중 <strong>방문하지 않은 정점</strong>들을 전부 큐에 넣고, 해당 정점들을 방문했다고 표시해줍니다. 이 때, 표시를 위해 별도의 배열(자료구조)이 필요합니다. 지금 이 과정을 큐가 완전히 비워질 때까지 반복하면 BFS는 끝이나게 됩니다.</p><p>queue를 사용하기 위해 C++로 나타낸 코드는 다음과 같습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">graph</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="p">};</span>

<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
  <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// 만약 node-&gt;i 의 경로가 있고 i를 방문하지 않았다면</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>graph는 2차원 배열로, graph[a][b] 는 a에서 b로 연결되어 있는지를 나타냅니다. 1이라면 연결됨, 0이라면 연결 안됨입니다. 그래프 자체는 이 외에도 매우 다양한 방법으로 표현이 가능한데, 동적 배열을 이용해서 자신과 연결된 정점들의 번호만 저장하거나 해시 테이블을 사용하면 메모리를 훨씬 절약할 수 있습니다.</p><h3 id="dfs"><span class="mr-2">DFS</span><a href="#dfs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>DFS는 BFS와 동일하게 그래프를 탐색하기 위한 알고리즘인데, 큐 대신 스택을 쓴다는 점이 다릅니다. 스택을 사용하기 때문에 마지막에 등록된 정점을 먼저 방문하며, 그로 인해 한번 탐색할 때 가능한 깊게 탐색하기 때문에 깊이우선탐색(Depth-First-Search) 라고 합니다. 그 외에는 BFS와 다른 점이 없기 때문에 설명을 생략합니다. 단, 스택을 사용한다는 특성상 DFS는 재귀함수를 사용해서 더 간단하게 코드를 작성할 수 있습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
	<span class="n">visited</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
			<span class="n">DFS</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>여기서 graph[x] 는 x와 연결된 정점들의 번호를 가지고 있는 배열이며, size() 함수를 사용해 배열의 길이를 알 수 있습니다.</p><p>만약 재귀함수를 사용하지 않는다면 BFS 예제와 동일하게 구현할 수 있습니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
  <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
      <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="다익스트라-알고리즘"><span class="mr-2">다익스트라 알고리즘</span><a href="#다익스트라-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>데이크스트라 알고리즘 혹은 다익스트라 알고리즘으로 불리는 Dijkstra Algorithm은 음의 가중치가 없는 그래프에서 한 정점부터 다른 모든 정점까지의 최단거리를 구하는 알고리즘입니다. 다음과 단계로 이루어지는데,</p><ol><li>방문할 정점 목록에서 정점을 꺼내 현재 정점으로 한다<li>현재 정점과 인접한 모든 정점에 대해 각 정점이 가지고 있던 최단거리와 현재 정점을 거쳐서 가는 거리를 비교, 갱신한다<li>방문하지 않은 가장 거리가 짧은 정점을 현재 정점으로 한다</ol><p>위 작업을 반복하면 끝이 나게 됩니다. 시작 정점으로부터 모든 정점의 최단거리를 나타내는 배열과, 각 정점을 방문했는지 확인해주는 배열이 필요합니다. 이 때, 3번 작업을 선형 검색으로 한다면 비효율적이므로, 주로 힙을 사용하게 됩니다.</p><h3 id="벨만-포드-알고리즘"><span class="mr-2">벨만-포드 알고리즘</span><a href="#벨만-포드-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>음수 가중치가 있는 그래프는 다익스트라로 정확한 결과를 얻을 수 없습니다. 그래서 사용 되는 것이 벨만-포드(Bellman-Ford) 알고리즘인데, A 정점 -&gt; B 정점의 최단 경로를 구할 때, 모든 간선에 대해 거리가 짧아지는 경우에 최단거리를 갱신하는 방법입니다.</p><h3 id="플로이드-와샬-알고리즘"><span class="mr-2">플로이드-와샬 알고리즘</span><a href="#플로이드-와샬-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>만약 모든 정점에서 모든 정점으로의 최단 거리를 구하고 싶다면, 플로이드-와샬 알고리즘을 사용합니다. 만약 A번 정점에서 B번 정점으로 가는 거리보다, A번 정점 -&gt; i번 정점 -&gt; B번 정점 을 거쳐가는 거리가 더 짧다면 거리를 갱신해주는 형태로 매우 간단합니다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// V는 정점들의 개수입니다</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAX</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">distance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">MAX</span><span class="p">));</span>

<span class="c1">// 그래프 가중치로 초기화</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

  <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 플로이드-와샬</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mid</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">mid</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">start</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">+</span> <span class="n">distance</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">end</span><span class="p">])</span>
        <span class="n">distance</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">+</span> <span class="n">distance</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">end</span><span class="p">];</span>

</pre></table></code></div></div><p>단, 음수 가중치는 처리하지 못하므로 <code class="language-plaintext highlighter-rouge">distance[i][i]</code> 가 음수라면 음수 가중치 사이클이 있는것으로 판단합니다.</p><h3 id="존슨-알고리즘"><span class="mr-2">존슨 알고리즘</span><a href="#존슨-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>존슨 알고리즘은 다익스트라 알고리즘과 벨만-포드 알고리즘의 장점을 합한 것으로, 다익스트라 만큼의 시간복잡도를 가지고 있지만 음수 가중치 또한 계산될 수 있습니다. 그 방법은 전체 에지 가중치를 음수가 아닌 형태로 변환하는 것으로, 더미(dummy) 정점을 만들고 이 정점과 나머지 모든 정점 사이에 가중치가 0인 에지를 연결하여 벨만-포드 알고리즘으로 더미 정점과 최단 거리를 찾고, 기록합니다. 그리고 그래프의 최단 거리를 구할 때, 정점의 거리 사이에 아까 구해둔 최단거리를 추가하여 이렇게 만들어진 그래프에 다익스트라 알고리즘을 사용하여 구할 수 있습니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/lecture/'>Lecture</a>, <a href='/categories/basic/'>Basic</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/essence/" class="post-tag no-text-decoration" >Essence</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=자료구조와 알고리즘 - Sigening&amp;url=https://termsigening97.github.io/posts/data-structure-and-algorithms/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=자료구조와 알고리즘 - Sigening&amp;u=https://termsigening97.github.io/posts/data-structure-and-algorithms/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://termsigening97.github.io/posts/data-structure-and-algorithms/&amp;text=자료구조와 알고리즘 - Sigening" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/unity-optimization/">유니티 그래픽스 최적화</a><li><a href="/posts/Scraps/">지식 스크랩</a><li><a href="/posts/data-structure-and-algorithms/">자료구조와 알고리즘</a><li><a href="/posts/C-lecture/">C언어 총정리</a><li><a href="/posts/game-design/">게임 디자인</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cpp/">CPP</a> <a class="post-tag" href="/tags/essence/">Essence</a> <a class="post-tag" href="/tags/game-design/">Game Design</a> <a class="post-tag" href="/tags/architect/">Architect</a> <a class="post-tag" href="/tags/optimize/">Optimize</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/algorithmic-paradigm/"><div class="card-body"> <em class="timeago small" data-ts="1648825200" > 2022-04-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>알고리즘 패러다임</h3><div class="text-muted small"><p> 알고리즘 패러다임 알고리즘 패러다임(Algorithmic Paradigm) 혹은 알고리즘 디자인 패러다임은 자주 등장하는 알고리즘 접근법을 의미하며, 여러 문제에 통상적으로 사용될 수 있습니다. 이 게시글을 이해하기 위해서는 일반적인 자료구조와 재귀함수를 응용할 수 있어야 함을 알립니다. 완전탐색 브루트 포스(Brute Force) 알고리즘이며,...</p></div></div></a></div><div class="card"> <a href="/posts/C-lecture/"><div class="card-body"> <em class="timeago small" data-ts="1632884400" > 2021-09-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C언어 총정리</h3><div class="text-muted small"><p> 이 강좌는 C언어의 기초 필수 문법을 설명합니다. 초보자가 쉽고 빠르게 이해할 수 있도록 구성되어 있으며, 꼭 지금 알 필요 없는 어려운 개념들은 부록으로 정리하였습니다. 내용이 많이 함축되어 있기 때문에 모든 내용을 정확히 이해하고 넘어가도록 합시다! Visual Studio 시작하기 Visual Studio 위 링크에서 Visual Stu...</p></div></div></a></div><div class="card"> <a href="/posts/clean-architecture/"><div class="card-body"> <em class="timeago small" data-ts="1646103600" > 2022-03-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Clean Architecture - 시스템 설계</h3><div class="text-muted small"><p> 프로그래밍 패러다임 구조적 프로그래밍structured programming 1968년 Edsger Wybe Dijkstra가 발견했으며, 무분별한 점프(goto)는 프로그램 구조에 해롭다는 사실을 제시했고, 이런 점프들을 if/then/else와 do/while/until과 같은 것으로 대체하였다. 구조적 프로그래밍은 제어흐름의 직접적인 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/puzzle-design/" class="btn btn-outline-primary" prompt="Older"><p>퍼즐 디자인</p></a> <a href="/posts/C-to-CPP/" class="btn btn-outline-primary" prompt="Newer"><p>C대신 C++로 알고리즘 풀기</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "termsigening97/termsigening97.github.io", "data-repo-id": "R_kgDOG6QKqw", "data-category": "Announcements", "data-category-id": "DIC_kwDOG6QKq84CBWWc", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/termsigening97">Jun Hwi Gu</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/boj/">BOJ</a> <a class="post-tag" href="/tags/cpp/">CPP</a> <a class="post-tag" href="/tags/essence/">Essence</a> <a class="post-tag" href="/tags/game-design/">Game Design</a> <a class="post-tag" href="/tags/architect/">Architect</a> <a class="post-tag" href="/tags/optimize/">Optimize</a> <a class="post-tag" href="/tags/other/">Other</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
